<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>wastecat的博客</title>

  
  <meta name="author" content="wastecat">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="wastecat的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wastecat的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">wastecat的博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2020/04/29/hello-world/"><span>你好世界</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/04/29/hello-world/" rel="bookmark">
        <time class="entry-date published" datetime="2020-04-29T18:56:21.497Z">
          2020-04-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2020/04/29/hello-world/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/20/网件R6220刷机LEDE（openwrt）固件教程/"><span>网件 R6220 刷机 LEDE（openwrt）固件教程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/20/网件R6220刷机LEDE（openwrt）固件教程/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-20T07:22:39.000Z">
          2017-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>家里一直用的是网件的 R6220 路由器，之前一直用的是原厂固件，因为本人不太喜欢在主路由器上装奇奇怪怪的东西，另外是因为 R6220 一直都没有好用的固件可以刷，前几天逛论坛发现竟然已经有人破解了 R6220 可以刷 LEDE 和 pandora 了，忍不住手痒又去刷了一波固件。此文记录一下过程。</p>
<p><a href="/notename/" title="install lede on netgear r6220"></a></p>
<p>[toc]</p>
<blockquote>
<p><strong>请全程使用网线连接进行操作，操作时千万不要断电，因为 R6220 使用 NAND flash，刷坏后无法使用普通编程器修复，刷机有风险，请扶稳方向盘谨慎驾驶</strong></p>
</blockquote>
<h2 id="1-开启路由器telnet"><a href="#1-开启路由器telnet" class="headerlink" title="1. 开启路由器telnet"></a>1. 开启路由器telnet</h2><p>在浏览器打开 <a href="http://192.168.1.1/setup.cgi?todo=debug" target="_blank" rel="noopener">http://192.168.1.1/setup.cgi?todo=debug</a> 这个网址，记着把 192.168.1.1 替换成你路由器的 ip 地址，成功后会显示 <code>Debug Enabled !</code> 说明已经成功。</p>
<p>使用 Mac 或 Linux 的用户，打开终端，执行 <code>telnet 192.168.1.1</code> ，可以登录到路由器的管理shell里，使用 windows 的用户，可以<a href="https://the.earth.li/~sgtatham/putty/latest/w32/putty.exe" target="_blank" rel="noopener">点这里</a>下载 putty，然后如下图，Host Name填路由器ip，port写23，connection type 选 telnet：</p>
<p><img src="http://static.zybuluo.com/zwh8800/87dgejkt4rs7ov1wgy8ejzyx/image_1bnv9ksf91joebhc5uvi451l14p.png" alt="image_1bnv9ksf91joebhc5uvi451l14p.png-84.3kB"></p>
<p>点击 open 之后，会出现一个黑屏窗口，显示 <code>R6220 login:</code> ，输入 <code>root</code> 按回车，会显示一个大的 logo 和一个 <code>#</code> 号（如下），此时说明已经登录成功了。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Welcome to</span><br><span class="line">    _______  _______  ___     __  ____   _  _   ___</span><br><span class="line">    |<span class="string">  ___  \</span>|<span class="string">   __  </span>||<span class="string">   </span>|<span class="string">   </span>|<span class="string">__</span>||<span class="string">    \ </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string"> /  /</span></span><br><span class="line"><span class="string">    </span>|<span class="string"> </span>|<span class="string">___</span>|<span class="string"> </span>||<span class="string">  </span>|<span class="string">__</span>|<span class="string"> </span>||<span class="string">   </span>|<span class="string">__  __ </span>|<span class="string">     \</span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">/  /</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   _   /</span>|<span class="string">   _   </span>||<span class="string">      </span>||<span class="string">  </span>||<span class="string"> </span>|<span class="string">\     </span>||<span class="string">     \</span></span><br><span class="line"><span class="string">    </span>|<span class="string">__</span>|<span class="string"> \__\</span>|<span class="string">__</span>|<span class="string"> </span>|<span class="string">__</span>||<span class="string">______</span>||<span class="string">__</span>||<span class="string">_</span>|<span class="string"> \____</span>||<span class="string">_</span>|<span class="string">\___\</span></span><br><span class="line"><span class="string">                     =System Architecture Department=</span></span><br><span class="line"><span class="string">#</span></span><br></pre></td></tr></table></figure>

<h2 id="2-备份eeprom"><a href="#2-备份eeprom" class="headerlink" title="2. 备份eeprom"></a>2. 备份eeprom</h2><blockquote>
<p>此步骤可跳过，但有一定几率无法使用 Wi-Fi</p>
</blockquote>
<p>准备一个格式化成 fat32 的U盘（最好重新格式化，卷标写成U），插入 R6220 的USB口中，然后在刚才的黑窗口里输入命令：<code>ls /mnt/shares</code></p>
<p>会显示出你刚才优盘的卷标名，如果重新格式化成 U 了，那么就会显示一个 U。</p>
<p>下一步，执行 <code>cd /mnt/shares/优盘的卷标名</code> ，同理如果刚才显示 U 这里就应该执行 <code>cd /mnt/shares/U</code>。</p>
<p>如果没有报错的话就进行下一步：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/mtd10 <span class="attribute">of</span>=./mtd10.bin</span><br></pre></td></tr></table></figure>

<p>这是为了把 eeprom 备份到U盘中。如果执行之后，显示一个 <code>#</code> 说明成功了。现在把U盘拔下来插到电脑上，可以看到一个 mtd10.bin 文件，把它复制到电脑上备份。</p>
<h2 id="3-刷写不死-bootloader-pb-boot"><a href="#3-刷写不死-bootloader-pb-boot" class="headerlink" title="3. 刷写不死 bootloader pb-boot"></a>3. 刷写不死 bootloader pb-boot</h2><p>从这里下载 pb-boot：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1jIONs6i" target="_blank" rel="noopener">https://pan.baidu.com/s/1jIONs6i</a> 密码: nyn9</p>
</blockquote>
<p>把这个文件放到U盘里，插入到路由器中。</p>
<p>使用 telnet 登陆到路由器，和第二步一样，执行 <code>cd /mnt/shares/U</code> 进入到U盘文件夹。执行下面的命令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd_write write pb-boot-r6220<span class="number">-20170801.</span>img Bootloader</span><br></pre></td></tr></table></figure>

<p>成功后会显示：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unlocking Bootloader <span class="built_in">..</span>.</span><br><span class="line">Writing <span class="keyword">from</span> pb-boot-r6220.bin <span class="keyword">to</span> Bootloader <span class="built_in">..</span>.  [w]</span><br></pre></td></tr></table></figure>

<p>接下来路由器关机，然后用针扎着reset键开机，开机后发现电源灯和wan口灯呼吸闪烁，说明进入了 bootloader，在浏览器中输入 192.168.1.1 会看到 pb-boot 的界面：</p>
<p><img src="http://static.zybuluo.com/zwh8800/say5dhokusmabok0w2ix1d8x/image_1bnvblmm81d0t1hgfpfu1h0ft4116.png" alt="image_1bnvblmm81d0t1hgfpfu1h0ft4116.png-107.3kB"></p>
<p>现在说明不死 bootloader 已经刷好了，可以随意折腾路由器而不怕刷坏了，无论何时感觉刷坏了，都可以用针扎着reset键开机，来反复刷机重置系统。</p>
<blockquote>
<p>小知识：bootloader 是在操作系统运行之前先运行的一个小程序，类似电脑的 bios，折腾路由器时就算把系统搞坏了，只要 bootloader 没被破坏，都可以刷回出厂设置的。</p>
</blockquote>
<h3 id="3-1-mac-用户会遇到的坑"><a href="#3-1-mac-用户会遇到的坑" class="headerlink" title="3.1 mac 用户会遇到的坑"></a>3.1 mac 用户会遇到的坑</h3><p>使用 mac 的用户再刷写了 pb-boot 之后，会发现无法获取到 IP 地址，可以这样操作：</p>
<p>在<strong>系统偏好设置</strong>中点网络，把网卡设置成下图所示：</p>
<p><img src="http://static.zybuluo.com/zwh8800/s5ltalpg46voaket5azleek1/image_1bnvc6apsorr15en13he1l7s1mei1j.png" alt="image_1bnvc6apsorr15en13he1l7s1mei1j.png-107.3kB"></p>
<p>打开<strong>终端</strong>反复执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">arp</span> <span class="selector-tag">-ad</span></span><br><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">arp</span> <span class="selector-tag">-s</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span></span><br></pre></td></tr></table></figure>

<p>第一次可能会要求你输密码，输入即可</p>
<p>每执行一遍就再浏览器中刷新一次 192.168.1.1 ，直到浏览器能打开网页后停止执行命令。</p>
<h2 id="4-刷-LEDE-官方固件"><a href="#4-刷-LEDE-官方固件" class="headerlink" title="4. 刷 LEDE 官方固件"></a>4. 刷 LEDE 官方固件</h2><p>一开始我是在 <a href="http://www.right.com.cn/forum/thread-208580-1-1.html" target="_blank" rel="noopener">恩山无限论坛</a> 下载的网友编译的固件，他的固件本身集成了好多功能，比如 广告屏蔽大师和s-s，不爱折腾的人刷他的固件用自带的功能就够用了，但是他的固件有个问题，固件的内核版本不是官方的版本，没办法安装官方软件仓库里的 kmod 软件包（可以强制安装，但是会大几率无限重启），另外固件的 opkg 好像也没有配置好，安装软件包会比较折腾。所以我建议还是先刷网友版，然后升级成官方版。</p>
<p>先从这里下载恩山网友版固件</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1c1YSCLy" target="_blank" rel="noopener">https://pan.baidu.com/s/1c1YSCLy</a> 密码: 36vm</p>
</blockquote>
<p>然后在 192.168.1.1 里，点击 browse 选择刚才下载的网友版固件，再点击 Firmware update，等 1 分钟就刷好了。</p>
<p>再次刷新 192.168.1.1 网页，发现已经进入 lede 的界面了。</p>
<p><img src="http://static.zybuluo.com/zwh8800/noqu5zni5zwm6uazgqiy4i1o/image_1bnvcca3pf6dfb6177rr9b70o20.png" alt="image_1bnvcca3pf6dfb6177rr9b70o20.png-23.1kB"></p>
<p>用户名填 root，密码输admin，进入到管理界面中。</p>
<p>然后左侧点击<strong>网络</strong>、<strong>接口</strong>，把 WAN 口配置好，尝试一下能不能上去网。</p>
<p>对于不想折腾的朋友到此为止就可以了，恩山网友版的固件足够好用，喜欢折腾的朋友继续看下面（如果发现Wi-Fi无法正常使用的请看<a href="#8-找不到-wi-fi或wi-fi信号很差">最下面</a>）。</p>
<p>点击左侧的<strong>系统</strong>，然后点击<strong>备份/升级</strong>。现在咱们要升级成 lede 官方版。</p>
<p>从这里下载官方版：<a href="https://downloads.lede-project.org/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar" target="_blank" rel="noopener">https://downloads.lede-project.org/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar</a></p>
<p>或者从中科大的镜像里下载：<a href="http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar</a></p>
<p>在刷写新的固件那一栏，选择刚下载的固件，然后点击刷写固件。</p>
<p>等 1 分钟后，路由器自动重启，此时官方固件已经刷好了。</p>
<h2 id="5-配置官方固件"><a href="#5-配置官方固件" class="headerlink" title="5. 配置官方固件"></a>5. 配置官方固件</h2><p>官方固件默认不开启Wi-Fi，默认不安装web管理界面，所以我们需要先使用命令行进行配置。</p>
<p>使用 <code>ssh root@192.168.1.1</code> 登陆，windows的朋友还使用 putty，但是 port 需填写 22，connection type 选 SSH。</p>
<p>然后输入 root 回车，再输入 admin 回车。</p>
<p><img src="http://static.zybuluo.com/zwh8800/oyll40uphimhngb1t8pmfcql/image_1bnvd5mqeofhlp61sa51q0c11fm2d.png" alt="image_1bnvd5mqeofhlp61sa51q0c11fm2d.png-22.6kB"></p>
<p>接着会看到一个 LEDE 的 logo，说明登陆成功了，下一步安装web管理界面。</p>
<blockquote>
<p>以下内容选作</p>
</blockquote>
<p>因为 lede 默认的软件仓库可能会比较慢，所以我们可以换成中科大的源，先执行vim：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/opkg/distfeeds.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>

<p>用 vim 打开 opkg 配置文件，然后多按几次键盘上的 <code>dd</code> 会发现之前的内容被删除了。之后按一下 键盘上的 <code>I</code> ，然后复制下面的内容，在终端里粘贴（putty用户直接在黑窗口里右键就可以了）</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src<span class="regexp">/gz reboot_core http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>targets<span class="regexp">/ramips/</span>mt7621/packages</span><br><span class="line">src<span class="regexp">/gz reboot_base http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>base</span><br><span class="line">src<span class="regexp">/gz reboot_luci http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>luci</span><br><span class="line">src<span class="regexp">/gz reboot_packages http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>packages</span><br><span class="line">src<span class="regexp">/gz reboot_routing http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>routing</span><br><span class="line">src<span class="regexp">/gz reboot_telephony http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>telephony</span><br></pre></td></tr></table></figure>

<p>然后按一下键盘上的 ESC 键，然后依次输入 <code>冒号</code>、<code>w</code>、<code>q</code>、<code>回车键</code>，退出到 shell 界面，现在中科大源就配置好了。</p>
<blockquote>
<p>以上内容选作</p>
</blockquote>
<p>接下来执行opkg来安装web管理界面，中文翻译和material皮肤：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg <span class="keyword">install </span>luci</span><br><span class="line">opkg <span class="keyword">install </span>luci-i18n-<span class="keyword">base-zh-cn</span></span><br><span class="line"><span class="keyword">opkg </span><span class="keyword">install </span>luci-theme-material</span><br></pre></td></tr></table></figure>

<p>短暂等待后就安装好了，在浏览器打开 192.168.1.1 就能看到路由器管理界面了。</p>
<blockquote>
<p>注意，此处有个小坑，如果在刚才升级到原版系统时，把 <strong>保留配置</strong> 的勾给去掉了，那么此时路由器是无法上网的，也就无法从软件仓库安装，所以如果你和我一样手贱去掉了那个勾，你现在可以把 R6220 接到一个已经配置好能上网的路由器的 LAN 口上，然后再进行 opkg install 操作。</p>
</blockquote>
<h2 id="6-安装upnp"><a href="#6-安装upnp" class="headerlink" title="6. 安装upnp"></a>6. 安装upnp</h2><p>官方版固件默认没有 upnp，需要ssh登陆到路由器执行下面命令安装：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">opkg</span> <span class="string">update</span></span><br><span class="line"><span class="attr">opkg</span> <span class="string">install luci-app-upnp</span></span><br></pre></td></tr></table></figure>

<p>或者也可以在<strong>系统</strong>、<strong>软件包</strong>里安装 <code>luci-app-upnp</code></p>
<p>然后在 <strong>服务</strong>、<strong>UPNP</strong>里勾选 Start UPnP and NAT-PMP service，点击保存&amp;应用</p>
<h2 id="7-编译广告屏蔽大师（adbyby）"><a href="#7-编译广告屏蔽大师（adbyby）" class="headerlink" title="7. 编译广告屏蔽大师（adbyby）"></a>7. 编译广告屏蔽大师（adbyby）</h2><p><a href="https://github.com/kuoruan/luci-app-adbyby" target="_blank" rel="noopener">广告屏蔽大师（英文名adbyby）</a>是一个很好用的 lede 应用，能屏蔽爱奇艺、优酷等一系列广告而且不用等待。</p>
<h3 id="7-1-下载SDK"><a href="#7-1-下载SDK" class="headerlink" title="7.1 下载SDK"></a>7.1 下载SDK</h3><p>中科大源：<a href="http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64.tar.xz" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64.tar.xz</a></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//mi</span>rrors.ustc.edu.cn<span class="regexp">/lede/</span>snapshots<span class="regexp">/targets/</span>ramips<span class="regexp">/mt7621/</span>lede-sdk-ramips-mt7621_gcc-<span class="number">5.4</span>.<span class="number">0</span>_musl.Linux-x86_64.tar.xz</span><br><span class="line">tar xvf lede-sdk-ramips-mt7621_gcc-<span class="number">5.4</span>.<span class="number">0</span>_musl.Linux-x86_64.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="7-2-下载adbyby"><a href="#7-2-下载adbyby" class="headerlink" title="7.2 下载adbyby"></a>7.2 下载adbyby</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/kuoruan/luci-app-adbyby.git</span><br></pre></td></tr></table></figure>

<h3 id="7-3-更新feeds"><a href="#7-3-更新feeds" class="headerlink" title="7.3 更新feeds"></a>7.3 更新feeds</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64</span></span><br><span class="line"><span class="string">./scripts/feeds</span> update -a</span><br></pre></td></tr></table></figure>

<h3 id="7-4-把-adbyby-放进-SDK"><a href="#7-4-把-adbyby-放进-SDK" class="headerlink" title="7.4 把 adbyby 放进 SDK"></a>7.4 把 adbyby 放进 SDK</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/luci-app-adbyby</span></span><br><span class="line">cp <span class="string">./adbyby</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64/package</span> -r</span><br><span class="line">cp <span class="string">./luci-app-adbyby</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64/feeds/luci/applications</span> -r</span><br></pre></td></tr></table></figure>

<p>把 adbyby 放到 package 里，把 luci-app-adbyby 放到 feeds/luci/applications 里。</p>
<h3 id="7-5-再更新-feeds"><a href="#7-5-再更新-feeds" class="headerlink" title="7.5 再更新 feeds"></a>7.5 再更新 feeds</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64</span></span><br><span class="line"><span class="string">./scripts/feeds</span> update -a</span><br><span class="line"><span class="string">./scripts/feeds</span> install luci-app-adbyby</span><br></pre></td></tr></table></figure>

<h3 id="7-6-编译"><a href="#7-6-编译" class="headerlink" title="7.6 编译"></a>7.6 编译</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">make menuconfig</span></span><br></pre></td></tr></table></figure>

<p>会打开一个界面，在里面用上下键移动光标，用回车键选择，先选 LuCI，再选 Appications，然后找到 luci-app-adbyby 按两下空格使前面变成 <code>[*]</code> ，然后一直按 ESC 退出，退出前会询问是否保存，选 YES。</p>
<p>然后执行 </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="attribute">V</span>=99</span><br></pre></td></tr></table></figure>

<p>最后会在 bin 文件夹编译出 luci-app-adbyby.ipk 文件，上传到路由器的/tmp 文件夹，执行 <code>opkg install luci-app-adbyby.ipk</code> 进行安装。</p>
<h2 id="8-找不到-Wi-Fi，或Wi-Fi信号很差"><a href="#8-找不到-Wi-Fi，或Wi-Fi信号很差" class="headerlink" title="8. 找不到 Wi-Fi，或Wi-Fi信号很差"></a>8. 找不到 Wi-Fi，或Wi-Fi信号很差</h2><p>如果刷了 lede 之后找不到Wi-Fi，可以把 eeprom 还原成原厂。</p>
<h3 id="8-1-把之前备份的-mtd10-bin-放到路由器中"><a href="#8-1-把之前备份的-mtd10-bin-放到路由器中" class="headerlink" title="8.1 把之前备份的 mtd10.bin 放到路由器中"></a>8.1 把之前备份的 <code>mtd10.bin</code> 放到路由器中</h3><p>在终端里执行：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp mtd10.bin <span class="symbol">root@</span><span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>:/tmp</span><br></pre></td></tr></table></figure>

<p>使用 windows 的用户可以下载一个 <a href="https://sourceforge.net/projects/winscp/files/WinSCP/5.9.6/WinSCP-5.9.6-Portable.zip/download" target="_blank" rel="noopener">WinScp</a> 来远程复制文件：</p>
<p>File protocol 选择 scp，hostname输入路由器IP，port写22，username写root，password写密码。</p>
<p><img src="http://static.zybuluo.com/zwh8800/6krs6kpjj5jtaxxs4we8ma47/image_1bnvf7v6un84c0v11qm1vku1sd37.png" alt="image_1bnvf7v6un84c0v11qm1vku1sd37.png-39.8kB"></p>
<p>点击login，然后再右侧窗口双击一下 <code>..</code> ，然后再双击 tmp 文件夹。然后再左侧窗口找到刚才备份的 mtd10.bin 文件，直接拖到右侧窗口的空白区域。</p>
<p><img src="http://static.zybuluo.com/zwh8800/5lt2mgcipjm2xiucliey687v/image_1bnvfagtt1k5f105kcgr7r132a3k.png" alt="image_1bnvfagtt1k5f105kcgr7r132a3k.png-193.8kB"></p>
<h3 id="8-2-还原-eeprom"><a href="#8-2-还原-eeprom" class="headerlink" title="8.2 还原 eeprom"></a>8.2 还原 eeprom</h3><p>使用 putty 或 ssh 登陆路由器，然后执行下面命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd -r <span class="keyword">write</span> <span class="regexp">/tmp/m</span>td10.bin factory</span><br></pre></td></tr></table></figure>

<p>成功后会自动重启。</p>
<p>然后在<strong>系统</strong>、<strong>备份/升级</strong>里重新上传sysupgrade.tar，并且不勾选<strong>保留设置</strong>。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/openwrt/">openwrt</a><a href="/tags/折腾/">折腾</a><a href="/tags/路由器/">路由器</a><a href="/tags/lede/">lede</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/08/20/网件R6220刷机LEDE（openwrt）固件教程/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/09/Caddy-方便够用的HTTPSserver新手教程/"><span>Caddy - 方便够用的 HTTPS server 新手教程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/09/Caddy-方便够用的HTTPSserver新手教程/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-09T11:51:49.000Z">
          2017-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>说起 HTTP server，使用最广泛的就是 apache 和 nginx 了，功能都非常强大，但相对而言，学习它们的配置是有一定难度的。最近发现了一个 golang 开发的 HTTP server，叫做 <a href="https://caddyserver.com/" target="_blank" rel="noopener" title="Caddy is the HTTP/2 web server with automatic HTTPS.">Caddy</a>，它配置起来十分简便，甚至可以 <a href="http://www.bilibili.com/video/av4219585/" target="_blank" rel="noopener" title="Caddy - Automatic HTTPS in 28s">28 秒配置好一个支持 http2 的 server </a> ，而且对各种 http 新特性都支持的比较早（比如 http2、quic都有支持）。因此对于不用于生产环境只搭建个人博客是十分友好的，我就简单介绍下 caddy。</p>
<p><a href="/notename/" title="caddy HTTP/2 web server guide for beginners"></a></p>
<p>[toc]</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>用过 golang 的应该都知道，golang 程序基本上不会有各种依赖，都是光秃秃一个可执行程序，cp 到 <code>/usr/local/bin</code> 就算安装完成了，所以说安装 caddy 是很简单的，我给出三种方法。</p>
<h3 id="1-1-脚本安装"><a href="#1-1-脚本安装" class="headerlink" title="1.1 脚本安装"></a>1.1 脚本安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://getcaddy.com | bash</span><br></pre></td></tr></table></figure>

<p>caddy 官方给出了一个安装脚本，执行上面的命令就可以一键安装 caddy，等执行结束后，使用 <code>which caddy</code>，可以看到 caddy 已经被安装到了 /usr/local/bin/caddy</p>
<h3 id="1-2-手动安装"><a href="#1-2-手动安装" class="headerlink" title="1.2 手动安装"></a>1.2 手动安装</h3><p><a href="https://caddyserver.com/download" target="_blank" rel="noopener">https://caddyserver.com/download</a> 点这个链接进入到 caddy 官网的下载界面，网页左侧可以选择平台和插件，如果在 Linux 服务器上使用的话，platform 选择 Linux 64-bit 就可以了，plugins 如果暂时不需要的话，可以不选。然后点击下面的 DOWNLOAD 按钮，就下载到 caddy 了。同理，解压之后用 cp 命令放到 <code>/usr/local/bin/caddy</code> 就完成了安装。</p>
<p><img src="http://static.zybuluo.com/zwh8800/i1yzmlylv9gyc0ouxhchgf18/image_1bn3mbk8jov2es3vu41l842ac9.png" alt="image_1bn3mbk8jov2es3vu41l842ac9.png-177.7kB"></p>
<h3 id="1-3-源码安装"><a href="#1-3-源码安装" class="headerlink" title="1.3 源码安装"></a>1.3 源码安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/mholt/caddy/caddy</span><br></pre></td></tr></table></figure>

<p>对于安装了 golang 编译器的同学，只需要执行 go get 就能到 $GOPATH/bin 里，是否 cp 到 <code>/usr/local/bin</code> 里就看心情了。使用源码安装可以安装到最新版本的 caddy，功能上一般是最新的，而且因为是本地编译，性能可能会稍微高一些，但是可能会存在不稳定的现象。</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-临时文件服务器"><a href="#2-1-临时文件服务器" class="headerlink" title="2.1 临时文件服务器"></a>2.1 临时文件服务器</h3><p>Caddy 的配置文件叫做 <code>Caddyfile</code>，Caddy 不强制你把配置文件放到哪个特定文件夹，默认情况下，把 Caddyfile 放到当前目录就可以跑起来了，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'localhost:8888'</span> &gt;&gt; Caddyfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'gzip'</span> &gt;&gt; Caddyfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'browse'</span> &gt;&gt; Caddyfile</span><br><span class="line">caddy</span><br></pre></td></tr></table></figure>

<p>在随便一个目录里执行上面代码，然后在浏览器里打开 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> 发现 caddy 已经启动了一个文件服务器。当临时需要一个 fileserver 的时候（比如共享文件），使用 caddy 会很方便。</p>
<h3 id="2-2-生产环境使用"><a href="#2-2-生产环境使用" class="headerlink" title="2.2 生产环境使用"></a>2.2 生产环境使用</h3><p>当然了，在生产环境使用的时候就不能这么草率的把配置文件放到当前目录了，一般情况下会放到 <code>/etc/caddy</code> 里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/caddy</span><br><span class="line">sudo touch /etc/caddy/Caddyfile</span><br><span class="line">sudo chown -R root:www-data /etc/caddy</span><br></pre></td></tr></table></figure>

<p>除了配置文件，caddy 会自动生成 ssl 证书，需要一个文件夹放置 ssl 证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/ssl/caddy</span><br><span class="line">sudo chown -R www-data:root /etc/ssl/caddy</span><br><span class="line">sudo chmod 0770 /etc/ssl/caddy</span><br></pre></td></tr></table></figure>

<p>因为 ssl 文件夹里会放置私钥，所以权限设置成 770 禁止其他用户访问。</p>
<p>最后，创建一下放置网站文件的目录，如果已经有了，就不需要创建了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/www</span><br><span class="line">sudo chown www-data:www-data /var/www</span><br></pre></td></tr></table></figure>

<p>创建好这些文件和目录了之后，我们需要把 caddy 配置成一个服务，这样就可以开机自动运行，并且管理起来也方便。因为目前大多数发行版都使用 systemd 了，所以这里只讲一下如何配置 systemd，不过 caddy 也支持配置成原始的 sysvinit 服务，具体方法<a href="https://github.com/mholt/caddy/tree/master/dist/init/linux-sysvinit" target="_blank" rel="noopener" title="SysVinit conf for Caddy">看这里</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service   <span class="comment"># 从 github 下载 systemd 配置文件</span></span><br><span class="line">sudo systemctl daemon-reload        <span class="comment"># 重新加载 systemd 配置</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> caddy.service <span class="comment"># 设置 caddy 服务自启动</span></span><br><span class="line">sudo systemctl status caddy.service <span class="comment"># 查看 caddy 状态</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Caddyfile"><a href="#3-Caddyfile" class="headerlink" title="3. Caddyfile"></a>3. Caddyfile</h2><p>基本的安装配置搞定之后，最重要的就是如何写 Caddyfile了。可以直接 <code>vim /etc/caddy/Caddyfile</code> 来修改 Caddyfile，也可以再自己电脑上改好然后 rsync 到服务器上。如果修改了 Caddyfile 发现没有生效，是需要执行一下 <code>sudo systemctl restart caddy.service</code> 来重启 caddy 的。</p>
<h3 id="3-1-Caddyfile-的格式"><a href="#3-1-Caddyfile-的格式" class="headerlink" title="3.1 Caddyfile 的格式"></a>3.1 Caddyfile 的格式</h3><p>Caddfile的格式还是比较简单的，首先第一行必须是网站的地址，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:8080</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lengzzz.com</span><br></pre></td></tr></table></figure>

<p>地址可以带一个端口号，那么 caddy 只会在这个端口上开启 http 服务，而不会开启 https，如果不写端口号的话，caddy 会默认绑定 80 和 443 端口，同时启动 http 和 https 服务。</p>
<p>地址后面可以再跟一大堆指令（directive）。Caddyfile 的基本格式就是这样，由一个网站地址和指令组成，是不是很简单。</p>
<h3 id="3-2-指令"><a href="#3-2-指令" class="headerlink" title="3.2 指令"></a>3.2 指令</h3><p>指令的作用是为网站开启某些功能。指令的格式有三种，先说一下最简单的不带参数的指令比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe     # 没错，moe后缀的域名也可以哦</span><br><span class="line">gzip</span><br></pre></td></tr></table></figure>

<p>第二行的 gzip 就是一个指令，它表示打开 gzip 压缩功能，这样网站在传输网页是可以降低流量。</p>
<p>第二种指令的格式是带简单参数的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe</span><br><span class="line">gzip</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;access.log</span><br><span class="line">tls lengz@lengzzz.com</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure>

<p>第三行，log 指令会为网站开启 log 功能，log 指令后的参数告诉 caddy log 文件存放的位置。第四行的 tls 指令告诉 caddy 为网站开启 https 并自动申请证书，后面的 email 参数是告知 CA 申请人的邮箱。（caddy 会默认使用 let’s encrypt 申请证书并续约，很方便吧）</p>
<p>另外，简单参数也可能不只一个，比如 redir 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe</span><br><span class="line">gzip</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;access.log</span><br><span class="line">tls &#x2F;etc&#x2F;ssl&#x2F;cert.pem &#x2F;etc&#x2F;ssl&#x2F;key.pem</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">redir &#x2F; https:&#x2F;&#x2F;lengzzz.com&#x2F;archive&#x2F;&#123;uri&#125; 301</span><br></pre></td></tr></table></figure>

<p>上面的 redir 指令带了三个参数，意思是把所有的请求使用 301 重定向到 <a href="https://lengzzz.com/archive/xxx，这个指令在给网站换域名的时候很有用。另外">https://lengzzz.com/archive/xxx，这个指令在给网站换域名的时候很有用。另外</a> tls 指令变了，不单单传 email一个参数， 而是分别传了证书和私钥的路径，这样的话 caddy 就不会去自动申请证书，而是使用路径给出的证书了。</p>
<p>在这个例子里还使用了 <code>{uri}</code> 这样的占位符（placeholder），详细的列表可以在这里查询到：<a href="https://caddyserver.com/docs/placeholders。" target="_blank" rel="noopener">https://caddyserver.com/docs/placeholders。</a></p>
<p>最后一种指令是带复杂参数的，这种指令包含可能很多参数，所以需要用一对花括号包起来，比如 header 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe</span><br><span class="line">gzip</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;access.log</span><br><span class="line">tls lengz@lengzzz.com</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">header &#x2F;api &#123;</span><br><span class="line">    Access-Control-Allow-Origin  *</span><br><span class="line">    Access-Control-Allow-Methods &quot;GET, POST, OPTIONS&quot;</span><br><span class="line">    -Server</span><br><span class="line">&#125;</span><br><span class="line">fastcgi &#x2F; 127.0.0.1:9000 php &#123;</span><br><span class="line">    index index.php</span><br><span class="line">&#125;</span><br><span class="line">rewrite &#123;</span><br><span class="line">    to &#123;path&#125; &#123;path&#125;&#x2F; &#x2F;index.php?&#123;query&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6-10 行的 header 指令代表为所有的 <code>/api/xxx</code> 的请求加上 <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Methods</code> 这两个 header，从而能支持 javascript <a href="https://lengzzz.com/note/cross-origin-http-request" title="跨源 HTTP 请求（CORS）">跨域访问</a> ，第 9 行代表删除 Server header，防止别人看到服务器类型。</p>
<p>11-13 行使用了 fastcgi 指令，代表把请求通过 fastcgi 传给 php，ruby 等后端程序。</p>
<p>14-15 行，使用了 rewrite 指令，这个指令的作用是 <strong>服务器内部重定向</strong> 在下面的参数 <code>to</code> 后面，又跟了三个参数，这个功能上有点类似 nginx 的 <code>try_files</code> 。告诉 caddy 需要先查看网址根目录 /var/www 里有没有 {path} 对应的文件，如果没有再查看有没有 {path} 对应的目录，如果都没有，则转发给 index.php 入口文件。这个功能一般会用在 PHP 的 MVC 框架上使用。</p>
<p>随着一步步完善这个 Caddyfile，目前这个版本的 Caddyfaile 已经可以直接在网站中使用了。</p>
<h3 id="3-3-多-HOST-网站"><a href="#3-3-多-HOST-网站" class="headerlink" title="3.3 多 HOST 网站"></a>3.3 多 HOST 网站</h3><p>刚才说的一直都是单个域名的网址，那么如果在同一个服务器上部署多个域名的网站呢？很简单，只需要在域名后面跟一个花括号扩起来就可以了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe &#123;</span><br><span class="line">    gzip</span><br><span class="line">    log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;railgun_moe.log</span><br><span class="line">    tls lengz@lengzzz.com</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">    header &#x2F;api &#123;</span><br><span class="line">        Access-Control-Allow-Origin  *</span><br><span class="line">        Access-Control-Allow-Methods &quot;GET, POST, OPTIONS&quot;</span><br><span class="line">        -Server</span><br><span class="line">    &#125;</span><br><span class="line">    fastcgi &#x2F; 127.0.0.1:9000 php &#123;</span><br><span class="line">        index index.php</span><br><span class="line">    &#125;</span><br><span class="line">    rewrite &#123;</span><br><span class="line">        to &#123;path&#125; &#123;path&#125;&#x2F; &#x2F;index.php?&#123;query&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">lengzzz.com &#123;</span><br><span class="line">	tls lengz@lengzzz.com</span><br><span class="line">	log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;lengzzz_com.log</span><br><span class="line">    redir &#x2F; https:&#x2F;&#x2F;railgun.moe&#x2F;&#123;uri&#125; 301</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，基本的 caddy 配置就这些，详细的内容可以去官网上看文档学习。</p>
<p><a href="https://caddyserver.com/docs" target="_blank" rel="noopener">https://caddyserver.com/docs</a></p>
<p>[EOF]</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/运维/">运维</a><a href="/tags/caddy/">caddy</a><a href="/tags/http/">http</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/08/09/Caddy-方便够用的HTTPSserver新手教程/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/05/30/移植LuaCoco/"><span>移植 LuaCoco</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/30/移植LuaCoco/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-30T04:13:43.000Z">
          2017-05-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>lua 语言最大的卖点之一就是他的协程（coroutine）了。但是在 lua5.1 中有一个文档都没提到的一个坑：协程<strong>只能</strong>在 lua 中使用，当调用 yield 时，如果当前的调用栈上有 c 代码，则会报错 <strong>“attempt to yield across metamethod/C-call boundary”</strong>。目前有个第三方的 patch 叫做 <a href="http://coco.luajit.org/" target="_blank" rel="noopener" title="Coco — True C Coroutines for Lua">luaCoco</a> 可以让 lua 支持 “真协程”。本文研究了 luaCoco 的内部实现，并把它移植到了 <a href="https://en.wikipedia.org/wiki/Tensilica" target="_blank" rel="noopener">xtensa</a> 处理器上。</p>
<p><a href="/notename/" title="porting luaCoco"></a></p>
<p><img src="http://static.zybuluo.com/zwh8800/ubwij67dsbcovkbihpd9cmfr/image_1bhbpomnrk0m58270a54k789.png" alt="image_1bhbpomnrk0m58270a54k789.png-16.9kB"></p>
<p>[toc]</p>
<h2 id="setjmp-的实现"><a href="#setjmp-的实现" class="headerlink" title="setjmp 的实现"></a>setjmp 的实现</h2><p>在文章的开头需要先讲解一下c语言标准库中 <a href="http://www.cplusplus.com/reference/csetjmp/" target="_blank" rel="noopener">setjmp</a> 的内部实现，因为之后的 luaCoco 的实现就是对 setjmp 的数据结构的一个 hack。</p>
<p>先看看 setjmp 的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jmp_buf buf;</span><br><span class="line">    <span class="keyword">int</span> code = setjmp(buf);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before jmp\n"</span>);</span><br><span class="line">        longjmp(buf, <span class="number">1024</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"jmp here, code: %d\n"</span>, code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 setjmp 的时候，会返回 0，从而会执行 <code>if (code == 0) {</code> 为 true 的 block，会打印出 <code>before jmp</code>。当执行了 longjmp 之后，程序的执行会重新跳转到 setjmp 那一行（第七行）然而这次 setjmp 的返回值 code 不再是 0，而是 longjmp 的第二个参数（1024），这样就会打印出 <code>jmp here, code: 1024</code>。</p>
<p>利用 setjmp 的这个功能能实现出很多有趣的东西，比如在c语言中做 <code>Exception</code>，但是 setjmp 是怎么实现的呢？我们去读一读源码。</p>
<p>libc 的实现有好多种，常见的比如 glibc、uclibc 和 musl-libc，但是我们这次读一读 newlib 的源码。newlib 也是一个 libc 的实现，常用于嵌入式开发中。</p>
<p>打开 inlcude/machine/setjmp-dj.h 文件，可以看到 jmp_buf 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from inlcude/machine/setjmp-dj.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">&#125; jmp_buf[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>发现这个结构体是用来存储 cpu 的寄存器的。这里很好理解，因为要实现 长跳转（longjmp），必须要首先把跳转的目的地的<strong>现场</strong>先保存下来。</p>
<p>setjmp 函数做的工作就是保存现场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; from machine&#x2F;i386&#x2F;setjmp.S</span><br><span class="line"> &#x2F;*</span><br><span class="line"> **	jmp_buf:</span><br><span class="line"> **	 eax ebx ecx edx esi edi ebp esp eip</span><br><span class="line"> **	 0   4   8   12  16  20  24  28  32</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">       #include &quot;i386mach.h&quot;</span><br><span class="line"></span><br><span class="line">        .global SYM (setjmp)</span><br><span class="line">        .global SYM (longjmp)</span><br><span class="line">       SOTYPE_FUNCTION(setjmp)</span><br><span class="line">       SOTYPE_FUNCTION(longjmp)</span><br><span class="line"> </span><br><span class="line">SYM (setjmp):</span><br><span class="line"></span><br><span class="line">	pushl	ebp</span><br><span class="line">	movl	esp,ebp</span><br><span class="line"></span><br><span class="line">	pushl	edi</span><br><span class="line">	movl	8 (ebp),edi</span><br><span class="line"></span><br><span class="line">	movl	eax,0 (edi)</span><br><span class="line">	movl	ebx,4 (edi)</span><br><span class="line">	movl	ecx,8 (edi)</span><br><span class="line">	movl	edx,12 (edi)</span><br><span class="line">	movl	esi,16 (edi)</span><br><span class="line"></span><br><span class="line">	movl	-4 (ebp),eax</span><br><span class="line">	movl	eax,20 (edi)    &#x2F;&#x2F; edi</span><br><span class="line"></span><br><span class="line">	movl	0 (ebp),eax</span><br><span class="line">	movl	eax,24 (edi)    &#x2F;&#x2F; ebp</span><br><span class="line"></span><br><span class="line">	movl	esp,eax</span><br><span class="line">	addl	$12,eax</span><br><span class="line">	movl	eax,28 (edi)    &#x2F;&#x2F; esp</span><br><span class="line">	</span><br><span class="line">	movl	4 (ebp),eax</span><br><span class="line">	movl	eax,32 (edi)    &#x2F;&#x2F; eip (PC)</span><br><span class="line"></span><br><span class="line">	popl	edi</span><br><span class="line">	movl	$0,eax</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<center>
![FullSizeRender 2.jpg-1881.4kB][2]
<small>setjmp 的栈帧</small>
</center>

<p>看图解释一下代码： </p>
<ul>
<li>17 行：push ebp 到栈上（esp 同时下移 4 字节）</li>
<li>18 行：ebp 指向 esp</li>
<li>20 行：push edi 到栈上（esp 同时再下移 4 字节）</li>
<li>21 行：8(ebp) 保存的是 jmp_buf 的指针，先把它放到 edi 中</li>
<li>23 - 27 行：分别把 eax、ebx、ecx、edx、esi 保存到 jmp_buf 里</li>
<li>29 - 30 行：-4 (ebp) 是edi，如图</li>
<li>32 - 33 行：(ebp) 就是之前的ebp，如图</li>
<li>35 - 37 行：保存 esp</li>
<li>39 - 40 行：如图，保存 <code>return addr</code> 到 jmp_buf-&gt;eip</li>
</ul>
<p>longjmp 的实现是正好相反的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SYM (longjmp):</span><br><span class="line">	pushl	ebp</span><br><span class="line">	movl	esp,ebp</span><br><span class="line"></span><br><span class="line">	movl	8(ebp),edi	&#x2F;* get jmp_buf *&#x2F;</span><br><span class="line">	movl	12(ebp),eax	&#x2F;* store retval in j-&gt;eax *&#x2F;</span><br><span class="line">	testl	eax,eax</span><br><span class="line">	jne	0f</span><br><span class="line">	incl	eax</span><br><span class="line">0:</span><br><span class="line">	movl	eax,0(edi)</span><br><span class="line"></span><br><span class="line">	movl	24(edi),ebp</span><br><span class="line"></span><br><span class="line">       __CLI</span><br><span class="line">	movl	28(edi),esp</span><br><span class="line">	</span><br><span class="line">	pushl	32(edi)	</span><br><span class="line"></span><br><span class="line">	movl	0(edi),eax</span><br><span class="line">	movl	4(edi),ebx</span><br><span class="line">	movl	8(edi),ecx</span><br><span class="line">	movl	12(edi),edx</span><br><span class="line">	movl	16(edi),esi</span><br><span class="line">	movl	20(edi),edi</span><br><span class="line">       __STI</span><br><span class="line"></span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>代码就不赘述了，基本上就是恢复<strong>现场</strong>、把longjmp的第二个参数作为返回值返回（7 - 9 行还有一个判断：如果参数为0的话，会把它改成 1）。</p>
<h2 id="LuaCoco-的实现"><a href="#LuaCoco-的实现" class="headerlink" title="LuaCoco 的实现"></a>LuaCoco 的实现</h2><p>首先在看代码之前，先简单讲解一下我对 LuaCoco 的理解。lua 的协程其实也就是为每个协程维护了一个 context（所谓 context，既程序执行到某个地方时的状态，包括寄存器、callstack）。当协程之前相互 yield 的时候，切换一下 context。但是 lua 没做好的地方是 lua 仅保存了 lua 程序的 context，而 c 代码的 context 是没有保存的。这是因为 lua 很追求使用 pure c，不希望在源码中加入过多平台相关的东西。保存 lua 的 context 是比较简单的，因为所有 lua 程序相关的数据结构都放在 lua 虚拟机里，只需要每个 coroutine 保存一份就好了，而取得／保存 c 代码的上下文是需要操作平台相关的寄存器的。LuaCoco 就是为每个常见的平台都做了一份保存 c 程序 context 的实现。</p>
<p>下面看 LuaCoco 的源码。</p>
<p>LuaCoco 是对 lua 源码的一个 patch，coco 改动了 lua 的以下文件：</p>
<p><img src="http://static.zybuluo.com/zwh8800/dr4o3fz11cdqpms9kb08fplp/image_1bhcc3die5r3c7tg95ab069b1e.png" alt="image_1bhcc3die5r3c7tg95ab069b1e.png-22.7kB"></p>
<p>最主要的文件就是 lcoco.c 和 lcoco.h 了：</p>
<p>我看源码一般喜欢先看一下 header 文件，瞄一眼 coco 大体上做了什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from lcoco.h</span></span><br><span class="line"><span class="comment">/* Exported C API to add a C stack to a coroutine. */</span></span><br><span class="line"><span class="function">LUA_API lua_State *<span class="title">lua_newcthread</span><span class="params">(lua_State *L, <span class="keyword">int</span> cstacksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal support routines. */</span></span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">void</span> <span class="title">luaCOCO_free</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_resume</span><span class="params">(lua_State *L, <span class="keyword">int</span> nargs)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_yield</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_cstacksize</span><span class="params">(<span class="keyword">int</span> cstacksize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>lcoco.h 里声明了 coco 定义的 4 个函数。很明显，lua_newcthread 是为了取代原生 lua 中的 lua_newthread 函数的。这一点可以在 lbaselib.c 文件的改动中看到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from lbaselib.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">luaB_cocreate</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COCO_DISABLE</span></span><br><span class="line">  lua_State *NL = lua_newthread(L);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp; !lua_iscfunction(L, <span class="number">1</span>), </span><br><span class="line">    <span class="number">1</span>, <span class="string">"Lua function expected"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> cstacksize = luaL_optint(L, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  lua_State *NL = lua_newcthread(L, cstacksize);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                   (cstacksize &gt;= <span class="number">0</span> ? <span class="number">1</span> : !lua_iscfunction(L, <span class="number">1</span>)),</span><br><span class="line">                <span class="number">1</span>, <span class="string">"Lua function expected"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  lua_pushvalue(L, <span class="number">1</span>);  <span class="comment">/* move function to top */</span></span><br><span class="line">  lua_xmove(L, NL, <span class="number">1</span>);  <span class="comment">/* move function from L to NL */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用宏判断了是否开启 coco，如果开启的话就使用新的 lua_newcthread，否则的话还使用原生的 lua_newthread。</p>
<p>那么，下一步就着重来看看 lua_newcthread 的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a C stack to a coroutine. */</span></span><br><span class="line"><span class="function">lua_State *<span class="title">lua_newcthread</span><span class="params">(lua_State *OL, <span class="keyword">int</span> cstacksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lua_State *NL = lua_newthread(OL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cstacksize &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> NL;</span><br><span class="line">  <span class="keyword">if</span> (cstacksize == <span class="number">0</span>)</span><br><span class="line">    cstacksize = defaultcstacksize;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cstacksize &lt; COCO_MIN_CSTACKSIZE)</span><br><span class="line">    cstacksize = COCO_MIN_CSTACKSIZE;</span><br><span class="line">  cstacksize &amp;= <span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line">  COCO_NEW(OL, NL, cstacksize, ((coco_MainFunc)(coco_main)))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看函数签名，发现比原生的 newthread 多了一个 cstacksize 参数，因为现在需要为 c 程序保存上下文，c 程序的执行需要一个 stack，所以每个 coroutine 都要有一个自己的 stack。这个 cstacksize 参数就是用来控制这个 stack 的大小的。</p>
<p>继续看代码，几个 if 的意思也很清晰，不表。发现重要的功能都封装到了 <code>COCO_NEW</code> 这个宏里面了。再一翻代码，这个宏又套了好几层宏和宏判断，搞得我很郁闷。所以我就使出了我的编译器大法！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -DCOCO_USE_SETJMP -D__linux__ -D_I386_JMP_BUF_H -D__i386 lcoco.c &gt; _lcoco.c</span><br></pre></td></tr></table></figure>

<p>这个命令可以让编译器只执行预处理，说白了就是把 c 语言的宏全部展开。命令中定义的其他几个宏的意思分别是：使用 setjmp 实现协程、使用Linux架构、使用i386架构。</p>
<p>宏展开的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lua_State* <span class="title">lua_newcthread</span><span class="params">(lua_State* OL, <span class="keyword">int</span> cstacksize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ... if check</span></span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = luaM_realloc_(OL, <span class="literal">NULL</span>, <span class="number">0</span>, (cstacksize));</span><br><span class="line">    coco_State* coco = ((coco_State* )(((<span class="keyword">char</span>* ) <span class="number">0</span>) + ((((<span class="keyword">char</span>* )(ptr) - (<span class="keyword">char</span>* ) <span class="number">0</span>) + (cstacksize) - <span class="keyword">sizeof</span>(coco_State)) &amp; <span class="number">-16</span>)));</span><br><span class="line">    coco-&gt;allocptr = ptr;</span><br><span class="line">    coco-&gt;allocsize = cstacksize; &#123;</span><br><span class="line">      <span class="keyword">size_t</span>* stackptr = &amp; ((<span class="keyword">size_t</span>*) coco)[<span class="number">-1</span>];</span><br><span class="line">      _setjmp(coco-&gt;ctx);</span><br><span class="line">      coco-&gt;ctx-&gt;__pc = (((coco_MainFunc)(coco_main)));</span><br><span class="line">      coco-&gt;ctx-&gt;__sp = (stackptr);</span><br><span class="line">      coco-&gt;ctx-&gt;__bp = <span class="literal">NULL</span>;</span><br><span class="line">      stackptr[<span class="number">1</span> - <span class="number">1</span>] = <span class="number">0xdeadc0c0</span>;</span><br><span class="line">      coco-&gt;arg0 = (<span class="keyword">size_t</span>)(NL);</span><br><span class="line">    &#125;(((coco_State**)(NL))[<span class="number">-1</span>]) = coco;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，主要做的事情就是 alloc 了 coco_State 数据结构和 cstack。这里只申请了一次内存空间，然后通过指针操作分别把内存分成了 coco_State 和 cstack 两块。有点迷糊的可以看一下我画的图：</p>
<p><img src="http://static.zybuluo.com/zwh8800/7o9m3fu856wkwv1te2z2ap76/WechatIMG23.jpeg" alt="WechatIMG23.jpeg-99.9kB"></p>
<p>申请好空间之后，11到16行初始化了 coco_State 的几个字段。</p>
<p>17行把 coco 的指针放到了 NL 的前面（我并不知道为什么可以这么做，反正就是可以，看的时候我一脸“还有这种操作？”的黑人问号）</p>
<center>
![IMG_0002.JPG-49.3kB][5]
</center>

<p>下面我们去看看 coco_State 的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coco_State</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> arg0;</span><br><span class="line">  jmp_buf ctx;</span><br><span class="line">  jmp_buf back;</span><br><span class="line">  <span class="keyword">void</span>* allocptr;</span><br><span class="line">  <span class="keyword">int</span> allocsize;</span><br><span class="line">  <span class="keyword">int</span> nargs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经过宏替换之后，coco_State 长上面这样。</p>
<p>lua_newcthread里的代码初始化了 ctx，allocptr，allocsize，arg0 字段。其中，对 ctx 的初始化操作比较让人在意，首先是调用 setjmp 初始化了 ctx，之后对 ctx 内部的几个字段进行了魔改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coco-&gt;ctx-&gt;__pc = (((coco_MainFunc)(coco_main)));</span><br><span class="line">coco-&gt;ctx-&gt;__sp = (stackptr);</span><br><span class="line">coco-&gt;ctx-&gt;__bp = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>有了之前 setjmp 的基础，这里就容易理解了，一旦对这个 ctx 调用 longjmp 的话，<strong>程序就会跳转到 <code>coco_main</code> 这个函数，并且把 stackptr 当作程序的 stack 来使用。这个 stack 的切换操作，其实就是程序 context 的切换</strong></p>
<p>我们先不看 <code>coco_main</code> 做了什么，先看看这个 longjmp 会在什么时候调用，动脑子想一想，应该会是再执行 resume 的时候调用 longjmp，果然不出所料：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaCOCO_resume</span><span class="params">(lua_State* L, <span class="keyword">int</span> nargs)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  coco-&gt;nargs = nargs;</span><br><span class="line">  <span class="keyword">if</span> (!_setjmp(coco-&gt;back)) _longjmp(coco-&gt;ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L-&gt;status != <span class="number">1</span>) &#123;</span><br><span class="line">    luaM_realloc_(L, ((((coco_State**)(L))[<span class="number">-1</span>])-&gt;allocptr), ((((coco_State**)(L))[<span class="number">-1</span>])-&gt;allocsize), <span class="number">0</span>);</span><br><span class="line">    (((coco_State**)(L))[<span class="number">-1</span>]) = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> L-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 resume 的时候，首先使用 setjmp 把主线程的状态保存到 <code>coco-&gt;back</code> 里，然后调转到 <code>coco_main</code>。</p>
<p>下面看 <code>coco_main</code> 做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coco_main</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    L-&gt;status = luaD_rawrunprotected(L, coco_start, L-&gt;top - (coco-&gt;nargs + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;status != <span class="number">0</span>) luaD_seterrorobj(L, L-&gt;status, L-&gt;top);</span><br><span class="line">    <span class="keyword">if</span> (!_setjmp(coco-&gt;ctx)) _longjmp(coco-&gt;back, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 首先通过L取到了coco的指针（又一次黑人问号）。然后通过 luaD_rawrunprotected 调用了 lua 程序（也就是lua子线程）。之后判断子线程时候出错，设置错误码。最后，保存子线程的状态到 ctx，然后跳转会 back（调转到了luaCOCO_resume 第6行）。</p>
<p>继续回来看 luaCOCO_resume 函数，第 6 行后面宏展开前其实是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L-&gt;status != LUA_YIELD) &#123;</span><br><span class="line">  COCO_FREE(L)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开前的代码比较容易懂：如果子线程执行完了，就 free 掉，没啥可说的。</p>
<p>最后看看 yield：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaCOCO_yield</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  L-&gt;status = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!_setjmp(coco-&gt;ctx)) _longjmp(coco-&gt;back, <span class="number">1</span>);</span><br><span class="line">  L-&gt;status = <span class="number">0</span>; &#123;</span><br><span class="line">    StkId base = L-&gt;top - coco-&gt;nargs;</span><br><span class="line">    StkId rbase = L-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (rbase &lt; base) &#123;</span><br><span class="line">      <span class="keyword">while</span> (base &lt; L-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">const</span> TValue* o2 = (base++);</span><br><span class="line">        TValue* o1 = (rbase++);</span><br><span class="line">        o1-&gt;value = o2-&gt;value;</span><br><span class="line">        o1-&gt;tt = o2-&gt;tt;</span><br><span class="line">        ((<span class="keyword">void</span>) <span class="number">0</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      L-&gt;top = rbase;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;base = L-&gt;ci-&gt;base;</span><br><span class="line">  <span class="keyword">return</span> coco-&gt;nargs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转那里和之前讲的一样，多了的东西没太明白，好像是在复制 lua_State 内部的数据。</p>
<p>LuaCoco 内部实现的内容基本上就这些了。</p>
<p>题外话：其实除了魔改 setjmp，LuaCoco还有三种实现，直接内连汇编、使用ucontext和使用fiber，大家可以通过执行 <code>gcc -E lcoco.c &gt; _lcoco.c</code> 加不同的宏定义来生成代码自行研究（其实原理都差不多）。</p>
<h2 id="xtensa-架构-ABI"><a href="#xtensa-架构-ABI" class="headerlink" title="xtensa 架构 ABI"></a>xtensa 架构 ABI</h2><p>这部分就简单讲一下带过了，毕竟不是那么通用的内容。</p>
<p>经常做移植的同学应该大多知道，移植的时候最重要的是需要了解这个 architecture 的 ABI（application binary interface）。Google 一番之后发现了<a href="http://0x04.net/~mwk/doc/xtensa.pdf" target="_blank" rel="noopener" title="Xtensa® Instruction Set Architecture (ISA)">这个pdf</a>，不过先不急着看 ABI，先看一下这个 CPU 的寄存器吧。</p>
<p>xtensa 有 16 个 32 位的通用寄存器，名字分别叫 A0 ～ A15，一个 PC 程序计数器，再加上一个 SAR 寄存器（不知道干嘛用的，不过好像移植的话用不上），还算挺简单的设计，没有奇奇怪怪的东西。</p>
<p>接下来，再看看 xtensa 的 ABI，在 PDF 的 chapter 8 里找到了 关于 Xtensa ABI 的部分。xtensa 使用了两种ABI，一种叫 <code>Windowed Register</code> 另一种叫 <code>CALL0</code> 。NodeMCU 只会用到 CALL0 所以我们简单讲一下 CALL0。</p>
<p>先看表格：</p>
<p>| Register        | Use   |<br>|    |   |<br>| a0 | Return Address |<br>| a1 (sp) | Stack Pointer (callee-saved) |<br>| a2 – a7 | Function Arguments |<br>| a8 | Static Chain (see Section 8.1.8) |<br>| a12 – a15 | Callee-saved |<br>| a15 | Stack-Frame Pointer (optional) |</p>
<p>A0 保存了函数的返回地址，A1保存了栈指针，a2到a7一共6个寄存器用于传递函数的参数，更多的参数会在栈中传递，a12-a15需要被调用者自己保存。</p>
<p>看完了寄存器的使用，看一下 xtensa 的栈帧（stack frame）格式：</p>
<p><img src="http://static.zybuluo.com/zwh8800/ultko7iylckid969jnozvr7o/image_1bktgc5jiv8p1bqh1ot5pcf1v0i9.png" alt="image_1bktgc5jiv8p1bqh1ot5pcf1v0i9.png-37.6kB"></p>
<p>可以看出来，xtensa 的指针也是向低地址方向增长的。在 SP 的上面会保存依次 <code>6个参数以外的参数</code> 、<code>局部变量</code> 等</p>
<h2 id="移植-LuaCoco"><a href="#移植-LuaCoco" class="headerlink" title="移植 LuaCoco"></a>移植 LuaCoco</h2><p>搞清楚 ABI 了，最后的工作就是 coding 了。</p>
<p>遇到的第一个问题是，因为我们要对 setjmp 进行 hack，而不是使用汇编，所以我们仅能操作内存，而不能操作寄存器，所以如何将 lua_State 传递给 coco_main 呢？最常见的方法就是使用 哑参数（dummy args）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COCO_MAIN_PARAM		int _a, int _b, int _c, int _d, int _e, int _f, lua_State *L</span></span><br></pre></td></tr></table></figure>

<p>我们把 coco_main 的参数列表定义成这样，前面a到f的参数都是用不上的，这样就不用管 a2 到 a7 这几个寄存器了。所以我们只需要把L指针放到SP指的位置就好了。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">COCO_PATCHCTX(<span class="params">coco</span>, <span class="params">buf</span>, <span class="params">func</span>, <span class="params">stack</span>, <span class="params">a0</span>)</span> \</span><br><span class="line">  buf<span class="literal">[<span class="number">0</span>]</span> = (<span class="built_in">int</span>)(func); \</span><br><span class="line">  buf<span class="literal">[<span class="number">1</span>]</span> = (<span class="built_in">int</span>)(stack); \</span><br><span class="line">  stack<span class="literal">[<span class="number">0</span>]</span> = (size_t)(a0);</span><br></pre></td></tr></table></figure>

<p><code>stack[0] = (size_t)(a0);</code> 这一句中的 a0 就是 lua_State 的指针，把他放到了 SP[0] 这里。</p>
<p>第二个问题就是对 <code>jmp_buf</code> 进行 hack 了，我们需要搞明白 <code>jmp_buf</code> 里怎么放东西的，这需要看这个平台编译器的源码了。<a href="https://github.com/pfalcon/esp-open-sdk" target="_blank" rel="noopener">https://github.com/pfalcon/esp-open-sdk</a> 这里是编译器的源代码，他是使用 crosstool 的，会一边下载源代码，一遍编译，下载好的源代码放在 crosstool-NG/.build/src/newlib-2.0.0 ，正好我们看看 newlib 中 setjmp 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#else &#x2F;* CALL0 ABI *&#x2F;</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.align	4</span><br><span class="line">	.literal_position</span><br><span class="line">	.global	setjmp</span><br><span class="line">	.type	setjmp, @function</span><br><span class="line">setjmp:	</span><br><span class="line">	s32i	a0, a2, 0</span><br><span class="line">	s32i	a1, a2, 4</span><br><span class="line">	s32i	a12, a2, 8</span><br><span class="line">	s32i	a13, a2, 12</span><br><span class="line">	s32i	a14, a2, 16</span><br><span class="line">	s32i	a15, a2, 20</span><br><span class="line">	movi	a2, 0</span><br><span class="line">	ret</span><br><span class="line">	.size	setjmp, . - setjmp</span><br><span class="line"></span><br><span class="line">	.align	4</span><br><span class="line">	.literal_position</span><br><span class="line">	.global	longjmp</span><br><span class="line">	.type	longjmp, @function</span><br><span class="line">longjmp:</span><br><span class="line">	l32i	a0, a2, 0</span><br><span class="line">	l32i	a12, a2, 8</span><br><span class="line">	l32i	a13, a2, 12</span><br><span class="line">	l32i	a14, a2, 16</span><br><span class="line">	l32i	a15, a2, 20</span><br><span class="line">	l32i	a1, a2, 4</span><br><span class="line">	&#x2F;* Return val ? val : 1.  *&#x2F;</span><br><span class="line">	movi	a2, 1</span><br><span class="line">	movnez	a2, a3, a3</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line">	.size	longjmp, .-longjmp</span><br><span class="line"></span><br><span class="line">#endif &#x2F;* CALL0 ABI *&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面的 else 宏代表这段代码是使用 CALL0 ABI 才会被编译。看一下代码，可以了解到以下对应关系：</p>
<p>| jmp_buf | Register | Use |<br>|  |  |<br>| jup_buf[0] | a0 | Return Address |<br>| jmp_buf[1] | a1 | Stack Pointer (callee-saved) |<br>| jmp_buf[2] - jmp_buf[5] | a12 - a15 | Callee-saved |</p>
<p>所以这段代码也就不难理解了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">COCO_PATCHCTX(<span class="params">coco</span>, <span class="params">buf</span>, <span class="params">func</span>, <span class="params">stack</span>, <span class="params">a0</span>)</span> \</span><br><span class="line">  buf<span class="literal">[<span class="number">0</span>]</span> = (<span class="built_in">int</span>)(func); \</span><br><span class="line">  buf<span class="literal">[<span class="number">1</span>]</span> = (<span class="built_in">int</span>)(stack); \</span><br><span class="line">  stack<span class="literal">[<span class="number">0</span>]</span> = (size_t)(a0);</span><br></pre></td></tr></table></figure>

<p>分别是把 <code>buf[0]</code> 和 <code>buf[1]</code> 改成 coco_main 和 我们为协程新申请的栈。</p>
<p>其他代码基本上是 copy coco 的，详细的可以看我 github：</p>
<p><a href="https://github.com/zwh8800/nodemcu-firmware/commit/1f31aa32901f07b6414c0471eb19f7bdd44d93a6" target="_blank" rel="noopener">https://github.com/zwh8800/nodemcu-firmware/commit/1f31aa32901f07b6414c0471eb19f7bdd44d93a6</a> </p>
<p>[EOF] 基本上这次移植涉及到的内容就这些，完。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/lua/">lua</a><a href="/tags/coroutine/">coroutine</a><a href="/tags/协程/">协程</a><a href="/tags/移植/">移植</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/05/30/移植LuaCoco/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/12/搞了个golang的文档站/"><span>搞了个 golang 的文档站</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/12/搞了个golang的文档站/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-12T05:56:42.000Z">
          2017-01-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>地址在这里：<a href="https://go.lengzzz.com" target="_blank" rel="noopener">https://go.lengzzz.com</a></p>
<p><a href="/notename/" title="godoc"></a></p>
<p><img src="http://static.zybuluo.com/zwh8800/blgrh0ja2sgglap4zzvz8muf/image_1b68k36vh18er1h5ltlqn3o1b1pm.png" alt="image_1b68k36vh18er1h5ltlqn3o1b1pm.png-3.5kB"></p>
<p>点这个按钮哦</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/闲扯/">闲扯</a><a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/01/12/搞了个golang的文档站/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/04/小蚁摄像头实时同步视频到群晖nas（2）——使用rtsp协议同步/"><span>小蚁摄像头实时同步视频到群晖 nas（2）—— 使用 rtsp 协议同步</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/04/小蚁摄像头实时同步视频到群晖nas（2）——使用rtsp协议同步/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-04T07:27:55.000Z">
          2017-01-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://lengzzz.com/note/sync-video-from-yi-camera-to-synology-nas" title="小蚁摄像头实时同步视频到群晖 nas">上一篇 blog</a> 我利用 inotify-tools 和 rsync 两个工具实现了自动同步小蚁摄像机里拍摄的视频。不过今天翻网络又发现了另一种自动同步的解决方案，这个可以利用到群晖 nas 的 Surveillance Station 功能，使用效果更佳一些。这篇博客记录一下这次折腾过程。</p>
<p><a href="/notename/" title="sync video from yi camera to synology nas 2"></a></p>
<p>Surveillance Station 是群晖上的一个功能套件，可以管理网络摄像机，功能十分强大，而且原生支持很多品牌的网络摄像机，但是不支持小蚁摄像机。不过还好的是 Surveillance Station 支持 rtsp 协议，只要能在小蚁上开启 rtsp 服务就可以了。</p>
<center width="80%">
![QQ20170104-1@2x.png-4220.7kB][1]
<small>功能很强的Surveillance Station</small>
</center>

<p>这次没有自己编译 rtsp 服务，一是因为没有找到一个好用又轻量的，二是因为刚好找到一个俄罗斯的国际友人做的 <a href="https://github.com/fritz-smh/yi-hack" target="_blank" rel="noopener">“小蚁Hack”项目</a> 里面正好有我想要的 rtsp 服务，我就直接拿来用了。</p>
<p>我们只需要用到他项目里的一个文件，叫做 rtspsvrM 可以在 <a href="https://raw.githubusercontent.com/fritz-smh/yi-hack/master/sd/test/rtspsvrM" target="_blank" rel="noopener">https://raw.githubusercontent.com/fritz-smh/yi-hack/master/sd/test/rtspsvrM</a> 下载到。如果小蚁的系统版本比较老，可能需要 rtspsvrK 或者 rtspsvrI。我用的最新的 1.8.6.1 所以使用 M 版本的。具体的规则可以在 <a href="https://github.com/fritz-smh/yi-hack/blob/master/sd/test/equip_test.sh#L216" target="_blank" rel="noopener">https://github.com/fritz-smh/yi-hack/blob/master/sd/test/equip_test.sh#L216</a> 这个脚本里找到，我就不赘述了。</p>
<p>下载好 rtspsvrM 文件后，放到 sd 卡根目录，然后再创建一个服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/tmp/hd1/rtspsvrM &gt;&gt; /tmp/hd1/rtspsvrM.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>然后重启，执行下 <code>netstat -tuanp</code> ，可以看到 rtspsvrM 已经监听 554 端口了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tuanp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:38888           0.0.0.0:*               LISTEN      1266/goolink</span><br><span class="line">tcp        0      0 0.0.0.0:8554            0.0.0.0:*               LISTEN      1214/rtspsvrM</span><br><span class="line">tcp        0      0 0.0.0.0:554             0.0.0.0:*               LISTEN      1214/rtspsvrM</span><br><span class="line">tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      1197/tcpsvd</span><br><span class="line">tcp        0      0 0.0.0.0:18554           0.0.0.0:*               LISTEN      1214/rtspsvrM</span><br><span class="line">tcp        0      0 10.0.0.224:49016        120.25.66.121:28622     ESTABLISHED 1266/goolink</span><br><span class="line">tcp        0      1 10.0.0.224:53621        10.0.0.1:56688          LAST_ACK    -</span><br><span class="line">tcp        0  36200 10.0.0.224:35958        10.0.0.222:873          ESTABLISHED 1837/rsync</span><br><span class="line">tcp        0      0 10.0.0.224:554          10.0.0.222:53007        ESTABLISHED 1214/rtspsvrM</span><br><span class="line">tcp        0      0 10.0.0.224:42065        42.62.94.185:80         ESTABLISHED 1629/cloud</span><br><span class="line">tcp        0      0 :::80                   :::*                    LISTEN      1141/server</span><br><span class="line">tcp        0      0 :::23                   :::*                    LISTEN      1204/telnetd</span><br><span class="line">tcp        0   1087 ::ffff:10.0.0.224:23    ::ffff:10.0.0.220:46884 ESTABLISHED 1204/telnetd</span><br><span class="line">udp        0      0 0.0.0.0:6970            0.0.0.0:*                           1214/rtspsvrM</span><br><span class="line">udp        0      0 0.0.0.0:6972            0.0.0.0:*                           1214/rtspsvrM</span><br><span class="line">udp        0      0 0.0.0.0:23887           0.0.0.0:*                           2596/p2p_tnp</span><br><span class="line">udp        0      0 0.0.0.0:32108           0.0.0.0:*                           2596/p2p_tnp</span><br><span class="line">udp        0      0 0.0.0.0:56944           0.0.0.0:*                           1266/goolink</span><br><span class="line">udp        0      0 0.0.0.0:56501           0.0.0.0:*                           1266/goolink</span><br><span class="line">udp        0      0 0.0.0.0:1500            0.0.0.0:*                           1266/goolink</span><br></pre></td></tr></table></figure>

<p>说明服务已经起来了。另外这个 rtspsvrM 虽然没有开源，但是他好像没有建立什么乱七八糟的网络连接，姑且认为它不会泄漏用户信息。</p>
<p>现在回到 nas 的管理界面中，打开 Surveillance Station，点击网络摄像机点新增。</p>
<p><img src="http://static.zybuluo.com/zwh8800/fdsn1kae71w3krm42sn58ede/image_1b5k8dc0o19jf8bt1fe1abrtjr17.png" alt="image_1b5k8dc0o19jf8bt1fe1abrtjr17.png-48.3kB"></p>
<p>之后把 IP、端口号填写上，品牌选择最上面的用户自定义。最后一个视频原路径很关键，需要填写成 <code>rtsp://10.0.0.224:554/ch0_0.h264</code> 把其中的 IP 地址替换成你摄像机的 IP 就可以了。</p>
<p>之后，就可以好好享受 Surveillance Station 的强大功能了。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a><a href="/tags/折腾/">折腾</a><a href="/tags/嵌入式/">嵌入式</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/01/04/小蚁摄像头实时同步视频到群晖nas（2）——使用rtsp协议同步/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/02/小蚁摄像机实时同步视频到群晖nas/"><span>小蚁摄像机实时同步视频到群晖 nas</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/02/小蚁摄像机实时同步视频到群晖nas/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-02T14:28:14.000Z">
          2017-01-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>之前买了个小蚁智能摄像机，原生只支持向小米路由器里同步视频，我只有一个群晖 nas 做网络存储，所以元旦放假在家研究了下怎么样“破解”小蚁摄像头使它能同步视频到 nas 上。本质上，小蚁摄像头也是一个 Linux 服务器，只不过是运行在 arm 上的嵌入式 Linux，所以 Linux 的整个生态环境都可以利用的上。我这次的解决方案是使用 Linux 上著名的 <a href="https://rsync.samba.org/" target="_blank" rel="noopener">rsync</a> 做同步工具，但是必须编译出一个在 arm 上能用使用的 rsync。所以这篇文章的重点是 <strong>交叉编译</strong>。</p>
<p><a href="/notename/" title="sync video from Yi Camera to Synology nas"></a></p>
<h2 id="拿到小蚁摄像头的-shell"><a href="#拿到小蚁摄像头的-shell" class="headerlink" title="拿到小蚁摄像头的 shell"></a>拿到小蚁摄像头的 shell</h2><p>据说某些系统版本的小蚁摄像头默认没关闭 telnet 服务，那么在做以下事情之前可以先试试你的摄像头是不是已经开启了 telnet 。在终端里运行 <code>telnet xxx.xxx.xxx.xxx</code> xxx.xxx.xxx.xxx 是你摄像头的 ip 地址，可以在路由器管理界面中查到。如果出现 <code>(none) login:</code> 字样，说明你已经拿到了 shell，就不用做下面的操作了，直接跳到<a href="#jumpto-1">这里</a>。</p>
<ul>
<li>把小蚁摄像头里的内存卡取出来，在内存卡根目录建立一个文件夹 test</li>
<li>在 test 目录下创建文件 <code>equip_test.sh</code> 粘贴以下内容。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Telnet</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">"/etc/init.d/S88telnet"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"#!/bin/sh"</span> &gt; /etc/init.d/S88telnet</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"telnetd &amp;"</span> &gt;&gt; /etc/init.d/S88telnet</span><br><span class="line">    chmod 755 /etc/init.d/S88telnet</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">dr=`dirname <span class="variable">$0</span>`</span><br><span class="line"><span class="comment"># fix bootcycle</span></span><br><span class="line">mv <span class="variable">$dr</span>/equip_test.sh <span class="variable">$dr</span>/equip_test.sh.moved</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>根据网上的说法，<code>equip_test.sh</code> 会在开机的时候自动运行。</p>
<p>这个脚本的内容很简单，第一步创建 <code>/etc/init.d/S88telnet</code> 这个文件，内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">telnetd &amp;</span><br></pre></td></tr></table></figure>

<p>这个文件相当于创建了一个 busybox-init 的 <code>服务</code> [^ref3]，和 ubuntu、CentOS 的服务类似，不过功能更简单一些，直接就是一个 shell 脚本。这个 shell 脚本开启了 telnetd 后台程序。</p>
<p>第二步是把自身重命名并且重启，避免每次摄像头开机重复运行。</p>
<div id="jumpto-1"></div>

<p>现在，可以把内存卡查到摄像头中开机，不出意外的话现在再次在终端里输入 <code>telnet xxx.xxx.xxx.xxx</code> 就可以看到 <code>(none) login:</code> 了，现在输入用户名 <code>root</code> 按回车，再输入密码 <code>1234qwer</code> 就可以进入小蚁摄像头的 shell 界面了。</p>
<h2 id="交叉编译-rsync"><a href="#交叉编译-rsync" class="headerlink" title="交叉编译 rsync"></a>交叉编译 rsync</h2><p>拿到 shell 之后先进去看了看系统信息，没想到这个小蚁摄像头的配置这么寒酸。。。? cpu 是 N 年前的 arm9 ，内存只有 32MiB ，你没看错，就是 32MiB，一点都不夸张，root 文件系统只有 3.5MiB 的空间，毛都放不了，只能想办法把东西放内存卡上。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line"><span class="string">Linux</span> <span class="string">(none)</span> <span class="number">3.0</span><span class="number">.8</span> <span class="comment">#1 Wed Apr 30 16:56:49 CST 2014 armv5tejl GNU/Linux</span></span><br><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/proc/cpuinfo</span></span><br><span class="line"><span class="attr">Processor       :</span> <span class="string">ARM926EJ-S</span> <span class="string">rev</span> <span class="number">5</span> <span class="string">(v5l)</span></span><br><span class="line"><span class="attr">BogoMIPS        :</span> <span class="number">218.72</span></span><br><span class="line"><span class="attr">Features        :</span> <span class="string">swp</span> <span class="string">half</span> <span class="string">thumb</span> <span class="string">fastmult</span> <span class="string">edsp</span> <span class="string">java</span></span><br><span class="line"><span class="attr">CPU implementer :</span> <span class="number">0x41</span></span><br><span class="line"><span class="attr">CPU architecture:</span> <span class="string">5TEJ</span></span><br><span class="line"><span class="attr">CPU variant     :</span> <span class="number">0x0</span></span><br><span class="line"><span class="attr">CPU part        :</span> <span class="number">0x926</span></span><br><span class="line"><span class="attr">CPU revision    :</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Hardware        :</span> <span class="string">hi3518</span></span><br><span class="line"><span class="attr">Revision        :</span> <span class="number">0000</span></span><br><span class="line"><span class="attr">Serial          :</span> <span class="number">0000000000000000</span></span><br><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/proc/meminfo</span></span><br><span class="line"><span class="attr">MemTotal:</span>          <span class="number">35212</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">MemFree:</span>            <span class="number">1044</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Buffers:</span>             <span class="number">268</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Cached:</span>            <span class="number">10016</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapCached:</span>            <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Active:</span>            <span class="number">11536</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Inactive:</span>           <span class="number">5432</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Active(anon):</span>       <span class="number">6996</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Inactive(anon):</span>     <span class="number">2944</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Active(file):</span>       <span class="number">4540</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Inactive(file):</span>     <span class="number">2488</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Unevictable:</span>           <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Mlocked:</span>               <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapTotal:</span>             <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapFree:</span>              <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Dirty:</span>               <span class="number">600</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Writeback:</span>             <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">AnonPages:</span>          <span class="number">6708</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Mapped:</span>             <span class="number">5344</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Shmem:</span>              <span class="number">3256</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Slab:</span>               <span class="number">8152</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SReclaimable:</span>       <span class="number">1192</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SUnreclaim:</span>         <span class="number">6960</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">KernelStack:</span>         <span class="number">808</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">PageTables:</span>          <span class="number">692</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">NFS_Unstable:</span>          <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Bounce:</span>                <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">WritebackTmp:</span>          <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">CommitLimit:</span>       <span class="number">17604</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Committed_AS:</span>     <span class="number">312508</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">VmallocTotal:</span>     <span class="number">966656</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">VmallocUsed:</span>       <span class="number">23856</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">VmallocChunk:</span>     <span class="number">935280</span> <span class="string">kB</span></span><br><span class="line"><span class="string">$</span> <span class="string">df</span> <span class="string">-h</span></span><br><span class="line"><span class="string">Filesystem</span>                <span class="string">Size</span>      <span class="string">Used</span> <span class="string">Available</span> <span class="string">Use%</span> <span class="string">Mounted</span> <span class="string">on</span></span><br><span class="line"><span class="string">/dev/root</span>                 <span class="number">3.</span><span class="string">5M</span>      <span class="number">2.</span><span class="string">7M</span>    <span class="number">844.</span><span class="string">0K</span>  <span class="number">76</span><span class="string">%</span> <span class="string">/</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">17.</span><span class="string">2M</span>     <span class="number">16.</span><span class="string">0K</span>     <span class="number">17.</span><span class="string">2M</span>   <span class="number">0</span><span class="string">%</span> <span class="string">/dev</span></span><br><span class="line"><span class="string">/dev/mtdblock5</span>            <span class="number">8.</span><span class="string">9M</span>      <span class="number">8.</span><span class="string">1M</span>    <span class="number">784.</span><span class="string">0K</span>  <span class="number">91</span><span class="string">%</span> <span class="string">/home</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">32.</span><span class="string">0M</span>    <span class="number">164.</span><span class="string">0K</span>     <span class="number">31.</span><span class="string">8M</span>   <span class="number">1</span><span class="string">%</span> <span class="string">/tmp</span></span><br><span class="line"><span class="string">/dev/hd1</span>                 <span class="number">14.</span><span class="string">8G</span>      <span class="number">4.</span><span class="string">1G</span>     <span class="number">10.</span><span class="string">8G</span>  <span class="number">27</span><span class="string">%</span> <span class="string">/tmp/hd1</span></span><br><span class="line"><span class="string">tmpfs</span>                   <span class="number">512.</span><span class="string">0K</span>     <span class="number">16.</span><span class="string">0K</span>    <span class="number">496.</span><span class="string">0K</span>   <span class="number">3</span><span class="string">%</span> <span class="string">/home/mmap_tmpfs</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">16.</span><span class="string">0M</span>     <span class="number">36.</span><span class="string">0K</span>     <span class="number">16.</span><span class="string">0M</span>   <span class="number">0</span><span class="string">%</span> <span class="string">/home/tmpfs</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">16.</span><span class="string">0M</span>      <span class="number">3.</span><span class="string">0M</span>     <span class="number">13.</span><span class="string">0M</span>  <span class="number">19</span><span class="string">%</span> <span class="string">/home/jrview</span></span><br></pre></td></tr></table></figure>

<p>soc 用的好像是屁眼公司的 hi3518，小米在手机行业和华为干架那么厉害，芯片还是得用菊花厂的啊。</p>
<p>回归正题，我们开始交叉编译 rsync。一开始我用的是 ubuntu 上自带的交叉工具链 <code>gcc-arm-linux-gnueabi</code> 折腾半天编译出来的东西没法用，这才发现这个摄像头用的 libc 是 uClibc， 这种低端错误都犯了，之前自己做嵌入式的时候最常用的就是 uClibc 都忘记了?。</p>
<p>后来想办法下载一个 <code>arm-linux-uclibc-gcc</code> ubuntu 上好像没有现成的源可以下，Google 一下发现了这个 maillist <a href="http://lists.busybox.net/pipermail/buildroot/2010-January/031634.html。" target="_blank" rel="noopener">http://lists.busybox.net/pipermail/buildroot/2010-January/031634.html。</a></p>
<p>这个帖子讨论的是一个叫 <a href="https://buildroot.org/" target="_blank" rel="noopener">buildroot</a> 的东西。我研究了一下这个项目，它竟然可以一键 build 出整个嵌入式系统，包括 host 上运行的交叉工具链、bootloader、kernel、root filesystem甚至是各种软件包，其中就包括 rsync。那我还费心找什么工具链啊，直接用它就好了。</p>
<p>现在要做的就是找一台 Linux 机器，在上面运行以下命令，编译出 rsync。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://buildroot.org/downloads/buildroot-2016.11.1.tar.gz</span><br><span class="line">tar xvf buildroot-2016.11.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> buildroot-2016.11.1</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>执行 <code>make menuconfig</code> 之后会出现一个菜单（和编译内核的菜单用的同一个）。</p>
<ul>
<li>进入 <code>Target options</code> 再进入 <code>Target Architecture</code> 菜单，选择 <code>ARM (little endian)</code></li>
<li>进入 <code>Target Architecture Variant</code> 选择 <code>arm926t</code> 其他选项不用动，按两下 esc 退出来</li>
<li>进入 <code>Toolchain</code> 菜单，<code>C library</code> 选择 <code>uClibc-ng</code></li>
<li>进入 <code>Kernel Headers</code>，貌似没有 <code>3.0.8</code> 选个最低的 <code>Linux 3.2.x kernel headers</code> 吧</li>
<li>退出来进入 <code>Target packages</code>，在 <code>Networking applications</code> 里找到 <code>rsync</code> 按空格键打上勾</li>
<li>退出来进入 <code>Shell and utilities</code> 把 <code>inotify-tools</code> 打上勾，这个我们也要用到</li>
<li>按 tab 键，使光标移动到 <code>Save</code>，回车存盘退出。</li>
</ul>
<p>之后执行 make，经过漫长的等待，终于编译好了。进入到 buildroot-2016.11.1/output/target 文件夹可以看到整个根目录，在 <code>/usr/bin</code> 可以看到编译好的 rsync 。不过只把这个文件放到摄像头是不行的，因为还有 rsync 的动态链接库 so 文件也得放进去。</p>
<p>我直接 <code>tar zxcf target.tgz ./target</code> 把根目录打包，放到摄像头内。然后摄像头开机进入 shell，执行 <code>tar xvf target.tgz</code> 解包到内存卡里。然饿。。。现在也不能运行，因为必须把链接库的目录设置好，在 shell 里再执行一下 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/tmp/hd1/target/bin:/tmp/hd1/target/usr/bin</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/tmp/hd1/target/lib:/tmp/hd1/target/usr/lib</span><br></pre></td></tr></table></figure>

<p>这个是把动态库的搜索路径设置好，具体可以看我<a href="https://lengzzz.com/note/linux-so-search-path">这篇文章</a>，现在，执行 rsync，竟然报错 <code>libz.so.1 not found</code> 。我进入发现只有 <code>libz.so.1.2.8</code> 并没有 <code>libz.so.1</code> 原来是因为内存卡是 fat32，不支持软连接，只好复制一份了?。<code>cp libz.so.1.2.8 libz.so.1</code> 这也是没有办法的事。</p>
<p>最后，执行一下 rsync，可以看到久违的帮助信息了，真不容易。</p>
<h2 id="自动同步脚本"><a href="#自动同步脚本" class="headerlink" title="自动同步脚本"></a>自动同步脚本</h2><p>rsync 只能同步一次文件，当文件保持同步之后就会退出，怎么样想个方法能让两端文件实时同步呢？答案是利用 <a href="https://github.com/rvoicilas/inotify-tools" target="_blank" rel="noopener">inotify-tool</a>。这个工具利用了内核的通知系统，当文件进行改动之后，就会发出一个通知，此时再调用 rsync 进行同步就可以了。</p>
<p>所以把它写成了一个脚本[^ref4]：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/tmp/hd1/target/lib:/tmp/hd1/target/usr/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/tmp/hd1/target/bin:/tmp/hd1/target/usr/bin</span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=<span class="string">"xxxxx"</span></span><br><span class="line"></span><br><span class="line">SRC=/tmp/hd1/record/</span><br><span class="line">DST=rsync://YiCamera@10.0.0.222/YiCamera/</span><br><span class="line">nowtime=$(date +%s)</span><br><span class="line">inotifywait -mrq --timefmt <span class="string">'%s'</span> --format <span class="string">'%T'</span> -e modify,delete,create,attrib,move <span class="variable">$SRC</span> | <span class="keyword">while</span></span><br><span class="line"><span class="built_in">read</span> timestamp</span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line">    diffnow=$((<span class="variable">$nowtime</span> - <span class="variable">$timestamp</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$nowtime</span> <span class="variable">$timestamp</span> <span class="variable">$diffnow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$diffnow</span> -lt 5 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'start rsync'</span></span><br><span class="line">        rsync -vzrtopg --delete <span class="variable">$SRC</span> <span class="variable">$DST</span></span><br><span class="line">        nowtime=$(date +%s)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>解释一下这个脚本。前两句不用说了，第三局是导出一个系统变量，rsync 会读取这个变量拿到 rsync 的密码[^ref2]。之后是调用 inotifywait，当他发现文件的修改、删除、创建、修改属性时，会输出到标准输出中。</p>
<p>标准输出被重定向到管道中，<code>read files</code> 当接不到数据时会 block，当接收到数据之后会向下执行 rsync。</p>
<p>rsync 的参数 <code>-vzrtopg</code> 里的v是verbose，z是压缩，r是recursive，topg都是保持文件原有属性如属主、时间的参数，–delete参数会把原有getfile目录下的文件删除以保持客户端和服务器端文件系统完全一致<a href="[Rsync安全配置](http://wps2015.org/drops/drops/Rsync%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE.html)">^ref1</a>。</p>
<p>然后，在 <code>/etc/init.d</code> 创建一个服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/init.d/S90nasync</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/tmp/hd1/nasync.sh &gt;&gt; /tmp/hd1/nasync.log &amp;</span><br></pre></td></tr></table></figure>

<p>重启摄像头，你会发现，nas 里有自动同步过来的视频了。</p>
<p>[^ref2]: <a href="http://unix.stackexchange.com/questions/111526/rsync-without-prompt-for-password" target="_blank" rel="noopener">rsync without prompt for password</a></p>
<p>[^ref3]: <a href="http://unix.stackexchange.com/questions/59018/create-and-control-start-up-scripts-in-busybox" target="_blank" rel="noopener">Create and control start up scripts in BusyBox</a></p>
<p>[^ref4]: <a href="http://miaocbin.blog.51cto.com/689091/1662466" target="_blank" rel="noopener">Linux-rsync+inotify 文件实时同步</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a><a href="/tags/折腾/">折腾</a><a href="/tags/嵌入式/">嵌入式</a><a href="/tags/交叉编译/">交叉编译</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/01/02/小蚁摄像机实时同步视频到群晖nas/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/18/把你的Linux服务器打造成AirPlay音乐播放器/"><span>把你的 Linux 服务器打造成 AirPlay 音乐播放器</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/18/把你的Linux服务器打造成AirPlay音乐播放器/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-18T07:57:43.000Z">
          2016-11-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>AirPlay 是苹果设备上最方便的播放技术，可以很方便的把音频、视频串流到你的电视或音箱上。现在大部分智能电视都支持 AirPlay 投屏了，但是支持 AirPlay 的音响设备还是比较少见（and 贵）。那么，有没有比较廉价的搭建 AirPlay 音乐播放器的方式呢？那就是今天的主角 shairport-sync。</p>
<p><a href="/notename/" title="make your linux server a airplay player"></a></p>
<p>shairport 是一个音频 AirPlay receiver 服务器。但是不幸的是 shairport 的作者两年前停止更新了，就有了另一个开发者 fork 了 shairport 做出了 shairport-sync。</p>
<p>shairport-sync 基于 shairport，在此基础上还改进了音视频的同步的问题，这样使用 shairport-sync 播放视频时不会出现影音不同步的问题了。</p>
<h2 id="在-ubuntu-16-04-上安装-shairport-sync"><a href="#在-ubuntu-16-04-上安装-shairport-sync" class="headerlink" title="在 ubuntu 16.04 上安装 shairport-sync"></a>在 ubuntu 16.04 上安装 shairport-sync</h2><p>ubuntu 16.04 的软件仓库里已经集成了 shairport-sync，这样只需要执行 <code>apt install</code> 就可以安装了。</p>
<p>但是 shairport 还需要 avahi-daemon 这个服务，avahi-daemon 是开源的，它实现了苹果的 mDNS 协议（在苹果的设备上对应的服务是 Banjour）。shairport 需要在 avahi 上注册自己。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install avahi-daemon</span><br><span class="line">sudo apt install shairport-sync</span><br></pre></td></tr></table></figure>

<h2 id="配置-shairport-sync"><a href="#配置-shairport-sync" class="headerlink" title="配置 shairport-sync"></a>配置 shairport-sync</h2><p>shairport-sync 的配置非常简单，它的配置文件放在 <code>/etc/shairport-sync.conf</code> ，打开它之后会发现里面有很多配置项，我们只需要简单的配置下 name 就可以了，其他的选项不用动。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> General Settings</span><br><span class="line">general =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">//</span>	<span class="string">...</span></span><br><span class="line">    name = <span class="string">"客厅的服务器"</span>;</span><br><span class="line">    <span class="string">//</span>	<span class="string">...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改完配置之后记得重启一下服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shairport-sync.service</span><br></pre></td></tr></table></figure>

<h2 id="不出声音的故障"><a href="#不出声音的故障" class="headerlink" title="不出声音的故障"></a>不出声音的故障</h2><p>安装之后有可能会不出声音，这是因为 shairport 的用户不在 audio 组了，这样的话 shairport 没有音频设备的权限，执行下面语句可以解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG audio shairport-sync</span><br></pre></td></tr></table></figure>

<h2 id="最后来一张效果图"><a href="#最后来一张效果图" class="headerlink" title="最后来一张效果图"></a>最后来一张效果图</h2><p><img src="http://static.zybuluo.com/zwh8800/uw62xa700g4emr8karlhey0x/IMG_1197.PNG" alt="IMG_1197.PNG-394.9kB"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a><a href="/tags/AirPlay/">AirPlay</a><a href="/tags//"></a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/11/18/把你的Linux服务器打造成AirPlay音乐播放器/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/08/11/女朋友都能看懂的git速查/"><span>女朋友都能看懂的 git 速查</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/11/女朋友都能看懂的git速查/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-11T06:19:56.000Z">
          2016-08-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>为女朋友总结了一些常用的 git 操作。这个速查默认：以 master 为主分支，开发新功能创建新分支。</p>
<p><a href="/notename/" title="girlfriend readable git quick"></a></p>
<p><img src="http://static.zybuluo.com/zwh8800/p9gv31npuv5lqfnblpih4h8e/atlassian-getting-git-right.jpg" alt="atlassian-getting-git-right.jpg-94.4kB"></p>
<h2 id="1-开发一个功能"><a href="#1-开发一个功能" class="headerlink" title="1. 开发一个功能"></a>1. 开发一个功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先确保自己在 master 且代码是最新的</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最新的代码上建一个分支</span></span><br><span class="line">git checkout -b xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地进行开发</span></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"zzz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"yyy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"www"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发完成，push开发分支</span></span><br><span class="line">git push -u origin xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在代码审核工具上创建 pull request</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据别人的审核意见，修改代码</span></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"yyy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将修改后的代码push</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 审核通过，按按钮合并 pr</span></span><br></pre></td></tr></table></figure>

<h2 id="2-审核过了之后有冲突"><a href="#2-审核过了之后有冲突" class="headerlink" title="2. 审核过了之后有冲突"></a>2. 审核过了之后有冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先把 master 上的代码更新一下</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后把开发分支的代码 rebase 到最新的代码之上</span></span><br><span class="line">git checkout xxx</span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时，会出现冲突，打开文件，手动把文件修改正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后执行这个：</span></span><br><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时，开发分支 xxx 已经和 master 没有冲突了，push 上去</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在代码审核工具上，按按钮合并</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发了一半的功能，不想-commit-也不想丢掉"><a href="#3-开发了一半的功能，不想-commit-也不想丢掉" class="headerlink" title="3. 开发了一半的功能，不想 commit 也不想丢掉"></a>3. 开发了一半的功能，不想 commit 也不想丢掉</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把修改暂存起来</span></span><br><span class="line">git add .</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以查看刚刚暂存的信息</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在需要继续开发，把暂存的东西 pop 出来</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在再看暂存列表，已经清空了</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<h2 id="4-只提交某几个文件，其他几个文件暂存起来"><a href="#4-只提交某几个文件，其他几个文件暂存起来" class="headerlink" title="4. 只提交某几个文件，其他几个文件暂存起来"></a>4. 只提交某几个文件，其他几个文件暂存起来</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只提交这几个文件</span></span><br><span class="line">git add 1.go 2.go 3.go</span><br><span class="line">git commit -m <span class="string">"zzz"</span></span><br><span class="line"><span class="comment"># 看一下，剩下的文件确实未提交</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 暂存</span></span><br><span class="line">git add .</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure>

<h2 id="5-只提交某几行，其余行暂存"><a href="#5-只提交某几行，其余行暂存" class="headerlink" title="5. 只提交某几行，其余行暂存"></a>5. 只提交某几行，其余行暂存</h2><p>打开 sourcetree </p>
<p><img src="http://static.zybuluo.com/zwh8800/r4u5jiql8a1vxy09rkct22ef/image_1aps6uir211qg14423s41qjq85g9.png" alt="image_1aps6uir211qg14423s41qjq85g9.png-47.5kB"></p>
<p>选中像提交的行，点按钮暂存行</p>
<p>然后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只提交某几行</span></span><br><span class="line">git commit -m <span class="string">"zzz"</span></span><br><span class="line"><span class="comment"># 看一下，剩下的行确实没提交</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 暂存</span></span><br><span class="line">git add .</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>已暂存的修改，叫做 <code>stashed changes</code> </p>
</blockquote>
<h2 id="6-已经-git-add-的文件，想变回未-add-的状态"><a href="#6-已经-git-add-的文件，想变回未-add-的状态" class="headerlink" title="6. 已经 git add 的文件，想变回未 add 的状态"></a>6. 已经 git add 的文件，想变回未 add 的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 1.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想把所有文件都未 add 的状态</span></span><br><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>已经被 add 的修改，叫做 <code>staged changes</code>；未 add 的叫做 <code>unstaged changes</code> </p>
</blockquote>
<h2 id="7-已经修改，但未-add-的文件，想变回未修改的状态"><a href="#7-已经修改，但未-add-的文件，想变回未修改的状态" class="headerlink" title="7. 已经修改，但未 add 的文件，想变回未修改的状态"></a>7. 已经修改，但未 add 的文件，想变回未修改的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- 1.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想把所有文件都变回未修改的状态</span></span><br><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure>

<h2 id="8-已经-commit-了，但是不想要了，想回到上一个-commit-重新写"><a href="#8-已经-commit-了，但是不想要了，想回到上一个-commit-重新写" class="headerlink" title="8. 已经 commit 了，但是不想要了，想回到上一个 commit 重新写"></a>8. 已经 commit 了，但是不想要了，想回到上一个 commit 重新写</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回到上一个 commit，把这个 commit 的修改变成 unstaged changes</span></span><br><span class="line">git reset HEAD^</span><br><span class="line"><span class="comment"># 把 unstaged changes 变回未修改的状态</span></span><br><span class="line">git checkout -- .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新写</span></span><br></pre></td></tr></table></figure>

<h2 id="9-已经-commit，并且-push-了，但是不想要了，想回到上一个-commit-重新写"><a href="#9-已经-commit，并且-push-了，但是不想要了，想回到上一个-commit-重新写" class="headerlink" title="9. 已经 commit，并且 push 了，但是不想要了，想回到上一个 commit 重新写"></a>9. 已经 commit，并且 push 了，但是不想要了，想回到上一个 commit 重新写</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上，但是最后再push的时候需要加 -f</span></span><br><span class="line"></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<h2 id="9-上个方法太暴力了"><a href="#9-上个方法太暴力了" class="headerlink" title="9. 上个方法太暴力了"></a>9. 上个方法太暴力了</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个和上个提交完全相反的提交</span></span><br><span class="line">git revert HEAD</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/git/">git</a><a href="/tags/速查/">速查</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/08/11/女朋友都能看懂的git速查/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/07/18/总结golang对于stream的抽象/"><span>总结 golang 对于 stream 的抽象</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/07/18/总结golang对于stream的抽象/" rel="bookmark">
        <time class="entry-date published" datetime="2016-07-18T07:23:09.000Z">
          2016-07-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本文对 golang 标准库中的 stream 进行了一些总结。</p>
<p><a href="/notename/" title="golang stream"></a></p>
<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>在 golang 中，通过几个基本的 interface 对流操作进行了抽象。</p>
<h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>首先是最基本的Reader、Writer，定义了对于一个流来说最基本的操作：<strong>读、写</strong>。这两个 interface 定义在 <code>io</code> 包里。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Seeker、ReaderAt、WriterAt、Closer"><a href="#Seeker、ReaderAt、WriterAt、Closer" class="headerlink" title="Seeker、ReaderAt、WriterAt、Closer"></a>Seeker、ReaderAt、WriterAt、Closer</h3><p>更进一步的，最常见的流就是文件了。对于文件来说，除了简单的读写操作之外，还有 <strong>Seek、ReadAt、WriteAt、Close</strong> 操作。标准库对这些操作也进行了抽象。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>有了这些基础设施之后，就可以使用 golang 的<strong>组合</strong>大法了：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriteSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer</span><br><span class="line">    Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Seeker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>其他还有一些不很常用的操作。</p>
<p><strong>写到一个Writer中</strong>、<strong>从一个Reader中读取</strong>。这两个操作会自动判断EOF，如果没有把所有数据写完／读完，就会继续写／读。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些面向 <code>byte</code> 和 <code>rune</code> 的读写操作：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadByte() (c <span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ByteScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    ByteReader</span><br><span class="line">    UnreadByte() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ByteWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteByte(c <span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RuneReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadRune() (r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RuneScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    RuneReader</span><br><span class="line">    UnreadRune() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Scanner</code> 允许把一个读出的字节重新放回流中。这个操作有点类似 Peek 但是比 Peek 别扭一些。这种操作在做词法分析器的时候很有用。</p>
<p>下面是一些这些 interface 的实现。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>使用 <code>os.Open</code>、<code>os.OpenFile</code> 可以打开一个文件进行读写。它返回一个 <code>*os.File</code> 结构体，这个结构体实现了上面除了杂项外的接口。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>使用 <code>os.Pipe</code> 可以创建一个操作系统提供的管道（参见 unix 管道）。这个函数也是返回一个 <code>*os.File</code> 结构体。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><code>net.Conn</code> 是个 interface，他也实现了 <code>io.Reader</code>、<code>io.Writer</code>、<code>io.Closer</code> 这三个接口。</p>
<h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>有时候我们需要把一段内存当作流来处理，我们把这种设施叫做内存流。内存流在某些情况下非常有用。</p>
<h3 id="不阻塞的内存流"><a href="#不阻塞的内存流" class="headerlink" title="不阻塞的内存流"></a>不阻塞的内存流</h3><p>在 <code>strings</code> 包中，<code>strings.Reader</code> 实现了 <code>io.Reader</code> 、 <code>io.Seeker</code>、<code>io.ReaderAt</code>、<code>io.WriterTo</code>、<code>io.ByteScanner</code>、<code>io.RuneScanner</code> 这些接口。</p>
<p>可以将一个字符串当作一个<strong>只读流</strong>来使用。</p>
<p><code>bytes</code> 包中提供了一个比 <code>strings.Reader</code> 更高级的内存流－－ <code>bytes.Buffer</code>。它支持<strong>读写</strong>操作，同时还可以讲写入的数据转换成字符串来使用。这个结构体一般会被当做 golang 中的 StringBuilder 使用。</p>
<p>另外，如果需要将 []byte 转换为只读流，可以使用 <code>bytes.Reader</code> 它和 <code>strings.Reader</code> 类似。当数据只需要进行读操作时，使用这两个 Reader 会比 Buffer 要高效一些。</p>
<p>这些内存流都是非阻塞的，如果内存中没有数据了，会立即返回一个 EOF 错误。</p>
<h3 id="阻塞的内存流"><a href="#阻塞的内存流" class="headerlink" title="阻塞的内存流"></a>阻塞的内存流</h3><p>有时我们需要一个可以阻塞的内存流。当 buffer 中无数据的时候，Read 操作会被阻塞住；当 buffer 满时，Write 操作也会阻塞。</p>
<p><code>io.Pipe</code> 提供了这个功能。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span> <span class="params">(*PipeReader, *PipeWriter)</span></span></span><br></pre></td></tr></table></figure>

<p>使用 <code>io.Pipe</code> 函数创建一对 pipe，对 PipeReader 进行读操作，对<br>PipeWriter 进行写操作。</p>
<h2 id="杂七杂八的功能"><a href="#杂七杂八的功能" class="headerlink" title="杂七杂八的功能"></a>杂七杂八的功能</h2><p><code>io.LimitReader</code> 函数可以限制一个 Reader 的读取字节数</p>
<p><code>io.TeeReader</code> 可以在你读一个 Reader 的同时，将数据写入到一个 Writer 中：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teeExample</span><span class="params">(input io.Reader)</span></span> &#123;</span><br><span class="line">    backup := os.Create(<span class="string">"xxx.log"</span>)</span><br><span class="line">    r := io.TeeReader(input, backup)</span><br><span class="line">    fmt.Println(io.ReadAll(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子可以将 input 的内容同时写到 console 和 xxx.log 文件中。</p>
<p><code>io.MultiReader</code>、<code>io.MultiWriter</code> 函数可以将多个 Reader 或 Writer 合并成一个 Reader 或 Writer。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/标准库/">标准库</a><a href="/tags/golang/">golang</a><a href="/tags/stream/">stream</a><a href="/tags/io/">io</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/07/18/总结golang对于stream的抽象/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 wastecat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47471611-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>