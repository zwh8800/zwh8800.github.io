<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>移植 LuaCoco | wastecat的博客</title>

  
  <meta name="author" content="wastecat">
  

  
  <meta name="description" content="lua 语言最大的卖点之一就是他的协程（coroutine）了。但是在 lua5.1 中有一个文档都没提到的一个坑：协程只能在 lua 中使用，当调用 yield 时，如果当前的调用栈上有 c 代码，则会报错 “attempt to yield across metamethod/C-call boundary”。目前有个第三方的 patch 叫做 luaCoco 可以让 lua 支持 “真协程”。本文研究了 luaCoco 的内部实现，并把它移植到了 xtensa 处理器上。">
  

  
  
  <meta name="keywords" content="lua,coroutine,协程,移植">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="移植 LuaCoco"/>

  <meta property="og:site_name" content="wastecat的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wastecat的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">wastecat的博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>移植 LuaCoco</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/30/移植LuaCoco/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-30T04:13:43.000Z">
          2017-05-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>lua 语言最大的卖点之一就是他的协程（coroutine）了。但是在 lua5.1 中有一个文档都没提到的一个坑：协程<strong>只能</strong>在 lua 中使用，当调用 yield 时，如果当前的调用栈上有 c 代码，则会报错 <strong>“attempt to yield across metamethod/C-call boundary”</strong>。目前有个第三方的 patch 叫做 <a href="http://coco.luajit.org/" target="_blank" rel="noopener" title="Coco — True C Coroutines for Lua">luaCoco</a> 可以让 lua 支持 “真协程”。本文研究了 luaCoco 的内部实现，并把它移植到了 <a href="https://en.wikipedia.org/wiki/Tensilica" target="_blank" rel="noopener">xtensa</a> 处理器上。</p>
<p><a href="/notename/" title="porting luaCoco"></a></p>
<p><img src="/images/7101caf8fc0075b8d52d5a15ad9f6cb9.png" alt="image_1bhbpomnrk0m58270a54k789.png-16.9kB"></p>
<a id="more"></a>

<p>[toc]</p>
<h2 id="setjmp-的实现"><a href="#setjmp-的实现" class="headerlink" title="setjmp 的实现"></a>setjmp 的实现</h2><p>在文章的开头需要先讲解一下c语言标准库中 <a href="http://www.cplusplus.com/reference/csetjmp/" target="_blank" rel="noopener">setjmp</a> 的内部实现，因为之后的 luaCoco 的实现就是对 setjmp 的数据结构的一个 hack。</p>
<p>先看看 setjmp 的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jmp_buf buf;</span><br><span class="line">    <span class="keyword">int</span> code = setjmp(buf);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before jmp\n"</span>);</span><br><span class="line">        longjmp(buf, <span class="number">1024</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"jmp here, code: %d\n"</span>, code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 setjmp 的时候，会返回 0，从而会执行 <code>if (code == 0) {</code> 为 true 的 block，会打印出 <code>before jmp</code>。当执行了 longjmp 之后，程序的执行会重新跳转到 setjmp 那一行（第七行）然而这次 setjmp 的返回值 code 不再是 0，而是 longjmp 的第二个参数（1024），这样就会打印出 <code>jmp here, code: 1024</code>。</p>
<p>利用 setjmp 的这个功能能实现出很多有趣的东西，比如在c语言中做 <code>Exception</code>，但是 setjmp 是怎么实现的呢？我们去读一读源码。</p>
<p>libc 的实现有好多种，常见的比如 glibc、uclibc 和 musl-libc，但是我们这次读一读 newlib 的源码。newlib 也是一个 libc 的实现，常用于嵌入式开发中。</p>
<p>打开 inlcude/machine/setjmp-dj.h 文件，可以看到 jmp_buf 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from inlcude/machine/setjmp-dj.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">&#125; jmp_buf[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>发现这个结构体是用来存储 cpu 的寄存器的。这里很好理解，因为要实现 长跳转（longjmp），必须要首先把跳转的目的地的<strong>现场</strong>先保存下来。</p>
<p>setjmp 函数做的工作就是保存现场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; from machine&#x2F;i386&#x2F;setjmp.S</span><br><span class="line"> &#x2F;*</span><br><span class="line"> **	jmp_buf:</span><br><span class="line"> **	 eax ebx ecx edx esi edi ebp esp eip</span><br><span class="line"> **	 0   4   8   12  16  20  24  28  32</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">       #include &quot;i386mach.h&quot;</span><br><span class="line"></span><br><span class="line">        .global SYM (setjmp)</span><br><span class="line">        .global SYM (longjmp)</span><br><span class="line">       SOTYPE_FUNCTION(setjmp)</span><br><span class="line">       SOTYPE_FUNCTION(longjmp)</span><br><span class="line"> </span><br><span class="line">SYM (setjmp):</span><br><span class="line"></span><br><span class="line">	pushl	ebp</span><br><span class="line">	movl	esp,ebp</span><br><span class="line"></span><br><span class="line">	pushl	edi</span><br><span class="line">	movl	8 (ebp),edi</span><br><span class="line"></span><br><span class="line">	movl	eax,0 (edi)</span><br><span class="line">	movl	ebx,4 (edi)</span><br><span class="line">	movl	ecx,8 (edi)</span><br><span class="line">	movl	edx,12 (edi)</span><br><span class="line">	movl	esi,16 (edi)</span><br><span class="line"></span><br><span class="line">	movl	-4 (ebp),eax</span><br><span class="line">	movl	eax,20 (edi)    &#x2F;&#x2F; edi</span><br><span class="line"></span><br><span class="line">	movl	0 (ebp),eax</span><br><span class="line">	movl	eax,24 (edi)    &#x2F;&#x2F; ebp</span><br><span class="line"></span><br><span class="line">	movl	esp,eax</span><br><span class="line">	addl	$12,eax</span><br><span class="line">	movl	eax,28 (edi)    &#x2F;&#x2F; esp</span><br><span class="line">	</span><br><span class="line">	movl	4 (ebp),eax</span><br><span class="line">	movl	eax,32 (edi)    &#x2F;&#x2F; eip (PC)</span><br><span class="line"></span><br><span class="line">	popl	edi</span><br><span class="line">	movl	$0,eax</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<center>
![FullSizeRender 2.jpg-1881.4kB][2]
<small>setjmp 的栈帧</small>
</center>

<p>看图解释一下代码： </p>
<ul>
<li>17 行：push ebp 到栈上（esp 同时下移 4 字节）</li>
<li>18 行：ebp 指向 esp</li>
<li>20 行：push edi 到栈上（esp 同时再下移 4 字节）</li>
<li>21 行：8(ebp) 保存的是 jmp_buf 的指针，先把它放到 edi 中</li>
<li>23 - 27 行：分别把 eax、ebx、ecx、edx、esi 保存到 jmp_buf 里</li>
<li>29 - 30 行：-4 (ebp) 是edi，如图</li>
<li>32 - 33 行：(ebp) 就是之前的ebp，如图</li>
<li>35 - 37 行：保存 esp</li>
<li>39 - 40 行：如图，保存 <code>return addr</code> 到 jmp_buf-&gt;eip</li>
</ul>
<p>longjmp 的实现是正好相反的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SYM (longjmp):</span><br><span class="line">	pushl	ebp</span><br><span class="line">	movl	esp,ebp</span><br><span class="line"></span><br><span class="line">	movl	8(ebp),edi	&#x2F;* get jmp_buf *&#x2F;</span><br><span class="line">	movl	12(ebp),eax	&#x2F;* store retval in j-&gt;eax *&#x2F;</span><br><span class="line">	testl	eax,eax</span><br><span class="line">	jne	0f</span><br><span class="line">	incl	eax</span><br><span class="line">0:</span><br><span class="line">	movl	eax,0(edi)</span><br><span class="line"></span><br><span class="line">	movl	24(edi),ebp</span><br><span class="line"></span><br><span class="line">       __CLI</span><br><span class="line">	movl	28(edi),esp</span><br><span class="line">	</span><br><span class="line">	pushl	32(edi)	</span><br><span class="line"></span><br><span class="line">	movl	0(edi),eax</span><br><span class="line">	movl	4(edi),ebx</span><br><span class="line">	movl	8(edi),ecx</span><br><span class="line">	movl	12(edi),edx</span><br><span class="line">	movl	16(edi),esi</span><br><span class="line">	movl	20(edi),edi</span><br><span class="line">       __STI</span><br><span class="line"></span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>代码就不赘述了，基本上就是恢复<strong>现场</strong>、把longjmp的第二个参数作为返回值返回（7 - 9 行还有一个判断：如果参数为0的话，会把它改成 1）。</p>
<h2 id="LuaCoco-的实现"><a href="#LuaCoco-的实现" class="headerlink" title="LuaCoco 的实现"></a>LuaCoco 的实现</h2><p>首先在看代码之前，先简单讲解一下我对 LuaCoco 的理解。lua 的协程其实也就是为每个协程维护了一个 context（所谓 context，既程序执行到某个地方时的状态，包括寄存器、callstack）。当协程之前相互 yield 的时候，切换一下 context。但是 lua 没做好的地方是 lua 仅保存了 lua 程序的 context，而 c 代码的 context 是没有保存的。这是因为 lua 很追求使用 pure c，不希望在源码中加入过多平台相关的东西。保存 lua 的 context 是比较简单的，因为所有 lua 程序相关的数据结构都放在 lua 虚拟机里，只需要每个 coroutine 保存一份就好了，而取得／保存 c 代码的上下文是需要操作平台相关的寄存器的。LuaCoco 就是为每个常见的平台都做了一份保存 c 程序 context 的实现。</p>
<p>下面看 LuaCoco 的源码。</p>
<p>LuaCoco 是对 lua 源码的一个 patch，coco 改动了 lua 的以下文件：</p>
<p><img src="/images/d6fcc3dbe149d5f6cdc4eeb0fba867b1.png" alt="image_1bhcc3die5r3c7tg95ab069b1e.png-22.7kB"></p>
<p>最主要的文件就是 lcoco.c 和 lcoco.h 了：</p>
<p>我看源码一般喜欢先看一下 header 文件，瞄一眼 coco 大体上做了什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from lcoco.h</span></span><br><span class="line"><span class="comment">/* Exported C API to add a C stack to a coroutine. */</span></span><br><span class="line"><span class="function">LUA_API lua_State *<span class="title">lua_newcthread</span><span class="params">(lua_State *L, <span class="keyword">int</span> cstacksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal support routines. */</span></span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">void</span> <span class="title">luaCOCO_free</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_resume</span><span class="params">(lua_State *L, <span class="keyword">int</span> nargs)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_yield</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_cstacksize</span><span class="params">(<span class="keyword">int</span> cstacksize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>lcoco.h 里声明了 coco 定义的 4 个函数。很明显，lua_newcthread 是为了取代原生 lua 中的 lua_newthread 函数的。这一点可以在 lbaselib.c 文件的改动中看到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from lbaselib.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">luaB_cocreate</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COCO_DISABLE</span></span><br><span class="line">  lua_State *NL = lua_newthread(L);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp; !lua_iscfunction(L, <span class="number">1</span>), </span><br><span class="line">    <span class="number">1</span>, <span class="string">"Lua function expected"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> cstacksize = luaL_optint(L, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  lua_State *NL = lua_newcthread(L, cstacksize);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                   (cstacksize &gt;= <span class="number">0</span> ? <span class="number">1</span> : !lua_iscfunction(L, <span class="number">1</span>)),</span><br><span class="line">                <span class="number">1</span>, <span class="string">"Lua function expected"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  lua_pushvalue(L, <span class="number">1</span>);  <span class="comment">/* move function to top */</span></span><br><span class="line">  lua_xmove(L, NL, <span class="number">1</span>);  <span class="comment">/* move function from L to NL */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用宏判断了是否开启 coco，如果开启的话就使用新的 lua_newcthread，否则的话还使用原生的 lua_newthread。</p>
<p>那么，下一步就着重来看看 lua_newcthread 的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a C stack to a coroutine. */</span></span><br><span class="line"><span class="function">lua_State *<span class="title">lua_newcthread</span><span class="params">(lua_State *OL, <span class="keyword">int</span> cstacksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lua_State *NL = lua_newthread(OL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cstacksize &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> NL;</span><br><span class="line">  <span class="keyword">if</span> (cstacksize == <span class="number">0</span>)</span><br><span class="line">    cstacksize = defaultcstacksize;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cstacksize &lt; COCO_MIN_CSTACKSIZE)</span><br><span class="line">    cstacksize = COCO_MIN_CSTACKSIZE;</span><br><span class="line">  cstacksize &amp;= <span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line">  COCO_NEW(OL, NL, cstacksize, ((coco_MainFunc)(coco_main)))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看函数签名，发现比原生的 newthread 多了一个 cstacksize 参数，因为现在需要为 c 程序保存上下文，c 程序的执行需要一个 stack，所以每个 coroutine 都要有一个自己的 stack。这个 cstacksize 参数就是用来控制这个 stack 的大小的。</p>
<p>继续看代码，几个 if 的意思也很清晰，不表。发现重要的功能都封装到了 <code>COCO_NEW</code> 这个宏里面了。再一翻代码，这个宏又套了好几层宏和宏判断，搞得我很郁闷。所以我就使出了我的编译器大法！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -DCOCO_USE_SETJMP -D__linux__ -D_I386_JMP_BUF_H -D__i386 lcoco.c &gt; _lcoco.c</span><br></pre></td></tr></table></figure>

<p>这个命令可以让编译器只执行预处理，说白了就是把 c 语言的宏全部展开。命令中定义的其他几个宏的意思分别是：使用 setjmp 实现协程、使用Linux架构、使用i386架构。</p>
<p>宏展开的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lua_State* <span class="title">lua_newcthread</span><span class="params">(lua_State* OL, <span class="keyword">int</span> cstacksize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ... if check</span></span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = luaM_realloc_(OL, <span class="literal">NULL</span>, <span class="number">0</span>, (cstacksize));</span><br><span class="line">    coco_State* coco = ((coco_State* )(((<span class="keyword">char</span>* ) <span class="number">0</span>) + ((((<span class="keyword">char</span>* )(ptr) - (<span class="keyword">char</span>* ) <span class="number">0</span>) + (cstacksize) - <span class="keyword">sizeof</span>(coco_State)) &amp; <span class="number">-16</span>)));</span><br><span class="line">    coco-&gt;allocptr = ptr;</span><br><span class="line">    coco-&gt;allocsize = cstacksize; &#123;</span><br><span class="line">      <span class="keyword">size_t</span>* stackptr = &amp; ((<span class="keyword">size_t</span>*) coco)[<span class="number">-1</span>];</span><br><span class="line">      _setjmp(coco-&gt;ctx);</span><br><span class="line">      coco-&gt;ctx-&gt;__pc = (((coco_MainFunc)(coco_main)));</span><br><span class="line">      coco-&gt;ctx-&gt;__sp = (stackptr);</span><br><span class="line">      coco-&gt;ctx-&gt;__bp = <span class="literal">NULL</span>;</span><br><span class="line">      stackptr[<span class="number">1</span> - <span class="number">1</span>] = <span class="number">0xdeadc0c0</span>;</span><br><span class="line">      coco-&gt;arg0 = (<span class="keyword">size_t</span>)(NL);</span><br><span class="line">    &#125;(((coco_State**)(NL))[<span class="number">-1</span>]) = coco;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，主要做的事情就是 alloc 了 coco_State 数据结构和 cstack。这里只申请了一次内存空间，然后通过指针操作分别把内存分成了 coco_State 和 cstack 两块。有点迷糊的可以看一下我画的图：</p>
<p><img src="/images/54aa11f5b1b9229bb14b4a0b83ea4a0d.jpeg" alt="WechatIMG23.jpeg-99.9kB"></p>
<p>申请好空间之后，11到16行初始化了 coco_State 的几个字段。</p>
<p>17行把 coco 的指针放到了 NL 的前面（我并不知道为什么可以这么做，反正就是可以，看的时候我一脸“还有这种操作？”的黑人问号）</p>
<center>
![IMG_0002.JPG-49.3kB][5]
</center>

<p>下面我们去看看 coco_State 的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coco_State</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> arg0;</span><br><span class="line">  jmp_buf ctx;</span><br><span class="line">  jmp_buf back;</span><br><span class="line">  <span class="keyword">void</span>* allocptr;</span><br><span class="line">  <span class="keyword">int</span> allocsize;</span><br><span class="line">  <span class="keyword">int</span> nargs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经过宏替换之后，coco_State 长上面这样。</p>
<p>lua_newcthread里的代码初始化了 ctx，allocptr，allocsize，arg0 字段。其中，对 ctx 的初始化操作比较让人在意，首先是调用 setjmp 初始化了 ctx，之后对 ctx 内部的几个字段进行了魔改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coco-&gt;ctx-&gt;__pc = (((coco_MainFunc)(coco_main)));</span><br><span class="line">coco-&gt;ctx-&gt;__sp = (stackptr);</span><br><span class="line">coco-&gt;ctx-&gt;__bp = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>有了之前 setjmp 的基础，这里就容易理解了，一旦对这个 ctx 调用 longjmp 的话，<strong>程序就会跳转到 <code>coco_main</code> 这个函数，并且把 stackptr 当作程序的 stack 来使用。这个 stack 的切换操作，其实就是程序 context 的切换</strong></p>
<p>我们先不看 <code>coco_main</code> 做了什么，先看看这个 longjmp 会在什么时候调用，动脑子想一想，应该会是再执行 resume 的时候调用 longjmp，果然不出所料：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaCOCO_resume</span><span class="params">(lua_State* L, <span class="keyword">int</span> nargs)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  coco-&gt;nargs = nargs;</span><br><span class="line">  <span class="keyword">if</span> (!_setjmp(coco-&gt;back)) _longjmp(coco-&gt;ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L-&gt;status != <span class="number">1</span>) &#123;</span><br><span class="line">    luaM_realloc_(L, ((((coco_State**)(L))[<span class="number">-1</span>])-&gt;allocptr), ((((coco_State**)(L))[<span class="number">-1</span>])-&gt;allocsize), <span class="number">0</span>);</span><br><span class="line">    (((coco_State**)(L))[<span class="number">-1</span>]) = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> L-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 resume 的时候，首先使用 setjmp 把主线程的状态保存到 <code>coco-&gt;back</code> 里，然后调转到 <code>coco_main</code>。</p>
<p>下面看 <code>coco_main</code> 做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coco_main</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    L-&gt;status = luaD_rawrunprotected(L, coco_start, L-&gt;top - (coco-&gt;nargs + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;status != <span class="number">0</span>) luaD_seterrorobj(L, L-&gt;status, L-&gt;top);</span><br><span class="line">    <span class="keyword">if</span> (!_setjmp(coco-&gt;ctx)) _longjmp(coco-&gt;back, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 首先通过L取到了coco的指针（又一次黑人问号）。然后通过 luaD_rawrunprotected 调用了 lua 程序（也就是lua子线程）。之后判断子线程时候出错，设置错误码。最后，保存子线程的状态到 ctx，然后跳转会 back（调转到了luaCOCO_resume 第6行）。</p>
<p>继续回来看 luaCOCO_resume 函数，第 6 行后面宏展开前其实是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L-&gt;status != LUA_YIELD) &#123;</span><br><span class="line">  COCO_FREE(L)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开前的代码比较容易懂：如果子线程执行完了，就 free 掉，没啥可说的。</p>
<p>最后看看 yield：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaCOCO_yield</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  L-&gt;status = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!_setjmp(coco-&gt;ctx)) _longjmp(coco-&gt;back, <span class="number">1</span>);</span><br><span class="line">  L-&gt;status = <span class="number">0</span>; &#123;</span><br><span class="line">    StkId base = L-&gt;top - coco-&gt;nargs;</span><br><span class="line">    StkId rbase = L-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (rbase &lt; base) &#123;</span><br><span class="line">      <span class="keyword">while</span> (base &lt; L-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">const</span> TValue* o2 = (base++);</span><br><span class="line">        TValue* o1 = (rbase++);</span><br><span class="line">        o1-&gt;value = o2-&gt;value;</span><br><span class="line">        o1-&gt;tt = o2-&gt;tt;</span><br><span class="line">        ((<span class="keyword">void</span>) <span class="number">0</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      L-&gt;top = rbase;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;base = L-&gt;ci-&gt;base;</span><br><span class="line">  <span class="keyword">return</span> coco-&gt;nargs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转那里和之前讲的一样，多了的东西没太明白，好像是在复制 lua_State 内部的数据。</p>
<p>LuaCoco 内部实现的内容基本上就这些了。</p>
<p>题外话：其实除了魔改 setjmp，LuaCoco还有三种实现，直接内连汇编、使用ucontext和使用fiber，大家可以通过执行 <code>gcc -E lcoco.c &gt; _lcoco.c</code> 加不同的宏定义来生成代码自行研究（其实原理都差不多）。</p>
<h2 id="xtensa-架构-ABI"><a href="#xtensa-架构-ABI" class="headerlink" title="xtensa 架构 ABI"></a>xtensa 架构 ABI</h2><p>这部分就简单讲一下带过了，毕竟不是那么通用的内容。</p>
<p>经常做移植的同学应该大多知道，移植的时候最重要的是需要了解这个 architecture 的 ABI（application binary interface）。Google 一番之后发现了<a href="http://0x04.net/~mwk/doc/xtensa.pdf" target="_blank" rel="noopener" title="Xtensa® Instruction Set Architecture (ISA)">这个pdf</a>，不过先不急着看 ABI，先看一下这个 CPU 的寄存器吧。</p>
<p>xtensa 有 16 个 32 位的通用寄存器，名字分别叫 A0 ～ A15，一个 PC 程序计数器，再加上一个 SAR 寄存器（不知道干嘛用的，不过好像移植的话用不上），还算挺简单的设计，没有奇奇怪怪的东西。</p>
<p>接下来，再看看 xtensa 的 ABI，在 PDF 的 chapter 8 里找到了 关于 Xtensa ABI 的部分。xtensa 使用了两种ABI，一种叫 <code>Windowed Register</code> 另一种叫 <code>CALL0</code> 。NodeMCU 只会用到 CALL0 所以我们简单讲一下 CALL0。</p>
<p>先看表格：</p>
<p>| Register        | Use   |<br>|    |   |<br>| a0 | Return Address |<br>| a1 (sp) | Stack Pointer (callee-saved) |<br>| a2 – a7 | Function Arguments |<br>| a8 | Static Chain (see Section 8.1.8) |<br>| a12 – a15 | Callee-saved |<br>| a15 | Stack-Frame Pointer (optional) |</p>
<p>A0 保存了函数的返回地址，A1保存了栈指针，a2到a7一共6个寄存器用于传递函数的参数，更多的参数会在栈中传递，a12-a15需要被调用者自己保存。</p>
<p>看完了寄存器的使用，看一下 xtensa 的栈帧（stack frame）格式：</p>
<p><img src="/images/94e476dfa01186c4655281e79aedcfa1.png" alt="image_1bktgc5jiv8p1bqh1ot5pcf1v0i9.png-37.6kB"></p>
<p>可以看出来，xtensa 的指针也是向低地址方向增长的。在 SP 的上面会保存依次 <code>6个参数以外的参数</code> 、<code>局部变量</code> 等</p>
<h2 id="移植-LuaCoco"><a href="#移植-LuaCoco" class="headerlink" title="移植 LuaCoco"></a>移植 LuaCoco</h2><p>搞清楚 ABI 了，最后的工作就是 coding 了。</p>
<p>遇到的第一个问题是，因为我们要对 setjmp 进行 hack，而不是使用汇编，所以我们仅能操作内存，而不能操作寄存器，所以如何将 lua_State 传递给 coco_main 呢？最常见的方法就是使用 哑参数（dummy args）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COCO_MAIN_PARAM		int _a, int _b, int _c, int _d, int _e, int _f, lua_State *L</span></span><br></pre></td></tr></table></figure>

<p>我们把 coco_main 的参数列表定义成这样，前面a到f的参数都是用不上的，这样就不用管 a2 到 a7 这几个寄存器了。所以我们只需要把L指针放到SP指的位置就好了。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">COCO_PATCHCTX(<span class="params">coco</span>, <span class="params">buf</span>, <span class="params">func</span>, <span class="params">stack</span>, <span class="params">a0</span>)</span> \</span><br><span class="line">  buf<span class="literal">[<span class="number">0</span>]</span> = (<span class="built_in">int</span>)(func); \</span><br><span class="line">  buf<span class="literal">[<span class="number">1</span>]</span> = (<span class="built_in">int</span>)(stack); \</span><br><span class="line">  stack<span class="literal">[<span class="number">0</span>]</span> = (size_t)(a0);</span><br></pre></td></tr></table></figure>

<p><code>stack[0] = (size_t)(a0);</code> 这一句中的 a0 就是 lua_State 的指针，把他放到了 SP[0] 这里。</p>
<p>第二个问题就是对 <code>jmp_buf</code> 进行 hack 了，我们需要搞明白 <code>jmp_buf</code> 里怎么放东西的，这需要看这个平台编译器的源码了。<a href="https://github.com/pfalcon/esp-open-sdk" target="_blank" rel="noopener">https://github.com/pfalcon/esp-open-sdk</a> 这里是编译器的源代码，他是使用 crosstool 的，会一边下载源代码，一遍编译，下载好的源代码放在 crosstool-NG/.build/src/newlib-2.0.0 ，正好我们看看 newlib 中 setjmp 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#else &#x2F;* CALL0 ABI *&#x2F;</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.align	4</span><br><span class="line">	.literal_position</span><br><span class="line">	.global	setjmp</span><br><span class="line">	.type	setjmp, @function</span><br><span class="line">setjmp:	</span><br><span class="line">	s32i	a0, a2, 0</span><br><span class="line">	s32i	a1, a2, 4</span><br><span class="line">	s32i	a12, a2, 8</span><br><span class="line">	s32i	a13, a2, 12</span><br><span class="line">	s32i	a14, a2, 16</span><br><span class="line">	s32i	a15, a2, 20</span><br><span class="line">	movi	a2, 0</span><br><span class="line">	ret</span><br><span class="line">	.size	setjmp, . - setjmp</span><br><span class="line"></span><br><span class="line">	.align	4</span><br><span class="line">	.literal_position</span><br><span class="line">	.global	longjmp</span><br><span class="line">	.type	longjmp, @function</span><br><span class="line">longjmp:</span><br><span class="line">	l32i	a0, a2, 0</span><br><span class="line">	l32i	a12, a2, 8</span><br><span class="line">	l32i	a13, a2, 12</span><br><span class="line">	l32i	a14, a2, 16</span><br><span class="line">	l32i	a15, a2, 20</span><br><span class="line">	l32i	a1, a2, 4</span><br><span class="line">	&#x2F;* Return val ? val : 1.  *&#x2F;</span><br><span class="line">	movi	a2, 1</span><br><span class="line">	movnez	a2, a3, a3</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line">	.size	longjmp, .-longjmp</span><br><span class="line"></span><br><span class="line">#endif &#x2F;* CALL0 ABI *&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面的 else 宏代表这段代码是使用 CALL0 ABI 才会被编译。看一下代码，可以了解到以下对应关系：</p>
<p>| jmp_buf | Register | Use |<br>|  |  |<br>| jup_buf[0] | a0 | Return Address |<br>| jmp_buf[1] | a1 | Stack Pointer (callee-saved) |<br>| jmp_buf[2] - jmp_buf[5] | a12 - a15 | Callee-saved |</p>
<p>所以这段代码也就不难理解了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">COCO_PATCHCTX(<span class="params">coco</span>, <span class="params">buf</span>, <span class="params">func</span>, <span class="params">stack</span>, <span class="params">a0</span>)</span> \</span><br><span class="line">  buf<span class="literal">[<span class="number">0</span>]</span> = (<span class="built_in">int</span>)(func); \</span><br><span class="line">  buf<span class="literal">[<span class="number">1</span>]</span> = (<span class="built_in">int</span>)(stack); \</span><br><span class="line">  stack<span class="literal">[<span class="number">0</span>]</span> = (size_t)(a0);</span><br></pre></td></tr></table></figure>

<p>分别是把 <code>buf[0]</code> 和 <code>buf[1]</code> 改成 coco_main 和 我们为协程新申请的栈。</p>
<p>其他代码基本上是 copy coco 的，详细的可以看我 github：</p>
<p><a href="https://github.com/zwh8800/nodemcu-firmware/commit/1f31aa32901f07b6414c0471eb19f7bdd44d93a6" target="_blank" rel="noopener">https://github.com/zwh8800/nodemcu-firmware/commit/1f31aa32901f07b6414c0471eb19f7bdd44d93a6</a> </p>
<p>[EOF] 基本上这次移植涉及到的内容就这些，完。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/lua/">lua</a><a href="/tags/coroutine/">coroutine</a><a href="/tags/协程/">协程</a><a href="/tags/移植/">移植</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'lengzzz';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 wastecat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47471611-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>