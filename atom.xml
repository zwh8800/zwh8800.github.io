<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wastecat的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lengzzz.com/"/>
  <updated>2020-04-30T07:08:36.496Z</updated>
  <id>https://lengzzz.com/</id>
  
  <author>
    <name>wastecat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你好世界</title>
    <link href="https://lengzzz.com/2020/04/30/hello-world/"/>
    <id>https://lengzzz.com/2020/04/30/hello-world/</id>
    <published>2020-04-30T07:08:36.496Z</published>
    <updated>2020-04-30T07:08:36.496Z</updated>
    
    <content type="html"><![CDATA[<p>这里是一只废喵，时隔多年，我又准备写博客了。这次搬家到了 GitHub pages，用上了hexo。整体感觉还不错，简单记录下折腾 hexo 的经历。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这几步是在本机上安装好 hexo，并且生成一个 hexo 项目文件。</p><a id="more"></a><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>默认的主题不太喜欢，换了个叫 <a href="https://github.com/CodeDaraW/Hacker" target="_blank" rel="noopener">Hacker</a> 的。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/CodeDaraW/Hacker themes/Hacker</span><br><span class="line">rm -rf themes/Hacker/.git</span><br></pre></td></tr></table></figure><p>这样就安装主题到 theme 目录了，当然也可以下载 zip，手动解压缩。</p><p>之后编辑 <code>_config.yml</code> 文件，修改成 <code>theme: Hacker</code>。</p><p>另外，主题本身也有一些配置，放在 <code>./themes/Hacker/_config.yml</code> 文件里。我的配置如下，根据自己不同需求做调整。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">Archives:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="attr">About:</span> <span class="string">/about</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gitment</span></span><br><span class="line"><span class="attr">gitment:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">gitment_owner:</span></span><br><span class="line"><span class="attr">gitment_repo:</span></span><br><span class="line"><span class="attr">gitment_client_id:</span></span><br><span class="line"><span class="attr">gitment_client_secret:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">gitalk_owner:</span></span><br><span class="line"><span class="attr">gitalk_admin:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">gitalk_repo:</span></span><br><span class="line"><span class="attr">gitalk_client_id:</span></span><br><span class="line"><span class="attr">gitalk_client_secret:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># valine comment</span></span><br><span class="line"><span class="attr">valine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">leancloud_id:</span></span><br><span class="line"><span class="attr">leancloud_key:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disqus comment</span></span><br><span class="line"><span class="attr">disqus:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">lengzzz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># google analytics</span></span><br><span class="line"><span class="attr">googleTrackId:</span> <span class="string">UA-47471611-1</span></span><br></pre></td></tr></table></figure><h2 id="配置CI"><a href="#配置CI" class="headerlink" title="配置CI"></a>配置CI</h2><p>travis-ci 能帮你在每次 push 时自动部署。基本上按照 <a href="https://hexo.io/zh-cn/docs/github-pages.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/github-pages.html</a> 这个教程就可以了，但是有个坑是目前 GitHub pages 只支持用 master 分支了，所以写文章的分支就不能是 master 了，我这里用的是 build 分支。相应的，<code>.travis.yml</code> 文件也需要修改一下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span> </span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span> <span class="comment"># 重点：这里分支改成写文章的分支</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ln</span> <span class="string">theme.config.yml</span> <span class="string">themes/Hacker/_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> </span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span> <span class="comment"># 重点：这里新增一个target_branch选项，值设定为 master</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">build</span> <span class="comment"># 重点：这里分支改成写文章的分支</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>Github pages 支持自定义域名，需要将www的域名CNAME设定为 <code>xxx.github.io</code>，另外需要把@域名（就是裸的没有任何子域名的，比如本站就是lengzzz.com）的A记录修改为下列IP：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">185.199.108.153</span></span><br><span class="line"><span class="number">185.199.109.153</span></span><br><span class="line"><span class="number">185.199.110.153</span></span><br><span class="line"><span class="number">185.199.111.153</span></span><br></pre></td></tr></table></figure><p>都设定好之后，在项目里 source 下新增一个 <code>CNAME</code> 文件（全大写），里面写上域名就ok了。</p><p>之后在 GitHub 项目的 setting 里，也将 Custom domain 里配置上域名。之后 GitHub 会自动签发域名的 ssl 证书。最好也将 setting 里的 Enforce HTTPS 勾上，这样能强制使用 https。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>大概等十几分钟后，使用域名 <a href="https://lengzzz.com/">https://lengzzz.com/</a> 就能访问到了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是一只废喵，时隔多年，我又准备写博客了。这次搬家到了 GitHub pages，用上了hexo。整体感觉还不错，简单记录下折腾 hexo 的经历。&lt;/p&gt;
&lt;h2 id=&quot;安装步骤&quot;&gt;&lt;a href=&quot;#安装步骤&quot; class=&quot;headerlink&quot; title=&quot;安装步骤&quot;&gt;&lt;/a&gt;安装步骤&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这几步是在本机上安装好 hexo，并且生成一个 hexo 项目文件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="闲扯" scheme="https://lengzzz.com/tags/%E9%97%B2%E6%89%AF/"/>
    
  </entry>
  
  <entry>
    <title>网件 R6220 刷机 LEDE（openwrt）固件教程</title>
    <link href="https://lengzzz.com/2017/08/20/%E7%BD%91%E4%BB%B6R6220%E5%88%B7%E6%9C%BALEDE%EF%BC%88openwrt%EF%BC%89%E5%9B%BA%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    <id>https://lengzzz.com/2017/08/20/%E7%BD%91%E4%BB%B6R6220%E5%88%B7%E6%9C%BALEDE%EF%BC%88openwrt%EF%BC%89%E5%9B%BA%E4%BB%B6%E6%95%99%E7%A8%8B/</id>
    <published>2017-08-20T07:22:39.000Z</published>
    <updated>2017-09-18T08:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>家里一直用的是网件的 R6220 路由器，之前一直用的是原厂固件，因为本人不太喜欢在主路由器上装奇奇怪怪的东西，另外是因为 R6220 一直都没有好用的固件可以刷，前几天逛论坛发现竟然已经有人破解了 R6220 可以刷 LEDE 和 pandora 了，忍不住手痒又去刷了一波固件。此文记录一下过程。</p><p><a href="/notename/" title="install lede on netgear r6220"></a></p><a id="more"></a><p>[toc]</p><blockquote><p><strong>请全程使用网线连接进行操作，操作时千万不要断电，因为 R6220 使用 NAND flash，刷坏后无法使用普通编程器修复，刷机有风险，请扶稳方向盘谨慎驾驶</strong></p></blockquote><h2 id="1-开启路由器telnet"><a href="#1-开启路由器telnet" class="headerlink" title="1. 开启路由器telnet"></a>1. 开启路由器telnet</h2><p>在浏览器打开 <a href="http://192.168.1.1/setup.cgi?todo=debug" target="_blank" rel="noopener">http://192.168.1.1/setup.cgi?todo=debug</a> 这个网址，记着把 192.168.1.1 替换成你路由器的 ip 地址，成功后会显示 <code>Debug Enabled !</code> 说明已经成功。</p><p>使用 Mac 或 Linux 的用户，打开终端，执行 <code>telnet 192.168.1.1</code> ，可以登录到路由器的管理shell里，使用 windows 的用户，可以<a href="https://the.earth.li/~sgtatham/putty/latest/w32/putty.exe" target="_blank" rel="noopener">点这里</a>下载 putty，然后如下图，Host Name填路由器ip，port写23，connection type 选 telnet：</p><p><img src="/images/1a797a80091c5a2290a090407be0801f.png" alt="image_1bnv9ksf91joebhc5uvi451l14p.png-84.3kB"></p><p>点击 open 之后，会出现一个黑屏窗口，显示 <code>R6220 login:</code> ，输入 <code>root</code> 按回车，会显示一个大的 logo 和一个 <code>#</code> 号（如下），此时说明已经登录成功了。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Welcome to</span><br><span class="line">    _______  _______  ___     __  ____   _  _   ___</span><br><span class="line">    |<span class="string">  ___  \</span>|<span class="string">   __  </span>||<span class="string">   </span>|<span class="string">   </span>|<span class="string">__</span>||<span class="string">    \ </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string"> /  /</span></span><br><span class="line"><span class="string">    </span>|<span class="string"> </span>|<span class="string">___</span>|<span class="string"> </span>||<span class="string">  </span>|<span class="string">__</span>|<span class="string"> </span>||<span class="string">   </span>|<span class="string">__  __ </span>|<span class="string">     \</span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">/  /</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   _   /</span>|<span class="string">   _   </span>||<span class="string">      </span>||<span class="string">  </span>||<span class="string"> </span>|<span class="string">\     </span>||<span class="string">     \</span></span><br><span class="line"><span class="string">    </span>|<span class="string">__</span>|<span class="string"> \__\</span>|<span class="string">__</span>|<span class="string"> </span>|<span class="string">__</span>||<span class="string">______</span>||<span class="string">__</span>||<span class="string">_</span>|<span class="string"> \____</span>||<span class="string">_</span>|<span class="string">\___\</span></span><br><span class="line"><span class="string">                     =System Architecture Department=</span></span><br><span class="line"><span class="string">#</span></span><br></pre></td></tr></table></figure><h2 id="2-备份eeprom"><a href="#2-备份eeprom" class="headerlink" title="2. 备份eeprom"></a>2. 备份eeprom</h2><blockquote><p>此步骤可跳过，但有一定几率无法使用 Wi-Fi</p></blockquote><p>准备一个格式化成 fat32 的U盘（最好重新格式化，卷标写成U），插入 R6220 的USB口中，然后在刚才的黑窗口里输入命令：<code>ls /mnt/shares</code></p><p>会显示出你刚才优盘的卷标名，如果重新格式化成 U 了，那么就会显示一个 U。</p><p>下一步，执行 <code>cd /mnt/shares/优盘的卷标名</code> ，同理如果刚才显示 U 这里就应该执行 <code>cd /mnt/shares/U</code>。</p><p>如果没有报错的话就进行下一步：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/mtd10 <span class="attribute">of</span>=./mtd10.bin</span><br></pre></td></tr></table></figure><p>这是为了把 eeprom 备份到U盘中。如果执行之后，显示一个 <code>#</code> 说明成功了。现在把U盘拔下来插到电脑上，可以看到一个 mtd10.bin 文件，把它复制到电脑上备份。</p><h2 id="3-刷写不死-bootloader-pb-boot"><a href="#3-刷写不死-bootloader-pb-boot" class="headerlink" title="3. 刷写不死 bootloader pb-boot"></a>3. 刷写不死 bootloader pb-boot</h2><p>从这里下载 pb-boot：</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1jIONs6i" target="_blank" rel="noopener">https://pan.baidu.com/s/1jIONs6i</a> 密码: nyn9</p></blockquote><p>把这个文件放到U盘里，插入到路由器中。</p><p>使用 telnet 登陆到路由器，和第二步一样，执行 <code>cd /mnt/shares/U</code> 进入到U盘文件夹。执行下面的命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd_write write pb-boot-r6220<span class="number">-20170801.</span>img Bootloader</span><br></pre></td></tr></table></figure><p>成功后会显示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unlocking Bootloader <span class="built_in">..</span>.</span><br><span class="line">Writing <span class="keyword">from</span> pb-boot-r6220.bin <span class="keyword">to</span> Bootloader <span class="built_in">..</span>.  [w]</span><br></pre></td></tr></table></figure><p>接下来路由器关机，然后用针扎着reset键开机，开机后发现电源灯和wan口灯呼吸闪烁，说明进入了 bootloader，在浏览器中输入 192.168.1.1 会看到 pb-boot 的界面：</p><p><img src="/images/6f4b994612ac748b39bf5768d96db680.png" alt="image_1bnvblmm81d0t1hgfpfu1h0ft4116.png-107.3kB"></p><p>现在说明不死 bootloader 已经刷好了，可以随意折腾路由器而不怕刷坏了，无论何时感觉刷坏了，都可以用针扎着reset键开机，来反复刷机重置系统。</p><blockquote><p>小知识：bootloader 是在操作系统运行之前先运行的一个小程序，类似电脑的 bios，折腾路由器时就算把系统搞坏了，只要 bootloader 没被破坏，都可以刷回出厂设置的。</p></blockquote><h3 id="3-1-mac-用户会遇到的坑"><a href="#3-1-mac-用户会遇到的坑" class="headerlink" title="3.1 mac 用户会遇到的坑"></a>3.1 mac 用户会遇到的坑</h3><p>使用 mac 的用户再刷写了 pb-boot 之后，会发现无法获取到 IP 地址，可以这样操作：</p><p>在<strong>系统偏好设置</strong>中点网络，把网卡设置成下图所示：</p><p><img src="/images/3e9a5f6d55c07d805533d03e2d3b8a24.png" alt="image_1bnvc6apsorr15en13he1l7s1mei1j.png-107.3kB"></p><p>打开<strong>终端</strong>反复执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">arp</span> <span class="selector-tag">-ad</span></span><br><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">arp</span> <span class="selector-tag">-s</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span><span class="selector-pseudo">:ff</span></span><br></pre></td></tr></table></figure><p>第一次可能会要求你输密码，输入即可</p><p>每执行一遍就再浏览器中刷新一次 192.168.1.1 ，直到浏览器能打开网页后停止执行命令。</p><h2 id="4-刷-LEDE-官方固件"><a href="#4-刷-LEDE-官方固件" class="headerlink" title="4. 刷 LEDE 官方固件"></a>4. 刷 LEDE 官方固件</h2><p>一开始我是在 <a href="http://www.right.com.cn/forum/thread-208580-1-1.html" target="_blank" rel="noopener">恩山无限论坛</a> 下载的网友编译的固件，他的固件本身集成了好多功能，比如 广告屏蔽大师和s-s，不爱折腾的人刷他的固件用自带的功能就够用了，但是他的固件有个问题，固件的内核版本不是官方的版本，没办法安装官方软件仓库里的 kmod 软件包（可以强制安装，但是会大几率无限重启），另外固件的 opkg 好像也没有配置好，安装软件包会比较折腾。所以我建议还是先刷网友版，然后升级成官方版。</p><p>先从这里下载恩山网友版固件</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1c1YSCLy" target="_blank" rel="noopener">https://pan.baidu.com/s/1c1YSCLy</a> 密码: 36vm</p></blockquote><p>然后在 192.168.1.1 里，点击 browse 选择刚才下载的网友版固件，再点击 Firmware update，等 1 分钟就刷好了。</p><p>再次刷新 192.168.1.1 网页，发现已经进入 lede 的界面了。</p><p><img src="/images/772ab39a5aa6a5091dc7111ab7983f0f.png" alt="image_1bnvcca3pf6dfb6177rr9b70o20.png-23.1kB"></p><p>用户名填 root，密码输admin，进入到管理界面中。</p><p>然后左侧点击<strong>网络</strong>、<strong>接口</strong>，把 WAN 口配置好，尝试一下能不能上去网。</p><p>对于不想折腾的朋友到此为止就可以了，恩山网友版的固件足够好用，喜欢折腾的朋友继续看下面（如果发现Wi-Fi无法正常使用的请看<a href="#8-找不到-wi-fi或wi-fi信号很差">最下面</a>）。</p><p>点击左侧的<strong>系统</strong>，然后点击<strong>备份/升级</strong>。现在咱们要升级成 lede 官方版。</p><p>从这里下载官方版：<a href="https://downloads.lede-project.org/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar" target="_blank" rel="noopener">https://downloads.lede-project.org/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar</a></p><p>或者从中科大的镜像里下载：<a href="http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-ramips-mt7621-r6220-squashfs-sysupgrade.tar</a></p><p>在刷写新的固件那一栏，选择刚下载的固件，然后点击刷写固件。</p><p>等 1 分钟后，路由器自动重启，此时官方固件已经刷好了。</p><h2 id="5-配置官方固件"><a href="#5-配置官方固件" class="headerlink" title="5. 配置官方固件"></a>5. 配置官方固件</h2><p>官方固件默认不开启Wi-Fi，默认不安装web管理界面，所以我们需要先使用命令行进行配置。</p><p>使用 <code>ssh root@192.168.1.1</code> 登陆，windows的朋友还使用 putty，但是 port 需填写 22，connection type 选 SSH。</p><p>然后输入 root 回车，再输入 admin 回车。</p><p><img src="/images/6450c2de39907259390b2e4f293b4ec4.png" alt="image_1bnvd5mqeofhlp61sa51q0c11fm2d.png-22.6kB"></p><p>接着会看到一个 LEDE 的 logo，说明登陆成功了，下一步安装web管理界面。</p><blockquote><p>以下内容选作</p></blockquote><p>因为 lede 默认的软件仓库可能会比较慢，所以我们可以换成中科大的源，先执行vim：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/opkg/distfeeds.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p>用 vim 打开 opkg 配置文件，然后多按几次键盘上的 <code>dd</code> 会发现之前的内容被删除了。之后按一下 键盘上的 <code>I</code> ，然后复制下面的内容，在终端里粘贴（putty用户直接在黑窗口里右键就可以了）</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src<span class="regexp">/gz reboot_core http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>targets<span class="regexp">/ramips/</span>mt7621/packages</span><br><span class="line">src<span class="regexp">/gz reboot_base http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>base</span><br><span class="line">src<span class="regexp">/gz reboot_luci http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>luci</span><br><span class="line">src<span class="regexp">/gz reboot_packages http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>packages</span><br><span class="line">src<span class="regexp">/gz reboot_routing http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>routing</span><br><span class="line">src<span class="regexp">/gz reboot_telephony http:/</span><span class="regexp">/mirrors.ustc.edu.cn/</span>lede<span class="regexp">/snapshots/</span>packages<span class="regexp">/mipsel_24kc/</span>telephony</span><br></pre></td></tr></table></figure><p>然后按一下键盘上的 ESC 键，然后依次输入 <code>冒号</code>、<code>w</code>、<code>q</code>、<code>回车键</code>，退出到 shell 界面，现在中科大源就配置好了。</p><blockquote><p>以上内容选作</p></blockquote><p>接下来执行opkg来安装web管理界面，中文翻译和material皮肤：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg <span class="keyword">install </span>luci</span><br><span class="line">opkg <span class="keyword">install </span>luci-i18n-<span class="keyword">base-zh-cn</span></span><br><span class="line"><span class="keyword">opkg </span><span class="keyword">install </span>luci-theme-material</span><br></pre></td></tr></table></figure><p>短暂等待后就安装好了，在浏览器打开 192.168.1.1 就能看到路由器管理界面了。</p><blockquote><p>注意，此处有个小坑，如果在刚才升级到原版系统时，把 <strong>保留配置</strong> 的勾给去掉了，那么此时路由器是无法上网的，也就无法从软件仓库安装，所以如果你和我一样手贱去掉了那个勾，你现在可以把 R6220 接到一个已经配置好能上网的路由器的 LAN 口上，然后再进行 opkg install 操作。</p></blockquote><h2 id="6-安装upnp"><a href="#6-安装upnp" class="headerlink" title="6. 安装upnp"></a>6. 安装upnp</h2><p>官方版固件默认没有 upnp，需要ssh登陆到路由器执行下面命令安装：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">opkg</span> <span class="string">update</span></span><br><span class="line"><span class="attr">opkg</span> <span class="string">install luci-app-upnp</span></span><br></pre></td></tr></table></figure><p>或者也可以在<strong>系统</strong>、<strong>软件包</strong>里安装 <code>luci-app-upnp</code></p><p>然后在 <strong>服务</strong>、<strong>UPNP</strong>里勾选 Start UPnP and NAT-PMP service，点击保存&amp;应用</p><h2 id="7-编译广告屏蔽大师（adbyby）"><a href="#7-编译广告屏蔽大师（adbyby）" class="headerlink" title="7. 编译广告屏蔽大师（adbyby）"></a>7. 编译广告屏蔽大师（adbyby）</h2><p><a href="https://github.com/kuoruan/luci-app-adbyby" target="_blank" rel="noopener">广告屏蔽大师（英文名adbyby）</a>是一个很好用的 lede 应用，能屏蔽爱奇艺、优酷等一系列广告而且不用等待。</p><h3 id="7-1-下载SDK"><a href="#7-1-下载SDK" class="headerlink" title="7.1 下载SDK"></a>7.1 下载SDK</h3><p>中科大源：<a href="http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64.tar.xz" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/lede/snapshots/targets/ramips/mt7621/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64.tar.xz</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//mi</span>rrors.ustc.edu.cn<span class="regexp">/lede/</span>snapshots<span class="regexp">/targets/</span>ramips<span class="regexp">/mt7621/</span>lede-sdk-ramips-mt7621_gcc-<span class="number">5.4</span>.<span class="number">0</span>_musl.Linux-x86_64.tar.xz</span><br><span class="line">tar xvf lede-sdk-ramips-mt7621_gcc-<span class="number">5.4</span>.<span class="number">0</span>_musl.Linux-x86_64.tar.xz</span><br></pre></td></tr></table></figure><h3 id="7-2-下载adbyby"><a href="#7-2-下载adbyby" class="headerlink" title="7.2 下载adbyby"></a>7.2 下载adbyby</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/kuoruan/luci-app-adbyby.git</span><br></pre></td></tr></table></figure><h3 id="7-3-更新feeds"><a href="#7-3-更新feeds" class="headerlink" title="7.3 更新feeds"></a>7.3 更新feeds</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64</span></span><br><span class="line"><span class="string">./scripts/feeds</span> update -a</span><br></pre></td></tr></table></figure><h3 id="7-4-把-adbyby-放进-SDK"><a href="#7-4-把-adbyby-放进-SDK" class="headerlink" title="7.4 把 adbyby 放进 SDK"></a>7.4 把 adbyby 放进 SDK</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/luci-app-adbyby</span></span><br><span class="line">cp <span class="string">./adbyby</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64/package</span> -r</span><br><span class="line">cp <span class="string">./luci-app-adbyby</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64/feeds/luci/applications</span> -r</span><br></pre></td></tr></table></figure><p>把 adbyby 放到 package 里，把 luci-app-adbyby 放到 feeds/luci/applications 里。</p><h3 id="7-5-再更新-feeds"><a href="#7-5-再更新-feeds" class="headerlink" title="7.5 再更新 feeds"></a>7.5 再更新 feeds</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/lede-sdk-ramips-mt7621_gcc-5.4.0_musl.Linux-x86_64</span></span><br><span class="line"><span class="string">./scripts/feeds</span> update -a</span><br><span class="line"><span class="string">./scripts/feeds</span> install luci-app-adbyby</span><br></pre></td></tr></table></figure><h3 id="7-6-编译"><a href="#7-6-编译" class="headerlink" title="7.6 编译"></a>7.6 编译</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">make menuconfig</span></span><br></pre></td></tr></table></figure><p>会打开一个界面，在里面用上下键移动光标，用回车键选择，先选 LuCI，再选 Appications，然后找到 luci-app-adbyby 按两下空格使前面变成 <code>[*]</code> ，然后一直按 ESC 退出，退出前会询问是否保存，选 YES。</p><p>然后执行 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="attribute">V</span>=99</span><br></pre></td></tr></table></figure><p>最后会在 bin 文件夹编译出 luci-app-adbyby.ipk 文件，上传到路由器的/tmp 文件夹，执行 <code>opkg install luci-app-adbyby.ipk</code> 进行安装。</p><h2 id="8-找不到-Wi-Fi，或Wi-Fi信号很差"><a href="#8-找不到-Wi-Fi，或Wi-Fi信号很差" class="headerlink" title="8. 找不到 Wi-Fi，或Wi-Fi信号很差"></a>8. 找不到 Wi-Fi，或Wi-Fi信号很差</h2><p>如果刷了 lede 之后找不到Wi-Fi，可以把 eeprom 还原成原厂。</p><h3 id="8-1-把之前备份的-mtd10-bin-放到路由器中"><a href="#8-1-把之前备份的-mtd10-bin-放到路由器中" class="headerlink" title="8.1 把之前备份的 mtd10.bin 放到路由器中"></a>8.1 把之前备份的 <code>mtd10.bin</code> 放到路由器中</h3><p>在终端里执行：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp mtd10.bin <span class="symbol">root@</span><span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>:/tmp</span><br></pre></td></tr></table></figure><p>使用 windows 的用户可以下载一个 <a href="https://sourceforge.net/projects/winscp/files/WinSCP/5.9.6/WinSCP-5.9.6-Portable.zip/download" target="_blank" rel="noopener">WinScp</a> 来远程复制文件：</p><p>File protocol 选择 scp，hostname输入路由器IP，port写22，username写root，password写密码。</p><p><img src="/images/b2fc85fcbac6955b1c2fc2c68fa01d89.png" alt="image_1bnvf7v6un84c0v11qm1vku1sd37.png-39.8kB"></p><p>点击login，然后再右侧窗口双击一下 <code>..</code> ，然后再双击 tmp 文件夹。然后再左侧窗口找到刚才备份的 mtd10.bin 文件，直接拖到右侧窗口的空白区域。</p><p><img src="/images/38b4a52764c74bf82b95b87032f00a2f.png" alt="image_1bnvfagtt1k5f105kcgr7r132a3k.png-193.8kB"></p><h3 id="8-2-还原-eeprom"><a href="#8-2-还原-eeprom" class="headerlink" title="8.2 还原 eeprom"></a>8.2 还原 eeprom</h3><p>使用 putty 或 ssh 登陆路由器，然后执行下面命令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd -r <span class="keyword">write</span> <span class="regexp">/tmp/m</span>td10.bin factory</span><br></pre></td></tr></table></figure><p>成功后会自动重启。</p><p>然后在<strong>系统</strong>、<strong>备份/升级</strong>里重新上传sysupgrade.tar，并且不勾选<strong>保留设置</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;家里一直用的是网件的 R6220 路由器，之前一直用的是原厂固件，因为本人不太喜欢在主路由器上装奇奇怪怪的东西，另外是因为 R6220 一直都没有好用的固件可以刷，前几天逛论坛发现竟然已经有人破解了 R6220 可以刷 LEDE 和 pandora 了，忍不住手痒又去刷了一波固件。此文记录一下过程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;install lede on netgear r6220&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="openwrt" scheme="https://lengzzz.com/tags/openwrt/"/>
    
      <category term="折腾" scheme="https://lengzzz.com/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="路由器" scheme="https://lengzzz.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
      <category term="lede" scheme="https://lengzzz.com/tags/lede/"/>
    
  </entry>
  
  <entry>
    <title>Caddy - 方便够用的 HTTPS server 新手教程</title>
    <link href="https://lengzzz.com/2017/08/09/Caddy-%E6%96%B9%E4%BE%BF%E5%A4%9F%E7%94%A8%E7%9A%84HTTPSserver%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"/>
    <id>https://lengzzz.com/2017/08/09/Caddy-%E6%96%B9%E4%BE%BF%E5%A4%9F%E7%94%A8%E7%9A%84HTTPSserver%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</id>
    <published>2017-08-09T11:51:49.000Z</published>
    <updated>2020-04-29T15:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>说起 HTTP server，使用最广泛的就是 apache 和 nginx 了，功能都非常强大，但相对而言，学习它们的配置是有一定难度的。最近发现了一个 golang 开发的 HTTP server，叫做 <a href="https://caddyserver.com/" target="_blank" rel="noopener" title="Caddy is the HTTP/2 web server with automatic HTTPS.">Caddy</a>，它配置起来十分简便，甚至可以 <a href="http://www.bilibili.com/video/av4219585/" target="_blank" rel="noopener" title="Caddy - Automatic HTTPS in 28s">28 秒配置好一个支持 http2 的 server </a> ，而且对各种 http 新特性都支持的比较早（比如 http2、quic都有支持）。因此对于不用于生产环境只搭建个人博客是十分友好的，我就简单介绍下 caddy。</p><p><a href="/notename/" title="caddy HTTP/2 web server guide for beginners"></a></p><a id="more"></a><p>[toc]</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>用过 golang 的应该都知道，golang 程序基本上不会有各种依赖，都是光秃秃一个可执行程序，cp 到 <code>/usr/local/bin</code> 就算安装完成了，所以说安装 caddy 是很简单的，我给出三种方法。</p><h3 id="1-1-脚本安装"><a href="#1-1-脚本安装" class="headerlink" title="1.1 脚本安装"></a>1.1 脚本安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://getcaddy.com | bash</span><br></pre></td></tr></table></figure><p>caddy 官方给出了一个安装脚本，执行上面的命令就可以一键安装 caddy，等执行结束后，使用 <code>which caddy</code>，可以看到 caddy 已经被安装到了 /usr/local/bin/caddy</p><h3 id="1-2-手动安装"><a href="#1-2-手动安装" class="headerlink" title="1.2 手动安装"></a>1.2 手动安装</h3><p><a href="https://caddyserver.com/download" target="_blank" rel="noopener">https://caddyserver.com/download</a> 点这个链接进入到 caddy 官网的下载界面，网页左侧可以选择平台和插件，如果在 Linux 服务器上使用的话，platform 选择 Linux 64-bit 就可以了，plugins 如果暂时不需要的话，可以不选。然后点击下面的 DOWNLOAD 按钮，就下载到 caddy 了。同理，解压之后用 cp 命令放到 <code>/usr/local/bin/caddy</code> 就完成了安装。</p><p><img src="/images/f3ac2345c6df862838743d2dd0c02830.png" alt="image_1bn3mbk8jov2es3vu41l842ac9.png-177.7kB"></p><h3 id="1-3-源码安装"><a href="#1-3-源码安装" class="headerlink" title="1.3 源码安装"></a>1.3 源码安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/mholt/caddy/caddy</span><br></pre></td></tr></table></figure><p>对于安装了 golang 编译器的同学，只需要执行 go get 就能到 $GOPATH/bin 里，是否 cp 到 <code>/usr/local/bin</code> 里就看心情了。使用源码安装可以安装到最新版本的 caddy，功能上一般是最新的，而且因为是本地编译，性能可能会稍微高一些，但是可能会存在不稳定的现象。</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-临时文件服务器"><a href="#2-1-临时文件服务器" class="headerlink" title="2.1 临时文件服务器"></a>2.1 临时文件服务器</h3><p>Caddy 的配置文件叫做 <code>Caddyfile</code>，Caddy 不强制你把配置文件放到哪个特定文件夹，默认情况下，把 Caddyfile 放到当前目录就可以跑起来了，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'localhost:8888'</span> &gt;&gt; Caddyfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'gzip'</span> &gt;&gt; Caddyfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'browse'</span> &gt;&gt; Caddyfile</span><br><span class="line">caddy</span><br></pre></td></tr></table></figure><p>在随便一个目录里执行上面代码，然后在浏览器里打开 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> 发现 caddy 已经启动了一个文件服务器。当临时需要一个 fileserver 的时候（比如共享文件），使用 caddy 会很方便。</p><h3 id="2-2-生产环境使用"><a href="#2-2-生产环境使用" class="headerlink" title="2.2 生产环境使用"></a>2.2 生产环境使用</h3><p>当然了，在生产环境使用的时候就不能这么草率的把配置文件放到当前目录了，一般情况下会放到 <code>/etc/caddy</code> 里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/caddy</span><br><span class="line">sudo touch /etc/caddy/Caddyfile</span><br><span class="line">sudo chown -R root:www-data /etc/caddy</span><br></pre></td></tr></table></figure><p>除了配置文件，caddy 会自动生成 ssl 证书，需要一个文件夹放置 ssl 证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/ssl/caddy</span><br><span class="line">sudo chown -R www-data:root /etc/ssl/caddy</span><br><span class="line">sudo chmod 0770 /etc/ssl/caddy</span><br></pre></td></tr></table></figure><p>因为 ssl 文件夹里会放置私钥，所以权限设置成 770 禁止其他用户访问。</p><p>最后，创建一下放置网站文件的目录，如果已经有了，就不需要创建了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/www</span><br><span class="line">sudo chown www-data:www-data /var/www</span><br></pre></td></tr></table></figure><p>创建好这些文件和目录了之后，我们需要把 caddy 配置成一个服务，这样就可以开机自动运行，并且管理起来也方便。因为目前大多数发行版都使用 systemd 了，所以这里只讲一下如何配置 systemd，不过 caddy 也支持配置成原始的 sysvinit 服务，具体方法<a href="https://github.com/mholt/caddy/tree/master/dist/init/linux-sysvinit" target="_blank" rel="noopener" title="SysVinit conf for Caddy">看这里</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service   <span class="comment"># 从 github 下载 systemd 配置文件</span></span><br><span class="line">sudo systemctl daemon-reload        <span class="comment"># 重新加载 systemd 配置</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> caddy.service <span class="comment"># 设置 caddy 服务自启动</span></span><br><span class="line">sudo systemctl status caddy.service <span class="comment"># 查看 caddy 状态</span></span><br></pre></td></tr></table></figure><h2 id="3-Caddyfile"><a href="#3-Caddyfile" class="headerlink" title="3. Caddyfile"></a>3. Caddyfile</h2><p>基本的安装配置搞定之后，最重要的就是如何写 Caddyfile了。可以直接 <code>vim /etc/caddy/Caddyfile</code> 来修改 Caddyfile，也可以再自己电脑上改好然后 rsync 到服务器上。如果修改了 Caddyfile 发现没有生效，是需要执行一下 <code>sudo systemctl restart caddy.service</code> 来重启 caddy 的。</p><h3 id="3-1-Caddyfile-的格式"><a href="#3-1-Caddyfile-的格式" class="headerlink" title="3.1 Caddyfile 的格式"></a>3.1 Caddyfile 的格式</h3><p>Caddfile的格式还是比较简单的，首先第一行必须是网站的地址，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:8080</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lengzzz.com</span><br></pre></td></tr></table></figure><p>地址可以带一个端口号，那么 caddy 只会在这个端口上开启 http 服务，而不会开启 https，如果不写端口号的话，caddy 会默认绑定 80 和 443 端口，同时启动 http 和 https 服务。</p><p>地址后面可以再跟一大堆指令（directive）。Caddyfile 的基本格式就是这样，由一个网站地址和指令组成，是不是很简单。</p><h3 id="3-2-指令"><a href="#3-2-指令" class="headerlink" title="3.2 指令"></a>3.2 指令</h3><p>指令的作用是为网站开启某些功能。指令的格式有三种，先说一下最简单的不带参数的指令比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe     # 没错，moe后缀的域名也可以哦</span><br><span class="line">gzip</span><br></pre></td></tr></table></figure><p>第二行的 gzip 就是一个指令，它表示打开 gzip 压缩功能，这样网站在传输网页是可以降低流量。</p><p>第二种指令的格式是带简单参数的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe</span><br><span class="line">gzip</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;access.log</span><br><span class="line">tls lengz@lengzzz.com</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure><p>第三行，log 指令会为网站开启 log 功能，log 指令后的参数告诉 caddy log 文件存放的位置。第四行的 tls 指令告诉 caddy 为网站开启 https 并自动申请证书，后面的 email 参数是告知 CA 申请人的邮箱。（caddy 会默认使用 let’s encrypt 申请证书并续约，很方便吧）</p><p>另外，简单参数也可能不只一个，比如 redir 指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe</span><br><span class="line">gzip</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;access.log</span><br><span class="line">tls &#x2F;etc&#x2F;ssl&#x2F;cert.pem &#x2F;etc&#x2F;ssl&#x2F;key.pem</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">redir &#x2F; https:&#x2F;&#x2F;lengzzz.com&#x2F;archive&#x2F;&#123;uri&#125; 301</span><br></pre></td></tr></table></figure><p>上面的 redir 指令带了三个参数，意思是把所有的请求使用 301 重定向到 <a href="https://lengzzz.com/archive/xxx，这个指令在给网站换域名的时候很有用。另外">https://lengzzz.com/archive/xxx，这个指令在给网站换域名的时候很有用。另外</a> tls 指令变了，不单单传 email一个参数， 而是分别传了证书和私钥的路径，这样的话 caddy 就不会去自动申请证书，而是使用路径给出的证书了。</p><p>在这个例子里还使用了 <code>{uri}</code> 这样的占位符（placeholder），详细的列表可以在这里查询到：<a href="https://caddyserver.com/docs/placeholders。" target="_blank" rel="noopener">https://caddyserver.com/docs/placeholders。</a></p><p>最后一种指令是带复杂参数的，这种指令包含可能很多参数，所以需要用一对花括号包起来，比如 header 指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe</span><br><span class="line">gzip</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;access.log</span><br><span class="line">tls lengz@lengzzz.com</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">header &#x2F;api &#123;</span><br><span class="line">    Access-Control-Allow-Origin  *</span><br><span class="line">    Access-Control-Allow-Methods &quot;GET, POST, OPTIONS&quot;</span><br><span class="line">    -Server</span><br><span class="line">&#125;</span><br><span class="line">fastcgi &#x2F; 127.0.0.1:9000 php &#123;</span><br><span class="line">    index index.php</span><br><span class="line">&#125;</span><br><span class="line">rewrite &#123;</span><br><span class="line">    to &#123;path&#125; &#123;path&#125;&#x2F; &#x2F;index.php?&#123;query&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6-10 行的 header 指令代表为所有的 <code>/api/xxx</code> 的请求加上 <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Methods</code> 这两个 header，从而能支持 javascript <a href="https://lengzzz.com/note/cross-origin-http-request" title="跨源 HTTP 请求（CORS）">跨域访问</a> ，第 9 行代表删除 Server header，防止别人看到服务器类型。</p><p>11-13 行使用了 fastcgi 指令，代表把请求通过 fastcgi 传给 php，ruby 等后端程序。</p><p>14-15 行，使用了 rewrite 指令，这个指令的作用是 <strong>服务器内部重定向</strong> 在下面的参数 <code>to</code> 后面，又跟了三个参数，这个功能上有点类似 nginx 的 <code>try_files</code> 。告诉 caddy 需要先查看网址根目录 /var/www 里有没有 {path} 对应的文件，如果没有再查看有没有 {path} 对应的目录，如果都没有，则转发给 index.php 入口文件。这个功能一般会用在 PHP 的 MVC 框架上使用。</p><p>随着一步步完善这个 Caddyfile，目前这个版本的 Caddyfaile 已经可以直接在网站中使用了。</p><h3 id="3-3-多-HOST-网站"><a href="#3-3-多-HOST-网站" class="headerlink" title="3.3 多 HOST 网站"></a>3.3 多 HOST 网站</h3><p>刚才说的一直都是单个域名的网址，那么如果在同一个服务器上部署多个域名的网站呢？很简单，只需要在域名后面跟一个花括号扩起来就可以了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">railgun.moe &#123;</span><br><span class="line">    gzip</span><br><span class="line">    log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;railgun_moe.log</span><br><span class="line">    tls lengz@lengzzz.com</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">    header &#x2F;api &#123;</span><br><span class="line">        Access-Control-Allow-Origin  *</span><br><span class="line">        Access-Control-Allow-Methods &quot;GET, POST, OPTIONS&quot;</span><br><span class="line">        -Server</span><br><span class="line">    &#125;</span><br><span class="line">    fastcgi &#x2F; 127.0.0.1:9000 php &#123;</span><br><span class="line">        index index.php</span><br><span class="line">    &#125;</span><br><span class="line">    rewrite &#123;</span><br><span class="line">        to &#123;path&#125; &#123;path&#125;&#x2F; &#x2F;index.php?&#123;query&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">lengzzz.com &#123;</span><br><span class="line">tls lengz@lengzzz.com</span><br><span class="line">log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;lengzzz_com.log</span><br><span class="line">    redir &#x2F; https:&#x2F;&#x2F;railgun.moe&#x2F;&#123;uri&#125; 301</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，基本的 caddy 配置就这些，详细的内容可以去官网上看文档学习。</p><p><a href="https://caddyserver.com/docs" target="_blank" rel="noopener">https://caddyserver.com/docs</a></p><p>[EOF]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起 HTTP server，使用最广泛的就是 apache 和 nginx 了，功能都非常强大，但相对而言，学习它们的配置是有一定难度的。最近发现了一个 golang 开发的 HTTP server，叫做 &lt;a href=&quot;https://caddyserver.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Caddy is the HTTP/2 web server with automatic HTTPS.&quot;&gt;Caddy&lt;/a&gt;，它配置起来十分简便，甚至可以 &lt;a href=&quot;http://www.bilibili.com/video/av4219585/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Caddy - Automatic HTTPS in 28s&quot;&gt;28 秒配置好一个支持 http2 的 server &lt;/a&gt; ，而且对各种 http 新特性都支持的比较早（比如 http2、quic都有支持）。因此对于不用于生产环境只搭建个人博客是十分友好的，我就简单介绍下 caddy。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;caddy HTTP/2 web server guide for beginners&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="运维" scheme="https://lengzzz.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="caddy" scheme="https://lengzzz.com/tags/caddy/"/>
    
      <category term="http" scheme="https://lengzzz.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>移植 LuaCoco</title>
    <link href="https://lengzzz.com/2017/05/30/%E7%A7%BB%E6%A4%8DLuaCoco/"/>
    <id>https://lengzzz.com/2017/05/30/%E7%A7%BB%E6%A4%8DLuaCoco/</id>
    <published>2017-05-30T04:13:43.000Z</published>
    <updated>2017-07-13T09:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>lua 语言最大的卖点之一就是他的协程（coroutine）了。但是在 lua5.1 中有一个文档都没提到的一个坑：协程<strong>只能</strong>在 lua 中使用，当调用 yield 时，如果当前的调用栈上有 c 代码，则会报错 <strong>“attempt to yield across metamethod/C-call boundary”</strong>。目前有个第三方的 patch 叫做 <a href="http://coco.luajit.org/" target="_blank" rel="noopener" title="Coco — True C Coroutines for Lua">luaCoco</a> 可以让 lua 支持 “真协程”。本文研究了 luaCoco 的内部实现，并把它移植到了 <a href="https://en.wikipedia.org/wiki/Tensilica" target="_blank" rel="noopener">xtensa</a> 处理器上。</p><p><a href="/notename/" title="porting luaCoco"></a></p><p><img src="/images/7101caf8fc0075b8d52d5a15ad9f6cb9.png" alt="image_1bhbpomnrk0m58270a54k789.png-16.9kB"></p><a id="more"></a><p>[toc]</p><h2 id="setjmp-的实现"><a href="#setjmp-的实现" class="headerlink" title="setjmp 的实现"></a>setjmp 的实现</h2><p>在文章的开头需要先讲解一下c语言标准库中 <a href="http://www.cplusplus.com/reference/csetjmp/" target="_blank" rel="noopener">setjmp</a> 的内部实现，因为之后的 luaCoco 的实现就是对 setjmp 的数据结构的一个 hack。</p><p>先看看 setjmp 的用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jmp_buf buf;</span><br><span class="line">    <span class="keyword">int</span> code = setjmp(buf);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before jmp\n"</span>);</span><br><span class="line">        longjmp(buf, <span class="number">1024</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"jmp here, code: %d\n"</span>, code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 setjmp 的时候，会返回 0，从而会执行 <code>if (code == 0) {</code> 为 true 的 block，会打印出 <code>before jmp</code>。当执行了 longjmp 之后，程序的执行会重新跳转到 setjmp 那一行（第七行）然而这次 setjmp 的返回值 code 不再是 0，而是 longjmp 的第二个参数（1024），这样就会打印出 <code>jmp here, code: 1024</code>。</p><p>利用 setjmp 的这个功能能实现出很多有趣的东西，比如在c语言中做 <code>Exception</code>，但是 setjmp 是怎么实现的呢？我们去读一读源码。</p><p>libc 的实现有好多种，常见的比如 glibc、uclibc 和 musl-libc，但是我们这次读一读 newlib 的源码。newlib 也是一个 libc 的实现，常用于嵌入式开发中。</p><p>打开 inlcude/machine/setjmp-dj.h 文件，可以看到 jmp_buf 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from inlcude/machine/setjmp-dj.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">&#125; jmp_buf[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>发现这个结构体是用来存储 cpu 的寄存器的。这里很好理解，因为要实现 长跳转（longjmp），必须要首先把跳转的目的地的<strong>现场</strong>先保存下来。</p><p>setjmp 函数做的工作就是保存现场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; from machine&#x2F;i386&#x2F;setjmp.S</span><br><span class="line"> &#x2F;*</span><br><span class="line"> **jmp_buf:</span><br><span class="line"> ** eax ebx ecx edx esi edi ebp esp eip</span><br><span class="line"> ** 0   4   8   12  16  20  24  28  32</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">       #include &quot;i386mach.h&quot;</span><br><span class="line"></span><br><span class="line">        .global SYM (setjmp)</span><br><span class="line">        .global SYM (longjmp)</span><br><span class="line">       SOTYPE_FUNCTION(setjmp)</span><br><span class="line">       SOTYPE_FUNCTION(longjmp)</span><br><span class="line"> </span><br><span class="line">SYM (setjmp):</span><br><span class="line"></span><br><span class="line">pushlebp</span><br><span class="line">movlesp,ebp</span><br><span class="line"></span><br><span class="line">pushledi</span><br><span class="line">movl8 (ebp),edi</span><br><span class="line"></span><br><span class="line">movleax,0 (edi)</span><br><span class="line">movlebx,4 (edi)</span><br><span class="line">movlecx,8 (edi)</span><br><span class="line">movledx,12 (edi)</span><br><span class="line">movlesi,16 (edi)</span><br><span class="line"></span><br><span class="line">movl-4 (ebp),eax</span><br><span class="line">movleax,20 (edi)    &#x2F;&#x2F; edi</span><br><span class="line"></span><br><span class="line">movl0 (ebp),eax</span><br><span class="line">movleax,24 (edi)    &#x2F;&#x2F; ebp</span><br><span class="line"></span><br><span class="line">movlesp,eax</span><br><span class="line">addl$12,eax</span><br><span class="line">movleax,28 (edi)    &#x2F;&#x2F; esp</span><br><span class="line"></span><br><span class="line">movl4 (ebp),eax</span><br><span class="line">movleax,32 (edi)    &#x2F;&#x2F; eip (PC)</span><br><span class="line"></span><br><span class="line">popledi</span><br><span class="line">movl$0,eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><center>![FullSizeRender 2.jpg-1881.4kB][2]<small>setjmp 的栈帧</small></center><p>看图解释一下代码： </p><ul><li>17 行：push ebp 到栈上（esp 同时下移 4 字节）</li><li>18 行：ebp 指向 esp</li><li>20 行：push edi 到栈上（esp 同时再下移 4 字节）</li><li>21 行：8(ebp) 保存的是 jmp_buf 的指针，先把它放到 edi 中</li><li>23 - 27 行：分别把 eax、ebx、ecx、edx、esi 保存到 jmp_buf 里</li><li>29 - 30 行：-4 (ebp) 是edi，如图</li><li>32 - 33 行：(ebp) 就是之前的ebp，如图</li><li>35 - 37 行：保存 esp</li><li>39 - 40 行：如图，保存 <code>return addr</code> 到 jmp_buf-&gt;eip</li></ul><p>longjmp 的实现是正好相反的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SYM (longjmp):</span><br><span class="line">pushlebp</span><br><span class="line">movlesp,ebp</span><br><span class="line"></span><br><span class="line">movl8(ebp),edi&#x2F;* get jmp_buf *&#x2F;</span><br><span class="line">movl12(ebp),eax&#x2F;* store retval in j-&gt;eax *&#x2F;</span><br><span class="line">testleax,eax</span><br><span class="line">jne0f</span><br><span class="line">incleax</span><br><span class="line">0:</span><br><span class="line">movleax,0(edi)</span><br><span class="line"></span><br><span class="line">movl24(edi),ebp</span><br><span class="line"></span><br><span class="line">       __CLI</span><br><span class="line">movl28(edi),esp</span><br><span class="line"></span><br><span class="line">pushl32(edi)</span><br><span class="line"></span><br><span class="line">movl0(edi),eax</span><br><span class="line">movl4(edi),ebx</span><br><span class="line">movl8(edi),ecx</span><br><span class="line">movl12(edi),edx</span><br><span class="line">movl16(edi),esi</span><br><span class="line">movl20(edi),edi</span><br><span class="line">       __STI</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>代码就不赘述了，基本上就是恢复<strong>现场</strong>、把longjmp的第二个参数作为返回值返回（7 - 9 行还有一个判断：如果参数为0的话，会把它改成 1）。</p><h2 id="LuaCoco-的实现"><a href="#LuaCoco-的实现" class="headerlink" title="LuaCoco 的实现"></a>LuaCoco 的实现</h2><p>首先在看代码之前，先简单讲解一下我对 LuaCoco 的理解。lua 的协程其实也就是为每个协程维护了一个 context（所谓 context，既程序执行到某个地方时的状态，包括寄存器、callstack）。当协程之前相互 yield 的时候，切换一下 context。但是 lua 没做好的地方是 lua 仅保存了 lua 程序的 context，而 c 代码的 context 是没有保存的。这是因为 lua 很追求使用 pure c，不希望在源码中加入过多平台相关的东西。保存 lua 的 context 是比较简单的，因为所有 lua 程序相关的数据结构都放在 lua 虚拟机里，只需要每个 coroutine 保存一份就好了，而取得／保存 c 代码的上下文是需要操作平台相关的寄存器的。LuaCoco 就是为每个常见的平台都做了一份保存 c 程序 context 的实现。</p><p>下面看 LuaCoco 的源码。</p><p>LuaCoco 是对 lua 源码的一个 patch，coco 改动了 lua 的以下文件：</p><p><img src="/images/d6fcc3dbe149d5f6cdc4eeb0fba867b1.png" alt="image_1bhcc3die5r3c7tg95ab069b1e.png-22.7kB"></p><p>最主要的文件就是 lcoco.c 和 lcoco.h 了：</p><p>我看源码一般喜欢先看一下 header 文件，瞄一眼 coco 大体上做了什么事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from lcoco.h</span></span><br><span class="line"><span class="comment">/* Exported C API to add a C stack to a coroutine. */</span></span><br><span class="line"><span class="function">LUA_API lua_State *<span class="title">lua_newcthread</span><span class="params">(lua_State *L, <span class="keyword">int</span> cstacksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal support routines. */</span></span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">void</span> <span class="title">luaCOCO_free</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_resume</span><span class="params">(lua_State *L, <span class="keyword">int</span> nargs)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_yield</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUAI_FUNC <span class="keyword">int</span> <span class="title">luaCOCO_cstacksize</span><span class="params">(<span class="keyword">int</span> cstacksize)</span></span>;</span><br></pre></td></tr></table></figure><p>lcoco.h 里声明了 coco 定义的 4 个函数。很明显，lua_newcthread 是为了取代原生 lua 中的 lua_newthread 函数的。这一点可以在 lbaselib.c 文件的改动中看到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from lbaselib.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">luaB_cocreate</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COCO_DISABLE</span></span><br><span class="line">  lua_State *NL = lua_newthread(L);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp; !lua_iscfunction(L, <span class="number">1</span>), </span><br><span class="line">    <span class="number">1</span>, <span class="string">"Lua function expected"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> cstacksize = luaL_optint(L, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  lua_State *NL = lua_newcthread(L, cstacksize);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                   (cstacksize &gt;= <span class="number">0</span> ? <span class="number">1</span> : !lua_iscfunction(L, <span class="number">1</span>)),</span><br><span class="line">                <span class="number">1</span>, <span class="string">"Lua function expected"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  lua_pushvalue(L, <span class="number">1</span>);  <span class="comment">/* move function to top */</span></span><br><span class="line">  lua_xmove(L, NL, <span class="number">1</span>);  <span class="comment">/* move function from L to NL */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用宏判断了是否开启 coco，如果开启的话就使用新的 lua_newcthread，否则的话还使用原生的 lua_newthread。</p><p>那么，下一步就着重来看看 lua_newcthread 的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a C stack to a coroutine. */</span></span><br><span class="line"><span class="function">lua_State *<span class="title">lua_newcthread</span><span class="params">(lua_State *OL, <span class="keyword">int</span> cstacksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lua_State *NL = lua_newthread(OL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cstacksize &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> NL;</span><br><span class="line">  <span class="keyword">if</span> (cstacksize == <span class="number">0</span>)</span><br><span class="line">    cstacksize = defaultcstacksize;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cstacksize &lt; COCO_MIN_CSTACKSIZE)</span><br><span class="line">    cstacksize = COCO_MIN_CSTACKSIZE;</span><br><span class="line">  cstacksize &amp;= <span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line">  COCO_NEW(OL, NL, cstacksize, ((coco_MainFunc)(coco_main)))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看函数签名，发现比原生的 newthread 多了一个 cstacksize 参数，因为现在需要为 c 程序保存上下文，c 程序的执行需要一个 stack，所以每个 coroutine 都要有一个自己的 stack。这个 cstacksize 参数就是用来控制这个 stack 的大小的。</p><p>继续看代码，几个 if 的意思也很清晰，不表。发现重要的功能都封装到了 <code>COCO_NEW</code> 这个宏里面了。再一翻代码，这个宏又套了好几层宏和宏判断，搞得我很郁闷。所以我就使出了我的编译器大法！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -DCOCO_USE_SETJMP -D__linux__ -D_I386_JMP_BUF_H -D__i386 lcoco.c &gt; _lcoco.c</span><br></pre></td></tr></table></figure><p>这个命令可以让编译器只执行预处理，说白了就是把 c 语言的宏全部展开。命令中定义的其他几个宏的意思分别是：使用 setjmp 实现协程、使用Linux架构、使用i386架构。</p><p>宏展开的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lua_State* <span class="title">lua_newcthread</span><span class="params">(lua_State* OL, <span class="keyword">int</span> cstacksize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ... if check</span></span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = luaM_realloc_(OL, <span class="literal">NULL</span>, <span class="number">0</span>, (cstacksize));</span><br><span class="line">    coco_State* coco = ((coco_State* )(((<span class="keyword">char</span>* ) <span class="number">0</span>) + ((((<span class="keyword">char</span>* )(ptr) - (<span class="keyword">char</span>* ) <span class="number">0</span>) + (cstacksize) - <span class="keyword">sizeof</span>(coco_State)) &amp; <span class="number">-16</span>)));</span><br><span class="line">    coco-&gt;allocptr = ptr;</span><br><span class="line">    coco-&gt;allocsize = cstacksize; &#123;</span><br><span class="line">      <span class="keyword">size_t</span>* stackptr = &amp; ((<span class="keyword">size_t</span>*) coco)[<span class="number">-1</span>];</span><br><span class="line">      _setjmp(coco-&gt;ctx);</span><br><span class="line">      coco-&gt;ctx-&gt;__pc = (((coco_MainFunc)(coco_main)));</span><br><span class="line">      coco-&gt;ctx-&gt;__sp = (stackptr);</span><br><span class="line">      coco-&gt;ctx-&gt;__bp = <span class="literal">NULL</span>;</span><br><span class="line">      stackptr[<span class="number">1</span> - <span class="number">1</span>] = <span class="number">0xdeadc0c0</span>;</span><br><span class="line">      coco-&gt;arg0 = (<span class="keyword">size_t</span>)(NL);</span><br><span class="line">    &#125;(((coco_State**)(NL))[<span class="number">-1</span>]) = coco;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主要做的事情就是 alloc 了 coco_State 数据结构和 cstack。这里只申请了一次内存空间，然后通过指针操作分别把内存分成了 coco_State 和 cstack 两块。有点迷糊的可以看一下我画的图：</p><p><img src="/images/54aa11f5b1b9229bb14b4a0b83ea4a0d.jpeg" alt="WechatIMG23.jpeg-99.9kB"></p><p>申请好空间之后，11到16行初始化了 coco_State 的几个字段。</p><p>17行把 coco 的指针放到了 NL 的前面（我并不知道为什么可以这么做，反正就是可以，看的时候我一脸“还有这种操作？”的黑人问号）</p><center>![IMG_0002.JPG-49.3kB][5]</center><p>下面我们去看看 coco_State 的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coco_State</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> arg0;</span><br><span class="line">  jmp_buf ctx;</span><br><span class="line">  jmp_buf back;</span><br><span class="line">  <span class="keyword">void</span>* allocptr;</span><br><span class="line">  <span class="keyword">int</span> allocsize;</span><br><span class="line">  <span class="keyword">int</span> nargs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过宏替换之后，coco_State 长上面这样。</p><p>lua_newcthread里的代码初始化了 ctx，allocptr，allocsize，arg0 字段。其中，对 ctx 的初始化操作比较让人在意，首先是调用 setjmp 初始化了 ctx，之后对 ctx 内部的几个字段进行了魔改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coco-&gt;ctx-&gt;__pc = (((coco_MainFunc)(coco_main)));</span><br><span class="line">coco-&gt;ctx-&gt;__sp = (stackptr);</span><br><span class="line">coco-&gt;ctx-&gt;__bp = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>有了之前 setjmp 的基础，这里就容易理解了，一旦对这个 ctx 调用 longjmp 的话，<strong>程序就会跳转到 <code>coco_main</code> 这个函数，并且把 stackptr 当作程序的 stack 来使用。这个 stack 的切换操作，其实就是程序 context 的切换</strong></p><p>我们先不看 <code>coco_main</code> 做了什么，先看看这个 longjmp 会在什么时候调用，动脑子想一想，应该会是再执行 resume 的时候调用 longjmp，果然不出所料：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaCOCO_resume</span><span class="params">(lua_State* L, <span class="keyword">int</span> nargs)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  coco-&gt;nargs = nargs;</span><br><span class="line">  <span class="keyword">if</span> (!_setjmp(coco-&gt;back)) _longjmp(coco-&gt;ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L-&gt;status != <span class="number">1</span>) &#123;</span><br><span class="line">    luaM_realloc_(L, ((((coco_State**)(L))[<span class="number">-1</span>])-&gt;allocptr), ((((coco_State**)(L))[<span class="number">-1</span>])-&gt;allocsize), <span class="number">0</span>);</span><br><span class="line">    (((coco_State**)(L))[<span class="number">-1</span>]) = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> L-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 resume 的时候，首先使用 setjmp 把主线程的状态保存到 <code>coco-&gt;back</code> 里，然后调转到 <code>coco_main</code>。</p><p>下面看 <code>coco_main</code> 做了什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coco_main</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    L-&gt;status = luaD_rawrunprotected(L, coco_start, L-&gt;top - (coco-&gt;nargs + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;status != <span class="number">0</span>) luaD_seterrorobj(L, L-&gt;status, L-&gt;top);</span><br><span class="line">    <span class="keyword">if</span> (!_setjmp(coco-&gt;ctx)) _longjmp(coco-&gt;back, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 首先通过L取到了coco的指针（又一次黑人问号）。然后通过 luaD_rawrunprotected 调用了 lua 程序（也就是lua子线程）。之后判断子线程时候出错，设置错误码。最后，保存子线程的状态到 ctx，然后跳转会 back（调转到了luaCOCO_resume 第6行）。</p><p>继续回来看 luaCOCO_resume 函数，第 6 行后面宏展开前其实是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L-&gt;status != LUA_YIELD) &#123;</span><br><span class="line">  COCO_FREE(L)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开前的代码比较容易懂：如果子线程执行完了，就 free 掉，没啥可说的。</p><p>最后看看 yield：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaCOCO_yield</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">  coco_State* coco = (((coco_State**)(L))[<span class="number">-1</span>]);</span><br><span class="line">  L-&gt;status = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!_setjmp(coco-&gt;ctx)) _longjmp(coco-&gt;back, <span class="number">1</span>);</span><br><span class="line">  L-&gt;status = <span class="number">0</span>; &#123;</span><br><span class="line">    StkId base = L-&gt;top - coco-&gt;nargs;</span><br><span class="line">    StkId rbase = L-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (rbase &lt; base) &#123;</span><br><span class="line">      <span class="keyword">while</span> (base &lt; L-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">const</span> TValue* o2 = (base++);</span><br><span class="line">        TValue* o1 = (rbase++);</span><br><span class="line">        o1-&gt;value = o2-&gt;value;</span><br><span class="line">        o1-&gt;tt = o2-&gt;tt;</span><br><span class="line">        ((<span class="keyword">void</span>) <span class="number">0</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      L-&gt;top = rbase;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;base = L-&gt;ci-&gt;base;</span><br><span class="line">  <span class="keyword">return</span> coco-&gt;nargs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转那里和之前讲的一样，多了的东西没太明白，好像是在复制 lua_State 内部的数据。</p><p>LuaCoco 内部实现的内容基本上就这些了。</p><p>题外话：其实除了魔改 setjmp，LuaCoco还有三种实现，直接内连汇编、使用ucontext和使用fiber，大家可以通过执行 <code>gcc -E lcoco.c &gt; _lcoco.c</code> 加不同的宏定义来生成代码自行研究（其实原理都差不多）。</p><h2 id="xtensa-架构-ABI"><a href="#xtensa-架构-ABI" class="headerlink" title="xtensa 架构 ABI"></a>xtensa 架构 ABI</h2><p>这部分就简单讲一下带过了，毕竟不是那么通用的内容。</p><p>经常做移植的同学应该大多知道，移植的时候最重要的是需要了解这个 architecture 的 ABI（application binary interface）。Google 一番之后发现了<a href="http://0x04.net/~mwk/doc/xtensa.pdf" target="_blank" rel="noopener" title="Xtensa® Instruction Set Architecture (ISA)">这个pdf</a>，不过先不急着看 ABI，先看一下这个 CPU 的寄存器吧。</p><p>xtensa 有 16 个 32 位的通用寄存器，名字分别叫 A0 ～ A15，一个 PC 程序计数器，再加上一个 SAR 寄存器（不知道干嘛用的，不过好像移植的话用不上），还算挺简单的设计，没有奇奇怪怪的东西。</p><p>接下来，再看看 xtensa 的 ABI，在 PDF 的 chapter 8 里找到了 关于 Xtensa ABI 的部分。xtensa 使用了两种ABI，一种叫 <code>Windowed Register</code> 另一种叫 <code>CALL0</code> 。NodeMCU 只会用到 CALL0 所以我们简单讲一下 CALL0。</p><p>先看表格：</p><p>| Register        | Use   |<br>|    |   |<br>| a0 | Return Address |<br>| a1 (sp) | Stack Pointer (callee-saved) |<br>| a2 – a7 | Function Arguments |<br>| a8 | Static Chain (see Section 8.1.8) |<br>| a12 – a15 | Callee-saved |<br>| a15 | Stack-Frame Pointer (optional) |</p><p>A0 保存了函数的返回地址，A1保存了栈指针，a2到a7一共6个寄存器用于传递函数的参数，更多的参数会在栈中传递，a12-a15需要被调用者自己保存。</p><p>看完了寄存器的使用，看一下 xtensa 的栈帧（stack frame）格式：</p><p><img src="/images/94e476dfa01186c4655281e79aedcfa1.png" alt="image_1bktgc5jiv8p1bqh1ot5pcf1v0i9.png-37.6kB"></p><p>可以看出来，xtensa 的指针也是向低地址方向增长的。在 SP 的上面会保存依次 <code>6个参数以外的参数</code> 、<code>局部变量</code> 等</p><h2 id="移植-LuaCoco"><a href="#移植-LuaCoco" class="headerlink" title="移植 LuaCoco"></a>移植 LuaCoco</h2><p>搞清楚 ABI 了，最后的工作就是 coding 了。</p><p>遇到的第一个问题是，因为我们要对 setjmp 进行 hack，而不是使用汇编，所以我们仅能操作内存，而不能操作寄存器，所以如何将 lua_State 传递给 coco_main 呢？最常见的方法就是使用 哑参数（dummy args）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COCO_MAIN_PARAMint _a, int _b, int _c, int _d, int _e, int _f, lua_State *L</span></span><br></pre></td></tr></table></figure><p>我们把 coco_main 的参数列表定义成这样，前面a到f的参数都是用不上的，这样就不用管 a2 到 a7 这几个寄存器了。所以我们只需要把L指针放到SP指的位置就好了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">COCO_PATCHCTX(<span class="params">coco</span>, <span class="params">buf</span>, <span class="params">func</span>, <span class="params">stack</span>, <span class="params">a0</span>)</span> \</span><br><span class="line">  buf<span class="literal">[<span class="number">0</span>]</span> = (<span class="built_in">int</span>)(func); \</span><br><span class="line">  buf<span class="literal">[<span class="number">1</span>]</span> = (<span class="built_in">int</span>)(stack); \</span><br><span class="line">  stack<span class="literal">[<span class="number">0</span>]</span> = (size_t)(a0);</span><br></pre></td></tr></table></figure><p><code>stack[0] = (size_t)(a0);</code> 这一句中的 a0 就是 lua_State 的指针，把他放到了 SP[0] 这里。</p><p>第二个问题就是对 <code>jmp_buf</code> 进行 hack 了，我们需要搞明白 <code>jmp_buf</code> 里怎么放东西的，这需要看这个平台编译器的源码了。<a href="https://github.com/pfalcon/esp-open-sdk" target="_blank" rel="noopener">https://github.com/pfalcon/esp-open-sdk</a> 这里是编译器的源代码，他是使用 crosstool 的，会一边下载源代码，一遍编译，下载好的源代码放在 crosstool-NG/.build/src/newlib-2.0.0 ，正好我们看看 newlib 中 setjmp 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#else &#x2F;* CALL0 ABI *&#x2F;</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.align4</span><br><span class="line">.literal_position</span><br><span class="line">.globalsetjmp</span><br><span class="line">.typesetjmp, @function</span><br><span class="line">setjmp:</span><br><span class="line">s32ia0, a2, 0</span><br><span class="line">s32ia1, a2, 4</span><br><span class="line">s32ia12, a2, 8</span><br><span class="line">s32ia13, a2, 12</span><br><span class="line">s32ia14, a2, 16</span><br><span class="line">s32ia15, a2, 20</span><br><span class="line">movia2, 0</span><br><span class="line">ret</span><br><span class="line">.sizesetjmp, . - setjmp</span><br><span class="line"></span><br><span class="line">.align4</span><br><span class="line">.literal_position</span><br><span class="line">.globallongjmp</span><br><span class="line">.typelongjmp, @function</span><br><span class="line">longjmp:</span><br><span class="line">l32ia0, a2, 0</span><br><span class="line">l32ia12, a2, 8</span><br><span class="line">l32ia13, a2, 12</span><br><span class="line">l32ia14, a2, 16</span><br><span class="line">l32ia15, a2, 20</span><br><span class="line">l32ia1, a2, 4</span><br><span class="line">&#x2F;* Return val ? val : 1.  *&#x2F;</span><br><span class="line">movia2, 1</span><br><span class="line">movneza2, a3, a3</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">.sizelongjmp, .-longjmp</span><br><span class="line"></span><br><span class="line">#endif &#x2F;* CALL0 ABI *&#x2F;</span><br></pre></td></tr></table></figure><p>上面的 else 宏代表这段代码是使用 CALL0 ABI 才会被编译。看一下代码，可以了解到以下对应关系：</p><p>| jmp_buf | Register | Use |<br>|  |  |<br>| jup_buf[0] | a0 | Return Address |<br>| jmp_buf[1] | a1 | Stack Pointer (callee-saved) |<br>| jmp_buf[2] - jmp_buf[5] | a12 - a15 | Callee-saved |</p><p>所以这段代码也就不难理解了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">COCO_PATCHCTX(<span class="params">coco</span>, <span class="params">buf</span>, <span class="params">func</span>, <span class="params">stack</span>, <span class="params">a0</span>)</span> \</span><br><span class="line">  buf<span class="literal">[<span class="number">0</span>]</span> = (<span class="built_in">int</span>)(func); \</span><br><span class="line">  buf<span class="literal">[<span class="number">1</span>]</span> = (<span class="built_in">int</span>)(stack); \</span><br><span class="line">  stack<span class="literal">[<span class="number">0</span>]</span> = (size_t)(a0);</span><br></pre></td></tr></table></figure><p>分别是把 <code>buf[0]</code> 和 <code>buf[1]</code> 改成 coco_main 和 我们为协程新申请的栈。</p><p>其他代码基本上是 copy coco 的，详细的可以看我 github：</p><p><a href="https://github.com/zwh8800/nodemcu-firmware/commit/1f31aa32901f07b6414c0471eb19f7bdd44d93a6" target="_blank" rel="noopener">https://github.com/zwh8800/nodemcu-firmware/commit/1f31aa32901f07b6414c0471eb19f7bdd44d93a6</a> </p><p>[EOF] 基本上这次移植涉及到的内容就这些，完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lua 语言最大的卖点之一就是他的协程（coroutine）了。但是在 lua5.1 中有一个文档都没提到的一个坑：协程&lt;strong&gt;只能&lt;/strong&gt;在 lua 中使用，当调用 yield 时，如果当前的调用栈上有 c 代码，则会报错 &lt;strong&gt;“attempt to yield across metamethod/C-call boundary”&lt;/strong&gt;。目前有个第三方的 patch 叫做 &lt;a href=&quot;http://coco.luajit.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Coco — True C Coroutines for Lua&quot;&gt;luaCoco&lt;/a&gt; 可以让 lua 支持 “真协程”。本文研究了 luaCoco 的内部实现，并把它移植到了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tensilica&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xtensa&lt;/a&gt; 处理器上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;porting luaCoco&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/7101caf8fc0075b8d52d5a15ad9f6cb9.png&quot; alt=&quot;image_1bhbpomnrk0m58270a54k789.png-16.9kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="lua" scheme="https://lengzzz.com/tags/lua/"/>
    
      <category term="coroutine" scheme="https://lengzzz.com/tags/coroutine/"/>
    
      <category term="协程" scheme="https://lengzzz.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="移植" scheme="https://lengzzz.com/tags/%E7%A7%BB%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>搞了个 golang 的文档站</title>
    <link href="https://lengzzz.com/2017/01/12/%E6%90%9E%E4%BA%86%E4%B8%AAgolang%E7%9A%84%E6%96%87%E6%A1%A3%E7%AB%99/"/>
    <id>https://lengzzz.com/2017/01/12/%E6%90%9E%E4%BA%86%E4%B8%AAgolang%E7%9A%84%E6%96%87%E6%A1%A3%E7%AB%99/</id>
    <published>2017-01-12T05:56:42.000Z</published>
    <updated>2017-07-20T17:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>地址在这里：<a href="https://go.lengzzz.com" target="_blank" rel="noopener">https://go.lengzzz.com</a></p><p><a href="/notename/" title="godoc"></a></p><p><img src="/images/5970731776c90dd6af3c828ca79433c3.png" alt="image_1b68k36vh18er1h5ltlqn3o1b1pm.png-3.5kB"></p><p>点这个按钮哦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;地址在这里：&lt;a href=&quot;https://go.lengzzz.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://go.lengzzz.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;godoc
      
    
    </summary>
    
    
    
      <category term="闲扯" scheme="https://lengzzz.com/tags/%E9%97%B2%E6%89%AF/"/>
    
      <category term="golang" scheme="https://lengzzz.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>小蚁摄像头实时同步视频到群晖 nas（2）—— 使用 rtsp 协议同步</title>
    <link href="https://lengzzz.com/2017/01/04/%E5%B0%8F%E8%9A%81%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E8%A7%86%E9%A2%91%E5%88%B0%E7%BE%A4%E6%99%96nas%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8rtsp%E5%8D%8F%E8%AE%AE%E5%90%8C%E6%AD%A5/"/>
    <id>https://lengzzz.com/2017/01/04/%E5%B0%8F%E8%9A%81%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E8%A7%86%E9%A2%91%E5%88%B0%E7%BE%A4%E6%99%96nas%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8rtsp%E5%8D%8F%E8%AE%AE%E5%90%8C%E6%AD%A5/</id>
    <published>2017-01-04T07:27:55.000Z</published>
    <updated>2017-01-04T08:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://lengzzz.com/note/sync-video-from-yi-camera-to-synology-nas" title="小蚁摄像头实时同步视频到群晖 nas">上一篇 blog</a> 我利用 inotify-tools 和 rsync 两个工具实现了自动同步小蚁摄像机里拍摄的视频。不过今天翻网络又发现了另一种自动同步的解决方案，这个可以利用到群晖 nas 的 Surveillance Station 功能，使用效果更佳一些。这篇博客记录一下这次折腾过程。</p><p><a href="/notename/" title="sync video from yi camera to synology nas 2"></a></p><a id="more"></a><p>Surveillance Station 是群晖上的一个功能套件，可以管理网络摄像机，功能十分强大，而且原生支持很多品牌的网络摄像机，但是不支持小蚁摄像机。不过还好的是 Surveillance Station 支持 rtsp 协议，只要能在小蚁上开启 rtsp 服务就可以了。</p><center width="80%">![QQ20170104-1@2x.png-4220.7kB][1]<small>功能很强的Surveillance Station</small></center><p>这次没有自己编译 rtsp 服务，一是因为没有找到一个好用又轻量的，二是因为刚好找到一个俄罗斯的国际友人做的 <a href="https://github.com/fritz-smh/yi-hack" target="_blank" rel="noopener">“小蚁Hack”项目</a> 里面正好有我想要的 rtsp 服务，我就直接拿来用了。</p><p>我们只需要用到他项目里的一个文件，叫做 rtspsvrM 可以在 <a href="https://raw.githubusercontent.com/fritz-smh/yi-hack/master/sd/test/rtspsvrM" target="_blank" rel="noopener">https://raw.githubusercontent.com/fritz-smh/yi-hack/master/sd/test/rtspsvrM</a> 下载到。如果小蚁的系统版本比较老，可能需要 rtspsvrK 或者 rtspsvrI。我用的最新的 1.8.6.1 所以使用 M 版本的。具体的规则可以在 <a href="https://github.com/fritz-smh/yi-hack/blob/master/sd/test/equip_test.sh#L216" target="_blank" rel="noopener">https://github.com/fritz-smh/yi-hack/blob/master/sd/test/equip_test.sh#L216</a> 这个脚本里找到，我就不赘述了。</p><p>下载好 rtspsvrM 文件后，放到 sd 卡根目录，然后再创建一个服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/tmp/hd1/rtspsvrM &gt;&gt; /tmp/hd1/rtspsvrM.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>然后重启，执行下 <code>netstat -tuanp</code> ，可以看到 rtspsvrM 已经监听 554 端口了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tuanp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:38888           0.0.0.0:*               LISTEN      1266/goolink</span><br><span class="line">tcp        0      0 0.0.0.0:8554            0.0.0.0:*               LISTEN      1214/rtspsvrM</span><br><span class="line">tcp        0      0 0.0.0.0:554             0.0.0.0:*               LISTEN      1214/rtspsvrM</span><br><span class="line">tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      1197/tcpsvd</span><br><span class="line">tcp        0      0 0.0.0.0:18554           0.0.0.0:*               LISTEN      1214/rtspsvrM</span><br><span class="line">tcp        0      0 10.0.0.224:49016        120.25.66.121:28622     ESTABLISHED 1266/goolink</span><br><span class="line">tcp        0      1 10.0.0.224:53621        10.0.0.1:56688          LAST_ACK    -</span><br><span class="line">tcp        0  36200 10.0.0.224:35958        10.0.0.222:873          ESTABLISHED 1837/rsync</span><br><span class="line">tcp        0      0 10.0.0.224:554          10.0.0.222:53007        ESTABLISHED 1214/rtspsvrM</span><br><span class="line">tcp        0      0 10.0.0.224:42065        42.62.94.185:80         ESTABLISHED 1629/cloud</span><br><span class="line">tcp        0      0 :::80                   :::*                    LISTEN      1141/server</span><br><span class="line">tcp        0      0 :::23                   :::*                    LISTEN      1204/telnetd</span><br><span class="line">tcp        0   1087 ::ffff:10.0.0.224:23    ::ffff:10.0.0.220:46884 ESTABLISHED 1204/telnetd</span><br><span class="line">udp        0      0 0.0.0.0:6970            0.0.0.0:*                           1214/rtspsvrM</span><br><span class="line">udp        0      0 0.0.0.0:6972            0.0.0.0:*                           1214/rtspsvrM</span><br><span class="line">udp        0      0 0.0.0.0:23887           0.0.0.0:*                           2596/p2p_tnp</span><br><span class="line">udp        0      0 0.0.0.0:32108           0.0.0.0:*                           2596/p2p_tnp</span><br><span class="line">udp        0      0 0.0.0.0:56944           0.0.0.0:*                           1266/goolink</span><br><span class="line">udp        0      0 0.0.0.0:56501           0.0.0.0:*                           1266/goolink</span><br><span class="line">udp        0      0 0.0.0.0:1500            0.0.0.0:*                           1266/goolink</span><br></pre></td></tr></table></figure><p>说明服务已经起来了。另外这个 rtspsvrM 虽然没有开源，但是他好像没有建立什么乱七八糟的网络连接，姑且认为它不会泄漏用户信息。</p><p>现在回到 nas 的管理界面中，打开 Surveillance Station，点击网络摄像机点新增。</p><p><img src="/images/c5056a2da99646ecea5ee8e10bf43334.png" alt="image_1b5k8dc0o19jf8bt1fe1abrtjr17.png-48.3kB"></p><p>之后把 IP、端口号填写上，品牌选择最上面的用户自定义。最后一个视频原路径很关键，需要填写成 <code>rtsp://10.0.0.224:554/ch0_0.h264</code> 把其中的 IP 地址替换成你摄像机的 IP 就可以了。</p><p>之后，就可以好好享受 Surveillance Station 的强大功能了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://lengzzz.com/note/sync-video-from-yi-camera-to-synology-nas&quot; title=&quot;小蚁摄像头实时同步视频到群晖 nas&quot;&gt;上一篇 blog&lt;/a&gt; 我利用 inotify-tools 和 rsync 两个工具实现了自动同步小蚁摄像机里拍摄的视频。不过今天翻网络又发现了另一种自动同步的解决方案，这个可以利用到群晖 nas 的 Surveillance Station 功能，使用效果更佳一些。这篇博客记录一下这次折腾过程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;sync video from yi camera to synology nas 2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="https://lengzzz.com/tags/linux/"/>
    
      <category term="折腾" scheme="https://lengzzz.com/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="嵌入式" scheme="https://lengzzz.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>小蚁摄像机实时同步视频到群晖 nas</title>
    <link href="https://lengzzz.com/2017/01/02/%E5%B0%8F%E8%9A%81%E6%91%84%E5%83%8F%E6%9C%BA%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E8%A7%86%E9%A2%91%E5%88%B0%E7%BE%A4%E6%99%96nas/"/>
    <id>https://lengzzz.com/2017/01/02/%E5%B0%8F%E8%9A%81%E6%91%84%E5%83%8F%E6%9C%BA%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E8%A7%86%E9%A2%91%E5%88%B0%E7%BE%A4%E6%99%96nas/</id>
    <published>2017-01-02T14:28:14.000Z</published>
    <updated>2017-01-04T07:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前买了个小蚁智能摄像机，原生只支持向小米路由器里同步视频，我只有一个群晖 nas 做网络存储，所以元旦放假在家研究了下怎么样“破解”小蚁摄像头使它能同步视频到 nas 上。本质上，小蚁摄像头也是一个 Linux 服务器，只不过是运行在 arm 上的嵌入式 Linux，所以 Linux 的整个生态环境都可以利用的上。我这次的解决方案是使用 Linux 上著名的 <a href="https://rsync.samba.org/" target="_blank" rel="noopener">rsync</a> 做同步工具，但是必须编译出一个在 arm 上能用使用的 rsync。所以这篇文章的重点是 <strong>交叉编译</strong>。</p><p><a href="/notename/" title="sync video from Yi Camera to Synology nas"></a></p><a id="more"></a><h2 id="拿到小蚁摄像头的-shell"><a href="#拿到小蚁摄像头的-shell" class="headerlink" title="拿到小蚁摄像头的 shell"></a>拿到小蚁摄像头的 shell</h2><p>据说某些系统版本的小蚁摄像头默认没关闭 telnet 服务，那么在做以下事情之前可以先试试你的摄像头是不是已经开启了 telnet 。在终端里运行 <code>telnet xxx.xxx.xxx.xxx</code> xxx.xxx.xxx.xxx 是你摄像头的 ip 地址，可以在路由器管理界面中查到。如果出现 <code>(none) login:</code> 字样，说明你已经拿到了 shell，就不用做下面的操作了，直接跳到<a href="#jumpto-1">这里</a>。</p><ul><li>把小蚁摄像头里的内存卡取出来，在内存卡根目录建立一个文件夹 test</li><li>在 test 目录下创建文件 <code>equip_test.sh</code> 粘贴以下内容。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Telnet</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">"/etc/init.d/S88telnet"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"#!/bin/sh"</span> &gt; /etc/init.d/S88telnet</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"telnetd &amp;"</span> &gt;&gt; /etc/init.d/S88telnet</span><br><span class="line">    chmod 755 /etc/init.d/S88telnet</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">dr=`dirname <span class="variable">$0</span>`</span><br><span class="line"><span class="comment"># fix bootcycle</span></span><br><span class="line">mv <span class="variable">$dr</span>/equip_test.sh <span class="variable">$dr</span>/equip_test.sh.moved</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>根据网上的说法，<code>equip_test.sh</code> 会在开机的时候自动运行。</p><p>这个脚本的内容很简单，第一步创建 <code>/etc/init.d/S88telnet</code> 这个文件，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">telnetd &amp;</span><br></pre></td></tr></table></figure><p>这个文件相当于创建了一个 busybox-init 的 <code>服务</code> [^ref3]，和 ubuntu、CentOS 的服务类似，不过功能更简单一些，直接就是一个 shell 脚本。这个 shell 脚本开启了 telnetd 后台程序。</p><p>第二步是把自身重命名并且重启，避免每次摄像头开机重复运行。</p><div id="jumpto-1"></div><p>现在，可以把内存卡查到摄像头中开机，不出意外的话现在再次在终端里输入 <code>telnet xxx.xxx.xxx.xxx</code> 就可以看到 <code>(none) login:</code> 了，现在输入用户名 <code>root</code> 按回车，再输入密码 <code>1234qwer</code> 就可以进入小蚁摄像头的 shell 界面了。</p><h2 id="交叉编译-rsync"><a href="#交叉编译-rsync" class="headerlink" title="交叉编译 rsync"></a>交叉编译 rsync</h2><p>拿到 shell 之后先进去看了看系统信息，没想到这个小蚁摄像头的配置这么寒酸。。。? cpu 是 N 年前的 arm9 ，内存只有 32MiB ，你没看错，就是 32MiB，一点都不夸张，root 文件系统只有 3.5MiB 的空间，毛都放不了，只能想办法把东西放内存卡上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line"><span class="string">Linux</span> <span class="string">(none)</span> <span class="number">3.0</span><span class="number">.8</span> <span class="comment">#1 Wed Apr 30 16:56:49 CST 2014 armv5tejl GNU/Linux</span></span><br><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/proc/cpuinfo</span></span><br><span class="line"><span class="attr">Processor       :</span> <span class="string">ARM926EJ-S</span> <span class="string">rev</span> <span class="number">5</span> <span class="string">(v5l)</span></span><br><span class="line"><span class="attr">BogoMIPS        :</span> <span class="number">218.72</span></span><br><span class="line"><span class="attr">Features        :</span> <span class="string">swp</span> <span class="string">half</span> <span class="string">thumb</span> <span class="string">fastmult</span> <span class="string">edsp</span> <span class="string">java</span></span><br><span class="line"><span class="attr">CPU implementer :</span> <span class="number">0x41</span></span><br><span class="line"><span class="attr">CPU architecture:</span> <span class="string">5TEJ</span></span><br><span class="line"><span class="attr">CPU variant     :</span> <span class="number">0x0</span></span><br><span class="line"><span class="attr">CPU part        :</span> <span class="number">0x926</span></span><br><span class="line"><span class="attr">CPU revision    :</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Hardware        :</span> <span class="string">hi3518</span></span><br><span class="line"><span class="attr">Revision        :</span> <span class="number">0000</span></span><br><span class="line"><span class="attr">Serial          :</span> <span class="number">0000000000000000</span></span><br><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/proc/meminfo</span></span><br><span class="line"><span class="attr">MemTotal:</span>          <span class="number">35212</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">MemFree:</span>            <span class="number">1044</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Buffers:</span>             <span class="number">268</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Cached:</span>            <span class="number">10016</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapCached:</span>            <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Active:</span>            <span class="number">11536</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Inactive:</span>           <span class="number">5432</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Active(anon):</span>       <span class="number">6996</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Inactive(anon):</span>     <span class="number">2944</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Active(file):</span>       <span class="number">4540</span> <span class="string">kB</span></span><br><span class="line"><span class="string">Inactive(file):</span>     <span class="number">2488</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Unevictable:</span>           <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Mlocked:</span>               <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapTotal:</span>             <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapFree:</span>              <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Dirty:</span>               <span class="number">600</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Writeback:</span>             <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">AnonPages:</span>          <span class="number">6708</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Mapped:</span>             <span class="number">5344</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Shmem:</span>              <span class="number">3256</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Slab:</span>               <span class="number">8152</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SReclaimable:</span>       <span class="number">1192</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SUnreclaim:</span>         <span class="number">6960</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">KernelStack:</span>         <span class="number">808</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">PageTables:</span>          <span class="number">692</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">NFS_Unstable:</span>          <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Bounce:</span>                <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">WritebackTmp:</span>          <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">CommitLimit:</span>       <span class="number">17604</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Committed_AS:</span>     <span class="number">312508</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">VmallocTotal:</span>     <span class="number">966656</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">VmallocUsed:</span>       <span class="number">23856</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">VmallocChunk:</span>     <span class="number">935280</span> <span class="string">kB</span></span><br><span class="line"><span class="string">$</span> <span class="string">df</span> <span class="string">-h</span></span><br><span class="line"><span class="string">Filesystem</span>                <span class="string">Size</span>      <span class="string">Used</span> <span class="string">Available</span> <span class="string">Use%</span> <span class="string">Mounted</span> <span class="string">on</span></span><br><span class="line"><span class="string">/dev/root</span>                 <span class="number">3.</span><span class="string">5M</span>      <span class="number">2.</span><span class="string">7M</span>    <span class="number">844.</span><span class="string">0K</span>  <span class="number">76</span><span class="string">%</span> <span class="string">/</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">17.</span><span class="string">2M</span>     <span class="number">16.</span><span class="string">0K</span>     <span class="number">17.</span><span class="string">2M</span>   <span class="number">0</span><span class="string">%</span> <span class="string">/dev</span></span><br><span class="line"><span class="string">/dev/mtdblock5</span>            <span class="number">8.</span><span class="string">9M</span>      <span class="number">8.</span><span class="string">1M</span>    <span class="number">784.</span><span class="string">0K</span>  <span class="number">91</span><span class="string">%</span> <span class="string">/home</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">32.</span><span class="string">0M</span>    <span class="number">164.</span><span class="string">0K</span>     <span class="number">31.</span><span class="string">8M</span>   <span class="number">1</span><span class="string">%</span> <span class="string">/tmp</span></span><br><span class="line"><span class="string">/dev/hd1</span>                 <span class="number">14.</span><span class="string">8G</span>      <span class="number">4.</span><span class="string">1G</span>     <span class="number">10.</span><span class="string">8G</span>  <span class="number">27</span><span class="string">%</span> <span class="string">/tmp/hd1</span></span><br><span class="line"><span class="string">tmpfs</span>                   <span class="number">512.</span><span class="string">0K</span>     <span class="number">16.</span><span class="string">0K</span>    <span class="number">496.</span><span class="string">0K</span>   <span class="number">3</span><span class="string">%</span> <span class="string">/home/mmap_tmpfs</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">16.</span><span class="string">0M</span>     <span class="number">36.</span><span class="string">0K</span>     <span class="number">16.</span><span class="string">0M</span>   <span class="number">0</span><span class="string">%</span> <span class="string">/home/tmpfs</span></span><br><span class="line"><span class="string">tmpfs</span>                    <span class="number">16.</span><span class="string">0M</span>      <span class="number">3.</span><span class="string">0M</span>     <span class="number">13.</span><span class="string">0M</span>  <span class="number">19</span><span class="string">%</span> <span class="string">/home/jrview</span></span><br></pre></td></tr></table></figure><p>soc 用的好像是屁眼公司的 hi3518，小米在手机行业和华为干架那么厉害，芯片还是得用菊花厂的啊。</p><p>回归正题，我们开始交叉编译 rsync。一开始我用的是 ubuntu 上自带的交叉工具链 <code>gcc-arm-linux-gnueabi</code> 折腾半天编译出来的东西没法用，这才发现这个摄像头用的 libc 是 uClibc， 这种低端错误都犯了，之前自己做嵌入式的时候最常用的就是 uClibc 都忘记了?。</p><p>后来想办法下载一个 <code>arm-linux-uclibc-gcc</code> ubuntu 上好像没有现成的源可以下，Google 一下发现了这个 maillist <a href="http://lists.busybox.net/pipermail/buildroot/2010-January/031634.html。" target="_blank" rel="noopener">http://lists.busybox.net/pipermail/buildroot/2010-January/031634.html。</a></p><p>这个帖子讨论的是一个叫 <a href="https://buildroot.org/" target="_blank" rel="noopener">buildroot</a> 的东西。我研究了一下这个项目，它竟然可以一键 build 出整个嵌入式系统，包括 host 上运行的交叉工具链、bootloader、kernel、root filesystem甚至是各种软件包，其中就包括 rsync。那我还费心找什么工具链啊，直接用它就好了。</p><p>现在要做的就是找一台 Linux 机器，在上面运行以下命令，编译出 rsync。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://buildroot.org/downloads/buildroot-2016.11.1.tar.gz</span><br><span class="line">tar xvf buildroot-2016.11.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> buildroot-2016.11.1</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>执行 <code>make menuconfig</code> 之后会出现一个菜单（和编译内核的菜单用的同一个）。</p><ul><li>进入 <code>Target options</code> 再进入 <code>Target Architecture</code> 菜单，选择 <code>ARM (little endian)</code></li><li>进入 <code>Target Architecture Variant</code> 选择 <code>arm926t</code> 其他选项不用动，按两下 esc 退出来</li><li>进入 <code>Toolchain</code> 菜单，<code>C library</code> 选择 <code>uClibc-ng</code></li><li>进入 <code>Kernel Headers</code>，貌似没有 <code>3.0.8</code> 选个最低的 <code>Linux 3.2.x kernel headers</code> 吧</li><li>退出来进入 <code>Target packages</code>，在 <code>Networking applications</code> 里找到 <code>rsync</code> 按空格键打上勾</li><li>退出来进入 <code>Shell and utilities</code> 把 <code>inotify-tools</code> 打上勾，这个我们也要用到</li><li>按 tab 键，使光标移动到 <code>Save</code>，回车存盘退出。</li></ul><p>之后执行 make，经过漫长的等待，终于编译好了。进入到 buildroot-2016.11.1/output/target 文件夹可以看到整个根目录，在 <code>/usr/bin</code> 可以看到编译好的 rsync 。不过只把这个文件放到摄像头是不行的，因为还有 rsync 的动态链接库 so 文件也得放进去。</p><p>我直接 <code>tar zxcf target.tgz ./target</code> 把根目录打包，放到摄像头内。然后摄像头开机进入 shell，执行 <code>tar xvf target.tgz</code> 解包到内存卡里。然饿。。。现在也不能运行，因为必须把链接库的目录设置好，在 shell 里再执行一下 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/tmp/hd1/target/bin:/tmp/hd1/target/usr/bin</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/tmp/hd1/target/lib:/tmp/hd1/target/usr/lib</span><br></pre></td></tr></table></figure><p>这个是把动态库的搜索路径设置好，具体可以看我<a href="https://lengzzz.com/note/linux-so-search-path">这篇文章</a>，现在，执行 rsync，竟然报错 <code>libz.so.1 not found</code> 。我进入发现只有 <code>libz.so.1.2.8</code> 并没有 <code>libz.so.1</code> 原来是因为内存卡是 fat32，不支持软连接，只好复制一份了?。<code>cp libz.so.1.2.8 libz.so.1</code> 这也是没有办法的事。</p><p>最后，执行一下 rsync，可以看到久违的帮助信息了，真不容易。</p><h2 id="自动同步脚本"><a href="#自动同步脚本" class="headerlink" title="自动同步脚本"></a>自动同步脚本</h2><p>rsync 只能同步一次文件，当文件保持同步之后就会退出，怎么样想个方法能让两端文件实时同步呢？答案是利用 <a href="https://github.com/rvoicilas/inotify-tools" target="_blank" rel="noopener">inotify-tool</a>。这个工具利用了内核的通知系统，当文件进行改动之后，就会发出一个通知，此时再调用 rsync 进行同步就可以了。</p><p>所以把它写成了一个脚本[^ref4]：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/tmp/hd1/target/lib:/tmp/hd1/target/usr/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/tmp/hd1/target/bin:/tmp/hd1/target/usr/bin</span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=<span class="string">"xxxxx"</span></span><br><span class="line"></span><br><span class="line">SRC=/tmp/hd1/record/</span><br><span class="line">DST=rsync://YiCamera@10.0.0.222/YiCamera/</span><br><span class="line">nowtime=$(date +%s)</span><br><span class="line">inotifywait -mrq --timefmt <span class="string">'%s'</span> --format <span class="string">'%T'</span> -e modify,delete,create,attrib,move <span class="variable">$SRC</span> | <span class="keyword">while</span></span><br><span class="line"><span class="built_in">read</span> timestamp</span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line">    diffnow=$((<span class="variable">$nowtime</span> - <span class="variable">$timestamp</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$nowtime</span> <span class="variable">$timestamp</span> <span class="variable">$diffnow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$diffnow</span> -lt 5 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'start rsync'</span></span><br><span class="line">        rsync -vzrtopg --delete <span class="variable">$SRC</span> <span class="variable">$DST</span></span><br><span class="line">        nowtime=$(date +%s)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>解释一下这个脚本。前两句不用说了，第三局是导出一个系统变量，rsync 会读取这个变量拿到 rsync 的密码[^ref2]。之后是调用 inotifywait，当他发现文件的修改、删除、创建、修改属性时，会输出到标准输出中。</p><p>标准输出被重定向到管道中，<code>read files</code> 当接不到数据时会 block，当接收到数据之后会向下执行 rsync。</p><p>rsync 的参数 <code>-vzrtopg</code> 里的v是verbose，z是压缩，r是recursive，topg都是保持文件原有属性如属主、时间的参数，–delete参数会把原有getfile目录下的文件删除以保持客户端和服务器端文件系统完全一致<a href="[Rsync安全配置](http://wps2015.org/drops/drops/Rsync%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE.html)">^ref1</a>。</p><p>然后，在 <code>/etc/init.d</code> 创建一个服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/init.d/S90nasync</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/tmp/hd1/nasync.sh &gt;&gt; /tmp/hd1/nasync.log &amp;</span><br></pre></td></tr></table></figure><p>重启摄像头，你会发现，nas 里有自动同步过来的视频了。</p><p>[^ref2]: <a href="http://unix.stackexchange.com/questions/111526/rsync-without-prompt-for-password" target="_blank" rel="noopener">rsync without prompt for password</a></p><p>[^ref3]: <a href="http://unix.stackexchange.com/questions/59018/create-and-control-start-up-scripts-in-busybox" target="_blank" rel="noopener">Create and control start up scripts in BusyBox</a></p><p>[^ref4]: <a href="http://miaocbin.blog.51cto.com/689091/1662466" target="_blank" rel="noopener">Linux-rsync+inotify 文件实时同步</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前买了个小蚁智能摄像机，原生只支持向小米路由器里同步视频，我只有一个群晖 nas 做网络存储，所以元旦放假在家研究了下怎么样“破解”小蚁摄像头使它能同步视频到 nas 上。本质上，小蚁摄像头也是一个 Linux 服务器，只不过是运行在 arm 上的嵌入式 Linux，所以 Linux 的整个生态环境都可以利用的上。我这次的解决方案是使用 Linux 上著名的 &lt;a href=&quot;https://rsync.samba.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rsync&lt;/a&gt; 做同步工具，但是必须编译出一个在 arm 上能用使用的 rsync。所以这篇文章的重点是 &lt;strong&gt;交叉编译&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;sync video from Yi Camera to Synology nas&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="https://lengzzz.com/tags/linux/"/>
    
      <category term="折腾" scheme="https://lengzzz.com/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="嵌入式" scheme="https://lengzzz.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="交叉编译" scheme="https://lengzzz.com/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>把你的 Linux 服务器打造成 AirPlay 音乐播放器</title>
    <link href="https://lengzzz.com/2016/11/18/%E6%8A%8A%E4%BD%A0%E7%9A%84Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%93%E9%80%A0%E6%88%90AirPlay%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://lengzzz.com/2016/11/18/%E6%8A%8A%E4%BD%A0%E7%9A%84Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%93%E9%80%A0%E6%88%90AirPlay%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</id>
    <published>2016-11-18T07:57:43.000Z</published>
    <updated>2017-01-02T14:31:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>AirPlay 是苹果设备上最方便的播放技术，可以很方便的把音频、视频串流到你的电视或音箱上。现在大部分智能电视都支持 AirPlay 投屏了，但是支持 AirPlay 的音响设备还是比较少见（and 贵）。那么，有没有比较廉价的搭建 AirPlay 音乐播放器的方式呢？那就是今天的主角 shairport-sync。</p><p><a href="/notename/" title="make your linux server a airplay player"></a></p><a id="more"></a><p>shairport 是一个音频 AirPlay receiver 服务器。但是不幸的是 shairport 的作者两年前停止更新了，就有了另一个开发者 fork 了 shairport 做出了 shairport-sync。</p><p>shairport-sync 基于 shairport，在此基础上还改进了音视频的同步的问题，这样使用 shairport-sync 播放视频时不会出现影音不同步的问题了。</p><h2 id="在-ubuntu-16-04-上安装-shairport-sync"><a href="#在-ubuntu-16-04-上安装-shairport-sync" class="headerlink" title="在 ubuntu 16.04 上安装 shairport-sync"></a>在 ubuntu 16.04 上安装 shairport-sync</h2><p>ubuntu 16.04 的软件仓库里已经集成了 shairport-sync，这样只需要执行 <code>apt install</code> 就可以安装了。</p><p>但是 shairport 还需要 avahi-daemon 这个服务，avahi-daemon 是开源的，它实现了苹果的 mDNS 协议（在苹果的设备上对应的服务是 Banjour）。shairport 需要在 avahi 上注册自己。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install avahi-daemon</span><br><span class="line">sudo apt install shairport-sync</span><br></pre></td></tr></table></figure><h2 id="配置-shairport-sync"><a href="#配置-shairport-sync" class="headerlink" title="配置 shairport-sync"></a>配置 shairport-sync</h2><p>shairport-sync 的配置非常简单，它的配置文件放在 <code>/etc/shairport-sync.conf</code> ，打开它之后会发现里面有很多配置项，我们只需要简单的配置下 name 就可以了，其他的选项不用动。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> General Settings</span><br><span class="line">general =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">//</span><span class="string">...</span></span><br><span class="line">    name = <span class="string">"客厅的服务器"</span>;</span><br><span class="line">    <span class="string">//</span><span class="string">...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改完配置之后记得重启一下服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shairport-sync.service</span><br></pre></td></tr></table></figure><h2 id="不出声音的故障"><a href="#不出声音的故障" class="headerlink" title="不出声音的故障"></a>不出声音的故障</h2><p>安装之后有可能会不出声音，这是因为 shairport 的用户不在 audio 组了，这样的话 shairport 没有音频设备的权限，执行下面语句可以解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG audio shairport-sync</span><br></pre></td></tr></table></figure><h2 id="最后来一张效果图"><a href="#最后来一张效果图" class="headerlink" title="最后来一张效果图"></a>最后来一张效果图</h2><p><img src="/images/1ee3cfdd2eb20f717381a3c95775dec8.PNG" alt="IMG_1197.PNG-394.9kB"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AirPlay 是苹果设备上最方便的播放技术，可以很方便的把音频、视频串流到你的电视或音箱上。现在大部分智能电视都支持 AirPlay 投屏了，但是支持 AirPlay 的音响设备还是比较少见（and 贵）。那么，有没有比较廉价的搭建 AirPlay 音乐播放器的方式呢？那就是今天的主角 shairport-sync。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;make your linux server a airplay player&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="https://lengzzz.com/tags/linux/"/>
    
      <category term="AirPlay" scheme="https://lengzzz.com/tags/AirPlay/"/>
    
      <category term="" scheme="https://lengzzz.com/tags/%EF%A3%BF/"/>
    
  </entry>
  
  <entry>
    <title>女朋友都能看懂的 git 速查</title>
    <link href="https://lengzzz.com/2016/08/11/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E9%83%BD%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84git%E9%80%9F%E6%9F%A5/"/>
    <id>https://lengzzz.com/2016/08/11/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E9%83%BD%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84git%E9%80%9F%E6%9F%A5/</id>
    <published>2016-08-11T06:19:56.000Z</published>
    <updated>2017-06-27T08:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>为女朋友总结了一些常用的 git 操作。这个速查默认：以 master 为主分支，开发新功能创建新分支。</p><p><a href="/notename/" title="girlfriend readable git quick"></a></p><p><img src="/images/56a0d8728d3325d70ca114f659975936.jpg" alt="atlassian-getting-git-right.jpg-94.4kB"></p><a id="more"></a><h2 id="1-开发一个功能"><a href="#1-开发一个功能" class="headerlink" title="1. 开发一个功能"></a>1. 开发一个功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先确保自己在 master 且代码是最新的</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最新的代码上建一个分支</span></span><br><span class="line">git checkout -b xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地进行开发</span></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"zzz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"yyy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"www"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发完成，push开发分支</span></span><br><span class="line">git push -u origin xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在代码审核工具上创建 pull request</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据别人的审核意见，修改代码</span></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"yyy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line">git commit -m <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将修改后的代码push</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 审核通过，按按钮合并 pr</span></span><br></pre></td></tr></table></figure><h2 id="2-审核过了之后有冲突"><a href="#2-审核过了之后有冲突" class="headerlink" title="2. 审核过了之后有冲突"></a>2. 审核过了之后有冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先把 master 上的代码更新一下</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后把开发分支的代码 rebase 到最新的代码之上</span></span><br><span class="line">git checkout xxx</span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时，会出现冲突，打开文件，手动把文件修改正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后执行这个：</span></span><br><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时，开发分支 xxx 已经和 master 没有冲突了，push 上去</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在代码审核工具上，按按钮合并</span></span><br></pre></td></tr></table></figure><h2 id="3-开发了一半的功能，不想-commit-也不想丢掉"><a href="#3-开发了一半的功能，不想-commit-也不想丢掉" class="headerlink" title="3. 开发了一半的功能，不想 commit 也不想丢掉"></a>3. 开发了一半的功能，不想 commit 也不想丢掉</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把修改暂存起来</span></span><br><span class="line">git add .</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以查看刚刚暂存的信息</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在需要继续开发，把暂存的东西 pop 出来</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在再看暂存列表，已经清空了</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="4-只提交某几个文件，其他几个文件暂存起来"><a href="#4-只提交某几个文件，其他几个文件暂存起来" class="headerlink" title="4. 只提交某几个文件，其他几个文件暂存起来"></a>4. 只提交某几个文件，其他几个文件暂存起来</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只提交这几个文件</span></span><br><span class="line">git add 1.go 2.go 3.go</span><br><span class="line">git commit -m <span class="string">"zzz"</span></span><br><span class="line"><span class="comment"># 看一下，剩下的文件确实未提交</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 暂存</span></span><br><span class="line">git add .</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure><h2 id="5-只提交某几行，其余行暂存"><a href="#5-只提交某几行，其余行暂存" class="headerlink" title="5. 只提交某几行，其余行暂存"></a>5. 只提交某几行，其余行暂存</h2><p>打开 sourcetree </p><p><img src="/images/40fd3596ffd1775197277b3916aa77ed.png" alt="image_1aps6uir211qg14423s41qjq85g9.png-47.5kB"></p><p>选中像提交的行，点按钮暂存行</p><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只提交某几行</span></span><br><span class="line">git commit -m <span class="string">"zzz"</span></span><br><span class="line"><span class="comment"># 看一下，剩下的行确实没提交</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 暂存</span></span><br><span class="line">git add .</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure><blockquote><p>已暂存的修改，叫做 <code>stashed changes</code> </p></blockquote><h2 id="6-已经-git-add-的文件，想变回未-add-的状态"><a href="#6-已经-git-add-的文件，想变回未-add-的状态" class="headerlink" title="6. 已经 git add 的文件，想变回未 add 的状态"></a>6. 已经 git add 的文件，想变回未 add 的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 1.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想把所有文件都未 add 的状态</span></span><br><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure><blockquote><p>已经被 add 的修改，叫做 <code>staged changes</code>；未 add 的叫做 <code>unstaged changes</code> </p></blockquote><h2 id="7-已经修改，但未-add-的文件，想变回未修改的状态"><a href="#7-已经修改，但未-add-的文件，想变回未修改的状态" class="headerlink" title="7. 已经修改，但未 add 的文件，想变回未修改的状态"></a>7. 已经修改，但未 add 的文件，想变回未修改的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- 1.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想把所有文件都变回未修改的状态</span></span><br><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure><h2 id="8-已经-commit-了，但是不想要了，想回到上一个-commit-重新写"><a href="#8-已经-commit-了，但是不想要了，想回到上一个-commit-重新写" class="headerlink" title="8. 已经 commit 了，但是不想要了，想回到上一个 commit 重新写"></a>8. 已经 commit 了，但是不想要了，想回到上一个 commit 重新写</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回到上一个 commit，把这个 commit 的修改变成 unstaged changes</span></span><br><span class="line">git reset HEAD^</span><br><span class="line"><span class="comment"># 把 unstaged changes 变回未修改的状态</span></span><br><span class="line">git checkout -- .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新写</span></span><br></pre></td></tr></table></figure><h2 id="9-已经-commit，并且-push-了，但是不想要了，想回到上一个-commit-重新写"><a href="#9-已经-commit，并且-push-了，但是不想要了，想回到上一个-commit-重新写" class="headerlink" title="9. 已经 commit，并且 push 了，但是不想要了，想回到上一个 commit 重新写"></a>9. 已经 commit，并且 push 了，但是不想要了，想回到上一个 commit 重新写</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上，但是最后再push的时候需要加 -f</span></span><br><span class="line"></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h2 id="9-上个方法太暴力了"><a href="#9-上个方法太暴力了" class="headerlink" title="9. 上个方法太暴力了"></a>9. 上个方法太暴力了</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个和上个提交完全相反的提交</span></span><br><span class="line">git revert HEAD</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为女朋友总结了一些常用的 git 操作。这个速查默认：以 master 为主分支，开发新功能创建新分支。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;girlfriend readable git quick&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/56a0d8728d3325d70ca114f659975936.jpg&quot; alt=&quot;atlassian-getting-git-right.jpg-94.4kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="git" scheme="https://lengzzz.com/tags/git/"/>
    
      <category term="速查" scheme="https://lengzzz.com/tags/%E9%80%9F%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>总结 golang 对于 stream 的抽象</title>
    <link href="https://lengzzz.com/2016/07/18/%E6%80%BB%E7%BB%93golang%E5%AF%B9%E4%BA%8Estream%E7%9A%84%E6%8A%BD%E8%B1%A1/"/>
    <id>https://lengzzz.com/2016/07/18/%E6%80%BB%E7%BB%93golang%E5%AF%B9%E4%BA%8Estream%E7%9A%84%E6%8A%BD%E8%B1%A1/</id>
    <published>2016-07-18T07:23:09.000Z</published>
    <updated>2016-08-10T06:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对 golang 标准库中的 stream 进行了一些总结。</p><p><a href="/notename/" title="golang stream"></a></p><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>在 golang 中，通过几个基本的 interface 对流操作进行了抽象。</p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>首先是最基本的Reader、Writer，定义了对于一个流来说最基本的操作：<strong>读、写</strong>。这两个 interface 定义在 <code>io</code> 包里。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Seeker、ReaderAt、WriterAt、Closer"><a href="#Seeker、ReaderAt、WriterAt、Closer" class="headerlink" title="Seeker、ReaderAt、WriterAt、Closer"></a>Seeker、ReaderAt、WriterAt、Closer</h3><p>更进一步的，最常见的流就是文件了。对于文件来说，除了简单的读写操作之外，还有 <strong>Seek、ReadAt、WriteAt、Close</strong> 操作。标准库对这些操作也进行了抽象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>有了这些基础设施之后，就可以使用 golang 的<strong>组合</strong>大法了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriteSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer</span><br><span class="line">    Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Seeker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>其他还有一些不很常用的操作。</p><p><strong>写到一个Writer中</strong>、<strong>从一个Reader中读取</strong>。这两个操作会自动判断EOF，如果没有把所有数据写完／读完，就会继续写／读。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些面向 <code>byte</code> 和 <code>rune</code> 的读写操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadByte() (c <span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ByteScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    ByteReader</span><br><span class="line">    UnreadByte() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ByteWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteByte(c <span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RuneReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadRune() (r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RuneScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    RuneReader</span><br><span class="line">    UnreadRune() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Scanner</code> 允许把一个读出的字节重新放回流中。这个操作有点类似 Peek 但是比 Peek 别扭一些。这种操作在做词法分析器的时候很有用。</p><p>下面是一些这些 interface 的实现。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>使用 <code>os.Open</code>、<code>os.OpenFile</code> 可以打开一个文件进行读写。它返回一个 <code>*os.File</code> 结构体，这个结构体实现了上面除了杂项外的接口。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>使用 <code>os.Pipe</code> 可以创建一个操作系统提供的管道（参见 unix 管道）。这个函数也是返回一个 <code>*os.File</code> 结构体。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><code>net.Conn</code> 是个 interface，他也实现了 <code>io.Reader</code>、<code>io.Writer</code>、<code>io.Closer</code> 这三个接口。</p><h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>有时候我们需要把一段内存当作流来处理，我们把这种设施叫做内存流。内存流在某些情况下非常有用。</p><h3 id="不阻塞的内存流"><a href="#不阻塞的内存流" class="headerlink" title="不阻塞的内存流"></a>不阻塞的内存流</h3><p>在 <code>strings</code> 包中，<code>strings.Reader</code> 实现了 <code>io.Reader</code> 、 <code>io.Seeker</code>、<code>io.ReaderAt</code>、<code>io.WriterTo</code>、<code>io.ByteScanner</code>、<code>io.RuneScanner</code> 这些接口。</p><p>可以将一个字符串当作一个<strong>只读流</strong>来使用。</p><p><code>bytes</code> 包中提供了一个比 <code>strings.Reader</code> 更高级的内存流－－ <code>bytes.Buffer</code>。它支持<strong>读写</strong>操作，同时还可以讲写入的数据转换成字符串来使用。这个结构体一般会被当做 golang 中的 StringBuilder 使用。</p><p>另外，如果需要将 []byte 转换为只读流，可以使用 <code>bytes.Reader</code> 它和 <code>strings.Reader</code> 类似。当数据只需要进行读操作时，使用这两个 Reader 会比 Buffer 要高效一些。</p><p>这些内存流都是非阻塞的，如果内存中没有数据了，会立即返回一个 EOF 错误。</p><h3 id="阻塞的内存流"><a href="#阻塞的内存流" class="headerlink" title="阻塞的内存流"></a>阻塞的内存流</h3><p>有时我们需要一个可以阻塞的内存流。当 buffer 中无数据的时候，Read 操作会被阻塞住；当 buffer 满时，Write 操作也会阻塞。</p><p><code>io.Pipe</code> 提供了这个功能。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span> <span class="params">(*PipeReader, *PipeWriter)</span></span></span><br></pre></td></tr></table></figure><p>使用 <code>io.Pipe</code> 函数创建一对 pipe，对 PipeReader 进行读操作，对<br>PipeWriter 进行写操作。</p><h2 id="杂七杂八的功能"><a href="#杂七杂八的功能" class="headerlink" title="杂七杂八的功能"></a>杂七杂八的功能</h2><p><code>io.LimitReader</code> 函数可以限制一个 Reader 的读取字节数</p><p><code>io.TeeReader</code> 可以在你读一个 Reader 的同时，将数据写入到一个 Writer 中：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teeExample</span><span class="params">(input io.Reader)</span></span> &#123;</span><br><span class="line">    backup := os.Create(<span class="string">"xxx.log"</span>)</span><br><span class="line">    r := io.TeeReader(input, backup)</span><br><span class="line">    fmt.Println(io.ReadAll(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子可以将 input 的内容同时写到 console 和 xxx.log 文件中。</p><p><code>io.MultiReader</code>、<code>io.MultiWriter</code> 函数可以将多个 Reader 或 Writer 合并成一个 Reader 或 Writer。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对 golang 标准库中的 stream 进行了一些总结。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; title=&quot;golang stream&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Interfaces&quot;&gt;&lt;a href=&quot;#Interfaces&quot; class=&quot;headerlink&quot; title=&quot;Interfaces&quot;&gt;&lt;/a&gt;Interfaces&lt;/h2&gt;&lt;p&gt;在 golang 中，通过几个基本的 interface 对流操作进行了抽象。&lt;/p&gt;
&lt;h3 id=&quot;读写&quot;&gt;&lt;a href=&quot;#读写&quot; class=&quot;headerlink&quot; title=&quot;读写&quot;&gt;&lt;/a&gt;读写&lt;/h3&gt;&lt;p&gt;首先是最基本的Reader、Writer，定义了对于一个流来说最基本的操作：&lt;strong&gt;读、写&lt;/strong&gt;。这两个 interface 定义在 &lt;code&gt;io&lt;/code&gt; 包里。&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Reader &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Read(p []&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;) (n &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Writer &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Write(p []&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;) (n &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="标准库" scheme="https://lengzzz.com/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
      <category term="golang" scheme="https://lengzzz.com/tags/golang/"/>
    
      <category term="stream" scheme="https://lengzzz.com/tags/stream/"/>
    
      <category term="io" scheme="https://lengzzz.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>并发难 | 池里究竟该放多少线程？</title>
    <link href="https://lengzzz.com/2016/07/08/%E5%B9%B6%E5%8F%91%E9%9A%BE|%E6%B1%A0%E9%87%8C%E7%A9%B6%E7%AB%9F%E8%AF%A5%E6%94%BE%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F/"/>
    <id>https://lengzzz.com/2016/07/08/%E5%B9%B6%E5%8F%91%E9%9A%BE|%E6%B1%A0%E9%87%8C%E7%A9%B6%E7%AB%9F%E8%AF%A5%E6%94%BE%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F/</id>
    <published>2016-07-08T06:29:46.000Z</published>
    <updated>2018-02-01T01:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目里做了一个数据同步的功能。需要把两个数据库里的数据做同步，在业务不繁忙的时候跑一次，核对库里每一条数据，主要是为了保证<strong>数据最终一致</strong>，做的一个保底工作。之前项目里同步的代码是单线程的，我改成了基于线程池的，但是在上线前的一些问题却引起了我的思考。</p><p><a href="/notename/" title="concurrency roadblock how many threads should be in pool"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>程序的代码还是比较简单的，大概类似下面：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数分别为线程数量和总任务数</span></span><br><span class="line">p := pool.NewPool(goroutineCount, <span class="built_in">len</span>(userIds))</span><br><span class="line"><span class="keyword">for</span> _, userId := <span class="keyword">range</span> userIds &#123;</span><br><span class="line">p.Queue(<span class="function"><span class="keyword">func</span><span class="params">(job *pool.Job)</span></span> &#123;</span><br><span class="line">userId := job.Params()[<span class="number">0</span>].(<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line">tx, err := sess.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tx.RollbackUnlessCommitted()</span><br><span class="line"><span class="keyword">if</span> err := dao.SyncSingleUser(tx, userId); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := tx.Commit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, userId)</span><br><span class="line">&#125;</span><br><span class="line">errOccurs := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> p.Results() &#123;</span><br><span class="line"><span class="keyword">if</span> err, ok := result.(*pool.ErrRecovery); ok &#123;</span><br><span class="line">glog.Errorln(err)</span><br><span class="line">errOccurs = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> errOccurs &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确定线程的数量，我逐步增加线程数记录系统各项数值。下面是在一台 RMBP 上做的测试。</p><p>| T | QPS | CPU | DBCPU |<br>|  |  |  |  | |<br>| 1 | 9000 | 37 | 81 |<br>| 2 | 14000 | 60 | 150 |<br>| 3 | 15500 | 70 | 195 |<br>| 4 | 16500 | 90 | 260 |</p><p>可以发现随着线程数增加，性能会逐步提高，但是当线程数提高到一定程度之后，性能不增反降（这部分数据没放）。如果继续增加线程数进行测试，会发现系统的某些性能指标会被耗尽，程序开始报错。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recovering <span class="keyword">from</span> panic: dial tcp <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>: getsockopt: operation timed <span class="keyword">out</span></span><br></pre></td></tr></table></figure><p>为什么会出现这种情况呢？在讨论这些问题之前，先回顾一下 goroutine 的设计与实现。</p><h2 id="goroutine-设计"><a href="#goroutine-设计" class="headerlink" title="goroutine 设计"></a>goroutine 设计</h2><p>事实上，在 golang 中的 goroutine 已经不是传统意义上的线程了。传统的操作系统提供的线程在使用时有一些限制，超过一定数量之后会对性能造成影响。而 golang 提供的 goroutine 是一种 green thread。</p><p>Green thread 和 NodeJS 的异步回调方案有类似的地方，都在底层调用的系统的异步 IO 系统调用。</p><ul><li>异步回调方案：所有 IO 操作的 API 都设计成异步回调形式，底层调用异步的系统调用（如epool、kqueue等）。同时，也可能提供同步版本的 IO 操作（如fs.readFileSync）</li><li>Green thread 方案：所有 IO 操作底层实际上事异步调用，但是在语言中却表现的像一个同步调用。当 IO 操作需要等待时，语言的 runtime 自动调度系统级线程到另一个 Green thread 中。写代码的时候感觉好像是同步的，仿佛在同一个线程完成的，但实际上系统可能切换了线程，但程序对此无感。</li></ul><p>由此可见，Green thread 在语言设计上比异步回调方案要略胜一筹，不会出现“冲击波”的现象（具体在 NodeJS 中如何避免“冲击波”代码可以看我<a href="https://lengzzz.com/note/in-depth-analysis-of-await-and-async">这篇文章<small>await &amp; async 深度剖析</small></a>），但在性能上实际是差不多的，都避免了大量使用操作系统级的线程带来的性能问题，同时又能充分的利用 CPU。</p><p>但是，今天我想谈的问题并不是 CPU 利用率／线程数量的问题，这个问题已经被上述两种设计方案比较完美的解决了。</p><h2 id="CPU-以外的资源瓶颈"><a href="#CPU-以外的资源瓶颈" class="headerlink" title="CPU 以外的资源瓶颈"></a>CPU 以外的资源瓶颈</h2><p>在实际中，更多遇到的是 cpu ／线程数量之外的资源瓶颈。比如锁、数据库链接、tcp链接。举个例子，假如做个爬虫应用，每个 goroutine 爬一个网页，golang 虽然号称百万级别的 goroutine ，但是你每个 goroutine 里面创建一个 tcp 链接，不到 5 万个 goroutine 就会把系统的 tcp 资源耗尽。</p><p>回到文章最上面的情况，在 goroutine 里调用了 <code>dao.SyncSingleUser</code> 函数，这个是一个数据库操作，不可避免的会有 socket 操作、硬盘操作。如果将所有数据库操作都无脑的放到 goroutine 中执行，当资源出现瓶颈之后，大量 goroutine 会阻塞或报错。</p><p>因此，我在项目里使用了一个 goroutine 池，来确保不会过多使用系统资源导致崩溃。那么问题来了，<strong>池里究竟该放多少线程</strong>？</p><p>又回到了最初使用系统线程时遇到的问题，不过这次导致问题的不再是线程资源，而是其他资源瓶颈（如 tcp、数据库链接 等）。这些资源比线程资源更加复杂，更加难以把控。更加难做 benchmark，也就更难找出一个通用的方法来解决实际场景的问题。</p><h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>思考过后，我在网上开始搜索解决方案。发现这篇文章的作者和我做了类似的思考：<a href="http://jolestar.com/parallel-programming-model-thread-goroutine-actor/" target="_blank" rel="noopener">《并发之痛 Thread，Goroutine，Actor》</a>。作者最后得出 Actor 模型能解决一些问题（不过我才疏学浅至今不怎么理解 Actor 模型），但并发带来的问题还远远没到解决的程度。</p><blockquote><p><em>革命尚未成功 同志任需努力</em></p></blockquote><p>所以说，<strong>软件工程没有银弹</strong>，路漫漫其修远兮，吾将上下而求索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在项目里做了一个数据同步的功能。需要把两个数据库里的数据做同步，在业务不繁忙的时候跑一次，核对库里每一条数据，主要是为了保证&lt;strong&gt;数据最终一致&lt;/strong&gt;，做的一个保底工作。之前项目里同步的代码是单线程的，我改成了基于线程池的，但是在上线前的一些问题却引
      
    
    </summary>
    
    
    
      <category term="并发" scheme="https://lengzzz.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="思考" scheme="https://lengzzz.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>golang 垃圾回收机制</title>
    <link href="https://lengzzz.com/2016/06/22/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://lengzzz.com/2016/06/22/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2016-06-22T07:22:16.000Z</published>
    <updated>2019-07-20T09:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>用任何带 GC 的语言最后都要直面 GC 问题。在以前学习 C# 的时候就被迫读了一大堆 .NET Garbage Collection 的文档。最近也学习了一番 golang 的垃圾回收机制，在这里记录一下。</p><p><a href="/notename/" title="gc in golang"></a></p><h2 id="常见-GC-算法"><a href="#常见-GC-算法" class="headerlink" title="常见 GC 算法"></a>常见 GC 算法</h2><p>趁着这个机会我总结了一下常见的 GC 算法。分别是：<strong>引用计数法</strong>、<strong>Mark-Sweep法</strong>、<strong>三色标记法</strong>、<strong>分代收集法</strong>。</p><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>原理是在每个对象内部维护一个整数值，叫做这个对象的<strong>引用计数</strong>，当对象被引用时引用计数加一，当对象不被引用时引用计数减一。当引用计数为 0 时，自动销毁对象。</p><p>目前引用计数法主要用在 c++ 标准库的 std::shared_ptr 、微软的 COM 、Objective-C 和 PHP 中。</p><p>但是引用计数法有个缺陷就是不能解决循环引用的问题。循环引用是指对象 A 和对象 B 互相持有对方的引用。这样两个对象的引用计数都不是 0 ，因此永远不能被收集。</p><p>另外的缺陷是，每次对象的赋值都要将引用计数加一，增加了消耗。</p><h3 id="2-Mark-Sweep法（标记清除法）"><a href="#2-Mark-Sweep法（标记清除法）" class="headerlink" title="2. Mark-Sweep法（标记清除法）"></a>2. Mark-Sweep法（标记清除法）</h3><p>这个算法分为两步，标记和清除。</p><ul><li>标记：从程序的根节点开始， <strong>递归地</strong> 遍历所有对象，将能遍历到的对象打上标记。</li><li>清除：讲所有未标记的的对象当作垃圾销毁。</li></ul><center>![Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif-143.9kB][1]<small>图片来自 https://en.wikipedia.org/wiki/Tracing_garbage_collection </small></center><p>如图所示。</p><p>但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。</p><p>当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。</p><p>golang 1.5以前使用的这个算法。</p><h3 id="3-三色标记法"><a href="#3-三色标记法" class="headerlink" title="3. 三色标记法"></a>3. 三色标记法</h3><p>三色标记法是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法。</p><p>原理如下，</p><ol><li>首先创建三个集合：白、灰、黑。</li><li>将所有对象放入白色集合中。</li><li>然后从根节点开始遍历所有对象（注意这里<strong>并不递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。</li><li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li><li>重复 4 直到灰色中无任何对象</li><li>通过write-barrier检测对象有变化，重复以上操作</li><li>收集所有白色对象（垃圾）</li></ol><center>![Animation_of_tri-color_garbage_collection.gif-94kB][2]<small>图片来自 https://en.wikipedia.org/wiki/Tracing_garbage_collection </small></center><p>过程如上图所示。</p><p>这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。</p><p>但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。</p><p>使用这种算法的是 Go 1.5、Go 1.6。</p><h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>分代收集也是传统 Mark-Sweep 的一个改进。这个算法是基于一个经验：绝大多数对象的生命周期都很短。所以按照对象的生命周期长短来进行分代。</p><p>一般 GC 都会分三代，在 java 中称之为新生代（Young Generation）、年老代（Tenured Generation）和永久代（Permanent Generation）；在 .NET 中称之为第 0 代、第 1 代和第2代。</p><p>原理如下：</p><ul><li>新对象放入第 0 代</li><li>当内存用量超过一个较小的阈值时，触发 0 代收集</li><li>第 0 代幸存的对象（未被收集）放入第 1 代</li><li>只有当内存用量超过一个较高的阈值时，才会触发 1 代收集</li><li>2 代同理</li></ul><p>因为 0 代中的对象十分少，所以每次收集时遍历都会非常快（比 1 代收集快几个数量级）。只有内存消耗过于大的时候才会触发较慢的 1 代和 2 代收集。</p><p>因此，分代收集是目前比较好的垃圾回收方式。使用的语言（平台）有 jvm、.NET 。</p><h2 id="golang-的-GC"><a href="#golang-的-GC" class="headerlink" title="golang 的 GC"></a>golang 的 GC</h2><p>go 语言在 1.3 以前，使用的是比较蠢的传统 Mark-Sweep 算法。</p><p>1.3 版本进行了一下改进，把 Sweep 改为了并行操作。</p><p>1.5 版本进行了较大改进，使用了三色标记算法。go 1.5 在源码中的解释是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”</p><p>go 除了标准的三色收集以外，还有一个辅助回收功能，防止垃圾产生过快手机不过来的情况。这部分代码在 <a href="https://golang.org/src/runtime/mgcmark.go#L316" target="_blank" rel="noopener"><code>runtime.gcAssistAlloc</code></a> 中。</p><p>但是 golang 并没有分代收集，所以对于巨量的小对象还是很苦手的，会导致整个 mark 过程十分长，在某些极端情况下，甚至会导致 GC 线程占据 50% 以上的 CPU。</p><p>因此，当程序由于高并发等原因造成大量小对象的gc问题时，最好可以使用 <a href="https://golang.org/pkg/sync/#Pool" target="_blank" rel="noopener"><code>sync.Pool</code></a> 等对象池技术，避免大量小对象加大 GC 压力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用任何带 GC 的语言最后都要直面 GC 问题。在以前学习 C# 的时候就被迫读了一大堆 .NET Garbage Collection 的文档。最近也学习了一番 golang 的垃圾回收机制，在这里记录一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; tit
      
    
    </summary>
    
    
    
      <category term="golang" scheme="https://lengzzz.com/tags/golang/"/>
    
      <category term="GC" scheme="https://lengzzz.com/tags/GC/"/>
    
      <category term="垃圾回收" scheme="https://lengzzz.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>高可用可伸缩架构</title>
    <link href="https://lengzzz.com/2016/06/21/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%9E%B6%E6%9E%84/"/>
    <id>https://lengzzz.com/2016/06/21/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%9E%B6%E6%9E%84/</id>
    <published>2016-06-21T05:39:33.000Z</published>
    <updated>2016-06-21T10:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读一本书《大型网站技术架构》，收获颇多。这篇文章是对最近学习的一些总结，大多是一些结论性的内容，可以拿来就用的东西，对于大部分企业都比较适用。注意这些内容并不是我自己发明的，而是业界多年来的经验总结出的结论。</p><p><a href="/notename/" title="high availability scalable architecture"></a></p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="1-性能测试"><a href="#1-性能测试" class="headerlink" title="1. 性能测试"></a>1. 性能测试</h3><p>保证网站高性能的前提是做性能测试，如果连网站的性能指标都不知道，怎么判断一个网站“慢不慢”和“高性能”呢。</p><p>对一个网站做性能测试时，主要需要测试一下几项数据：</p><ul><li>并发数</li><li>响应时间</li><li>吞吐量（TPS，每秒事物数）</li><li>资源消耗（主要指cpu、内存消耗）</li></ul><p>在做性能测试时，一般以并发数为自变量，逐步提高并发数，每次记录上述四个指标，制作出一张表格以方便后面进行分析。</p><p>例子如下：</p><table><thead><tr><th>并发数</th><th>响应时间</th><th>TPS</th><th>出错率</th><th>CPU</th><th>内存</th><th>备注</th></tr></thead><tbody><tr><td>100</td><td>10ms</td><td>200</td><td>0%</td><td>5%</td><td>200MiB</td><td>性能测试</td></tr><tr><td>200</td><td>15ms</td><td>266</td><td>0%</td><td>10%</td><td>300MiB</td><td>性能测试</td></tr><tr><td>300</td><td>20ms</td><td>300</td><td>2%</td><td>15%</td><td>400MiB</td><td>性能测试</td></tr><tr><td>400</td><td>50ms</td><td>330</td><td>20%</td><td>35%</td><td>600MiB</td><td>负载测试</td></tr><tr><td>500</td><td>100ms</td><td>350</td><td>25%</td><td>40%</td><td>800MiB</td><td>负载测试</td></tr><tr><td>600</td><td>500ms</td><td>360</td><td>30%</td><td>50%</td><td>1.0GiB</td><td>压力测试</td></tr><tr><td>700</td><td>1200ms</td><td>350</td><td>50%</td><td>60%</td><td>1.5GiB</td><td>压力测试</td></tr><tr><td>800</td><td>timeout</td><td>0</td><td>100%</td><td>N/A</td><td>N/A</td><td>压力测试</td></tr></tbody></table><p>看表格不是很直观，我简单解释一下。这个测试大致分为三个stage：<strong>性能测试</strong>、<strong>负载测试</strong>、<strong>压力测试</strong>。</p><ul><li>性能测试：网站正常运行的状态。随着并发数量的增大，响应时间不会有很大的变化；吞吐量和资源消耗基本上时线性正相关。</li><li>负载测试：网站某项或多项性能指标已达到临界值。此时增大并发数量响应时间已经有明显的影响；资源消耗增大而吞吐量不会有太大变化。</li><li>压力测试：已超出安全负载。此时响应延迟明显增大；资源消耗越来越多而系统吞吐量不增反降。继续增大负载，系统将崩溃，不能接受任何请求。</li></ul><p>分别以 “资源消耗” 为横轴、TPS 为纵轴画出函数图像可以更直观的观察两者之间的关系。</p><center>![QQ20160621-0@2x.png-76.3kB][1]</center><p>分别以 “并发数” 为横轴、“响应时间” 为纵轴，观察两者关系。</p><center>![QQ20160621-1@2x.png-84.2kB][2]</center><p>通过以上分析，判断一个网站是否高性能，可以通过并发数来做基本的判断。更准确的应当通过上图中的b点处（系统最佳运行点）的并发数量来判断网站性能。</p><h3 id="2-前端性能优化"><a href="#2-前端性能优化" class="headerlink" title="2. 前端性能优化"></a>2. 前端性能优化</h3><p>这部分和我们讨论的网站架构关系不大，对于后端开发者来说需要注意的点有：使用CDN、注意开启浏览器缓存、合并JS减少HTTP请求等等，主要还是靠前端工程师的努力啦。</p><h3 id="3-应用性能优化"><a href="#3-应用性能优化" class="headerlink" title="3. 应用性能优化"></a>3. 应用性能优化</h3><p>对于应用层的性能优化主要有三种方法：<strong>加缓存</strong>、<strong>使用异步操作</strong>、<strong>应用集群化</strong>。这三者越靠前者越应当优先使用，效果越好，对系统影响越小。</p><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><p>有一位计算机科学家曾说“缓存是最伟大的发明”，在系统中使用缓存可以挡住大部分请求从而可以不访问数据库。但是并不是说缓存可以在任何地方使用（滥用）。使用缓存有以下原则。</p><ul><li>不应缓存频繁更改的数据。一般来说，缓存是被用来读的，如果一个缓存刚刚写入没过过久又被修改了，这样毫无意义。最好的情况是，缓存写入后被读了成千上万次。</li><li>应缓存热点数据。缓存使用内存存储，如果将不频繁访问的数据放入缓存的话太浪费内存空间。</li><li>注意数据不一致问题。缓存一般设置超时时间，当用户修改了数据后缓存不一定能及时更新。应根据业务合理设置超时时间。</li><li>注意缓存可用性问题。应妥善结果缓存挂了的情况，因为数据库已经习惯了有缓存的“舒适”的日子，一旦缓存挂了之后数据库压力山大而宕机导致网站整体不可用。</li><li>应进行缓存预热。当换上一台新缓存服务器后不应立即撤掉老的缓存服务器，因为新机器内部还没有任何数据，大部分访问还是会打到数据库。所以新的缓存服务器启动时最好将热点数据提前载入进行预热。</li></ul><p>具体在使用缓存时可以使用业界通用的开源缓存系统，如redis、memcached、jboss cache等。</p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>网站一些操作可以不直接访问数据库，而是将任务放入消息队列异步化。是用另一台 consumer 服务器从消息队列中取出任务进行数据库访问。</p><p>这样可以有效的起到“削峰”作用。经常用于应对突然增加的并发数，比如在抢购系统中，在前几分钟会接到很多请求，将这些请求放入消息队列中逐个处理，当处理结束后再使用 websocket 等通知方式告知用户是否抢购到商品。</p><center>![QQ20160621-2@2x.png-60.3kB][3]</center><h4 id="应用集群化"><a href="#应用集群化" class="headerlink" title="应用集群化"></a>应用集群化</h4><p>使用负载均衡技术，在网站入口搭建一台负载均衡服务器（如nginx），入口后搭建一个应用服务器集群，当接收到请求后，负载均衡服务器使用一定算法将请求平均的打到不同的应用服务器上。</p><p>这样，比如应用集群有10台机器，那么理想状态下每台机器的负载只有总负载的 1/10 。</p><h3 id="4-存储性能优化"><a href="#4-存储性能优化" class="headerlink" title="4. 存储性能优化"></a>4. 存储性能优化</h3><p>先略过不表</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>可用性指网站的故障情况。网站的故障时间越短，故障范围越小说明网站可用性越高。对于网站提高网站的可用性，需要从四方面入手：负载均衡（入口）、应用、缓存、数据库。</p><h3 id="1-入口层"><a href="#1-入口层" class="headerlink" title="1. 入口层"></a>1. 入口层</h3><p>需要在 nginx 挂了之后还有机器能顶上。可使用的技术有 VRRP，具体说来就是当一台机器挂了之后，另一台机器检测到了之后立即把自己的IP地址设置为原有机器的IP地址。通过这种抢地址的方式来接管新的请求。</p><h3 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h3><p>应用层做到高可用的方式就是“集群化”。部署多台应用服务器，对于负载均衡来说每台业务服务器都是一样的，当一台机器挂了之后将请求打到其他机器上就好了。</p><p>做应用集群化的核心就是“业务层不要有状态”。将状态保存到缓存层和数据库中。以下几点是大家常犯的错误：</p><ul><li>session数据，很多语言都自带了 session 功能（如php）。这样不利于集群化，所以在写代码时应注意不要使用语言自带的 session 系统，最好将 session 数据存储到缓存层、另外也可以使用 CookieSession ，将 session 加密存储在客户端。</li><li>缓存，很多程序员喜欢在业务层使用一个全局的 map 缓存一些数据，这样就不必频繁访问数据库了，但是在使用集群时很容易造成不同机器上的缓存数据不一致的问题。这样从缓存拿到的数据就是错误的。</li><li>全局变量。写代码时不要使用全局变量。</li></ul><h3 id="3-缓存层"><a href="#3-缓存层" class="headerlink" title="3. 缓存层"></a>3. 缓存层</h3><p>现在普遍使用缓存，因为缓存可以替 mysql 挡住大部分请求。所以这种情况下，整个系统都过于依赖缓存层。因为一旦缓存不可用之后，所有的请求都打到数据库上，导致数据库压力过大。</p><p>因此，保证缓存层高可用也是必要的了。达到缓存层高可用的方式也是集群化，将缓存分的细一些，不同的数据存储到不同的 cache 中。这样某一个 cache 宕机之后不至于太过严重。</p><h3 id="4-数据层"><a href="#4-数据层" class="headerlink" title="4. 数据层"></a>4. 数据层</h3><p>数据层有一个经典的原理，叫做 CAP 原理。CAP 分别指：一致性（ <strong>C</strong> onsistency)、可用性（<strong>A</strong> vailibility）、分区耐受性（<strong>P</strong> atition Tolerance）。</p><p>CAP 原理认为，一个数据服务通常无法同时做到以上三点。所以一般情况下网站会舍弃一致性，而达到可用性和分区耐受性（既可伸缩性）。</p><p>数据层做高可用的主要技术是：数据备份。</p><p>数据备份主要分为：热备、冷备。</p><p>冷备指定期对数据库进行备份，如果发现数据库出错了会滚到上一个备份。这种方式其实做不到数据最终一致。</p><p>热备主要分为同步热备和异步热备。</p><ul><li>同步热备指同时开两个数据库，应用在读写时同时对两个数据库进行操作，这样当一个数据库宕机之后另一个数据库中还保存完整数据。</li><li>异步热备一般指 Master-Slave 模式，应用只对 master 进行写入操作，master 会随后将数据同步到 slave 中。</li></ul><center>![QQ20160621-3@2x.png-116.2kB][4]</center><p>这两种功能 mysql 都有实现。</p><h2 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h2><p>可伸缩性指当业务达到负载上限时，可通过简单的增加机器的方式提高系统的负载能力。</p><h3 id="1-入口层-1"><a href="#1-入口层-1" class="headerlink" title="1. 入口层"></a>1. 入口层</h3><p>可以通过 DNS 来实现，目前 DNS 服务器会使用轮转算法返回 IP 地址，这样就可以把请求分配到不同的负载均衡上。</p><h3 id="2-应用层-1"><a href="#2-应用层-1" class="headerlink" title="2. 应用层"></a>2. 应用层</h3><p>其实应用层做到可伸缩性和高可用的解决方案一致，都是集群化，核心都是保证应用无状态。</p><h3 id="3-缓存层-1"><a href="#3-缓存层-1" class="headerlink" title="3. 缓存层"></a>3. 缓存层</h3><p>缓存要保证水平扩展的同时不增加额外的消耗需要一些技术。常见的技术是一致性 HASH。可以保证水平扩展后较少的数据失效。</p><center>![QQ20160621-4@2x.png-115.8kB][5]</center><h3 id="4-数据层-1"><a href="#4-数据层-1" class="headerlink" title="4. 数据层"></a>4. 数据层</h3><p>数据库层做可伸缩的话常用的技术就是分库、分表。</p><p>书中也介绍了一些开源的技术如 Cobar 之类的，不过我没有去深入研究。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网上找了张图，总结的不错。</p><p><img src="/images/56d5977b5a4140ed3f59db7c5aed710c.png" alt="高可用可伸缩.png-27.5kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在读一本书《大型网站技术架构》，收获颇多。这篇文章是对最近学习的一些总结，大多是一些结论性的内容，可以拿来就用的东西，对于大部分企业都比较适用。注意这些内容并不是我自己发明的，而是业界多年来的经验总结出的结论。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/notename/&quot; t
      
    
    </summary>
    
    
    
      <category term="架构" scheme="https://lengzzz.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="高可用" scheme="https://lengzzz.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="可伸缩" scheme="https://lengzzz.com/tags/%E5%8F%AF%E4%BC%B8%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>跨源 HTTP 请求（CORS）</title>
    <link href="https://lengzzz.com/2016/06/13/%E8%B7%A8%E6%BA%90HTTP%E8%AF%B7%E6%B1%82%EF%BC%88CORS%EF%BC%89/"/>
    <id>https://lengzzz.com/2016/06/13/%E8%B7%A8%E6%BA%90HTTP%E8%AF%B7%E6%B1%82%EF%BC%88CORS%EF%BC%89/</id>
    <published>2016-06-13T06:37:05.000Z</published>
    <updated>2016-06-13T07:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直对跨域问题一知半解，今天看了些资料<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">^cors</a>总算把所有情况搞明白了。总的来说跨域请求分为两种：简单请求和复杂请求，下面来详细说明。</p><p><a href="/notename/" title="cross origin http request"></a></p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>简单请求是指：</p><ul><li>只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型 (Content-Type，<strong>注意是 request 的 Content-Type</strong>) 只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</li><li>不会使用自定义请求头（类似于 X-Modified 这种）。</li></ul><p>当浏览器遇到这种请求时，会直接向服务器发送请求，但是在把结果返回给JS代码前会做一次检查。浏览器会查看 response header 中是否有 <code>Access-Control-Allow-Origin</code> 这个 header 。如果有且允许当前 Origin 访问的话，才会真正将结果返回给 JS 程序。</p><h2 id="复杂请求和预请求"><a href="#复杂请求和预请求" class="headerlink" title="复杂请求和预请求"></a>复杂请求和预请求</h2><p>如果一个 Ajax 请求不是上面所说的那种。比如使用 POST 方法并且 Content-Type 是 application/json。那么浏览器则不会直接发送这个 HTTP 请求，而是先发送一个预请求。</p><p>预请求使用 OPTION 方法发送，并且带上 <code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Headers</code> 等 header。</p><p>举例说明：</p><p>在 a.com 下使用 POST 请求 b.com/user ，数据类型是 application/json ，并且使用了私有 header ：x-token</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/user</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: b.com</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span>: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Origin</span>: http://a.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-TOKEN</span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: POST, GET, PUT, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-TOKEN</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding, Origin</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>这个 OPTION 请求类似一个询问，他会询问服务器是否支持用户的请求，服务器应当返回他所支持的请求。当进行了 OPTION 请求之后，浏览器进行判断此次请求是否合法，如果合法的话才会发起真正的 HTTP 请求。</p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>默认情况下跨域请求是不带 Cookies 的，如果需要 Cookies 的话，在客户端需要将 XMLHttpRequest 对象的 withCredentials 设置为 true 。同时，服务器也应当做相应调整。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>; <span class="comment">// 设置 withCredentials 为 true</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>服务器应当返回 <code>Access-Control-Allow-Credentials: true</code> ，否则浏览器不会将结果返回给 JS 程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，为了实现安全的跨域 Ajax 请求。会对 ajax 做一下检查。对于简单的请求，浏览器会直接发送请求，然后对结果进行检查；对于复杂请求，会首先发送一个预请求进行检查，检查通过之后才发送真正的请求。</p><p>为了实现检查的目的，在 HTTP 协议中新增了如下几个请求头和响应头。</p><h3 id="请求头（request-header）"><a href="#请求头（request-header）" class="headerlink" title="请求头（request header）"></a>请求头（request header）</h3><ul><li>Origin：用于表明此请求来自哪个源</li><li>Access-Control-Request-Method：用于表明此次请求需要使用哪个方法</li><li>Access-Control-Request-Headers：用于表明此次请求需要哪些自定义头</li></ul><h3 id="响应头（response-header）"><a href="#响应头（response-header）" class="headerlink" title="响应头（response header）"></a>响应头（response header）</h3><ul><li>Access-Control-Allow-Origin：用于表明此资源允许哪些源访问</li><li>Access-Control-Expose-Headers：用于表明此资源会返回哪些自定义响应头</li><li>Access-Control-Max-Age：用于表明此次预请求的有效期（秒）</li><li>Access-Control-Allow-Credentials：用于表明此资源允许使用 Cookies</li><li>Access-Control-Allow-Methods：用于表明此资源允许哪些方法</li><li>Access-Control-Allow-Headers：用于表明此资源允许哪些自定义请求头</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直对跨域问题一知半解，今天看了些资料&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;^cors
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="https://lengzzz.com/tags/HTTP/"/>
    
      <category term="CORS" scheme="https://lengzzz.com/tags/CORS/"/>
    
      <category term="跨域" scheme="https://lengzzz.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>是时候用 apt 代替 apt-get 了！</title>
    <link href="https://lengzzz.com/2016/05/28/%E6%98%AF%E6%97%B6%E5%80%99%E7%94%A8apt%E4%BB%A3%E6%9B%BFapt-get%E4%BA%86%EF%BC%81/"/>
    <id>https://lengzzz.com/2016/05/28/%E6%98%AF%E6%97%B6%E5%80%99%E7%94%A8apt%E4%BB%A3%E6%9B%BFapt-get%E4%BA%86%EF%BC%81/</id>
    <published>2016-05-28T01:51:48.000Z</published>
    <updated>2016-05-28T02:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近无痛升级了 ubuntu 16.04 ，软件包和数据一点没丢。比上次 12.04 升级 14.04 舒服多了，直接 ssh 就搞定升级了。不得不说 ubuntu 已经成熟很多了。升级后我才发现多了个 <code>apt</code> 命令，用起来很符合我的审美，不过这个东西好像也存在比较久的一段时间了，实在是后知后觉了。</p><p><a href="/notename/" title="it is time to replace apt-get with apt"></a></p><p>apt 这个命令行工具在功能上基本涵盖了以前 apt-get 和 apt-cache 的功能，在他们之上提供了一个 high-level 的命令行界面，而且也更有交互性。</p><p><img src="/images/78febf75a690a0a0b38c17a8c046defe.png" alt="image_1ajqh3qkm1kf81vb81kmtjldlipg.png-416.8kB"></p><p>在命令行下敲击 apt 后会打印出一些常见命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">zzz@ubuntu-server ~ $ apt</span><br><span class="line">apt 1.2.10 (amd64)</span><br><span class="line">用法： apt [选项] 命令</span><br><span class="line"></span><br><span class="line">命令行软件包管理器 apt 提供软件包搜索，管理和信息查询等功能。</span><br><span class="line">它提供的功能与其他 APT 工具相同（像 apt-<span class="builtin-name">get</span> 和 apt-cache），</span><br><span class="line">但是默认情况下被设置得更适合交互。</span><br><span class="line"></span><br><span class="line">常用命令：</span><br><span class="line">  list - 根据名称列出软件包</span><br><span class="line">  search - 搜索软件包描述</span><br><span class="line">  show - 显示软件包细节</span><br><span class="line">  install - 安装软件包</span><br><span class="line">  <span class="builtin-name">remove</span> - 移除软件包</span><br><span class="line">  autoremove - 卸载所有自动安装且不再使用的软件包</span><br><span class="line">  update - 更新可用软件包列表</span><br><span class="line"> <span class="built_in"> upgrade </span>- 通过 安装/升级 软件来更新系统</span><br><span class="line">  full-upgrade - 通过 卸载/安装/升级 来更新系统</span><br><span class="line">  edit-sources - 编辑软件源信息文件</span><br><span class="line"></span><br><span class="line">参见 apt(8) 以获取更多关于可用命令的信息。</span><br><span class="line">程序配置选项及语法都已经在 apt.conf(5) 中阐明。</span><br><span class="line">欲知如何配置软件源，请参阅 sources.list(5)。</span><br><span class="line">软件包及其版本偏好可以通过 apt_preferences(5) 来设置。</span><br><span class="line">关于安全方面的细节可以参考 apt-secure(8).</span><br><span class="line">                                         本 APT 具有超级牛力。</span><br></pre></td></tr></table></figure><p>虽然这个 <code>超级牛力</code> 是什么鬼我也不明白了。。。（莫非是 powered by GNU？）但是基本的使用介绍还是很清晰的。对于咱们普通用户来说，最明显的就是把 search 功能合并过来了。</p><p>另外，比较好用的一点是 list 命令。可以使用 <code>apt list --upgradable</code> 来查看需要升级的软件包，有点类似 <code>brew outdated</code> 。</p><p>还有一个 <code>apt show</code> 可以打印出软件包的基本信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zzz@ubuntu-server</span> <span class="string">~</span> <span class="string">$</span> <span class="string">apt</span> <span class="string">show</span> <span class="string">zsh</span></span><br><span class="line"><span class="attr">Package:</span> <span class="string">zsh</span></span><br><span class="line"><span class="attr">Version:</span> <span class="number">5.1</span><span class="number">.1</span><span class="string">-1ubuntu2</span></span><br><span class="line"><span class="attr">Priority:</span> <span class="string">optional</span></span><br><span class="line"><span class="attr">Section:</span> <span class="string">shells</span></span><br><span class="line"><span class="attr">Origin:</span> <span class="string">Ubuntu</span></span><br><span class="line"><span class="attr">Maintainer:</span> <span class="string">Ubuntu</span> <span class="string">Developers</span> <span class="string">&lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;</span></span><br><span class="line"><span class="attr">Original-Maintainer:</span> <span class="string">Debian</span> <span class="string">Zsh</span> <span class="string">Maintainers</span> <span class="string">&lt;pkg-zsh-devel@lists.alioth.debian.org&gt;</span></span><br><span class="line"><span class="attr">Bugs:</span> <span class="string">https://bugs.launchpad.net/ubuntu/+filebug</span></span><br><span class="line"><span class="attr">Installed-Size:</span> <span class="number">2</span><span class="string">,023</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Pre-Depends:</span> <span class="string">dpkg</span> <span class="string">(&gt;=</span> <span class="number">1.17</span><span class="number">.14</span><span class="string">)</span></span><br><span class="line"><span class="attr">Depends:</span> <span class="string">zsh-common</span> <span class="string">(=</span> <span class="number">5.1</span><span class="number">.1</span><span class="string">-1ubuntu2),</span> <span class="string">libc6</span> <span class="string">(&gt;=</span> <span class="number">2.15</span><span class="string">),</span> <span class="string">libcap2</span> <span class="string">(&gt;=</span> <span class="number">1</span><span class="string">:2.10),</span> <span class="string">libtinfo5</span> <span class="string">(&gt;=</span> <span class="number">6</span><span class="string">)</span></span><br><span class="line"><span class="attr">Recommends:</span> <span class="string">libncursesw5</span> <span class="string">(&gt;=</span> <span class="number">6</span><span class="string">),</span> <span class="string">libpcre3</span></span><br><span class="line"><span class="attr">Suggests:</span> <span class="string">zsh-doc</span></span><br><span class="line"><span class="attr">Homepage:</span> <span class="string">http://www.zsh.org/</span></span><br><span class="line"><span class="attr">Supported:</span> <span class="string">5y</span></span><br><span class="line"><span class="attr">Download-Size:</span> <span class="number">651</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">APT-Sources:</span> <span class="string">http://cn.archive.ubuntu.com/ubuntu</span> <span class="string">xenial/main</span> <span class="string">amd64</span> <span class="string">Packages</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">具有很多特性的</span> <span class="string">Shell</span></span><br><span class="line"> <span class="string">Zsh</span> <span class="string">是一个既可用作登录</span> <span class="string">Shell，又可用于执行脚本的命令解析器。</span> <span class="string">在标准</span> <span class="string">Shell</span> <span class="string">中</span> <span class="string">Zsh</span> <span class="string">与</span> <span class="string">Ksh</span></span><br><span class="line"> <span class="string">最相近，同时又带有许多改进。Zsh</span> <span class="string">支持命令行编辑，内置拼写纠正，支持可编程命令补全、带自动加载的</span> <span class="string">Shell</span> <span class="string">函数、历史功能和大量其他特性。</span></span><br></pre></td></tr></table></figure><p>总之就是各种命令清晰漂亮了很多，个人用起来很舒服。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近无痛升级了 ubuntu 16.04 ，软件包和数据一点没丢。比上次 12.04 升级 14.04 舒服多了，直接 ssh 就搞定升级了。不得不说 ubuntu 已经成熟很多了。升级后我才发现多了个 &lt;code&gt;apt&lt;/code&gt; 命令，用起来很符合我的审美，不过这个
      
    
    </summary>
    
    
    
      <category term="linux" scheme="https://lengzzz.com/tags/linux/"/>
    
      <category term="运维" scheme="https://lengzzz.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ubuntu" scheme="https://lengzzz.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>用 elasticsearch 给博客加上了搜索</title>
    <link href="https://lengzzz.com/2016/05/25/%E7%94%A8elasticsearch%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E4%BA%86%E6%90%9C%E7%B4%A2/"/>
    <id>https://lengzzz.com/2016/05/25/%E7%94%A8elasticsearch%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E4%BA%86%E6%90%9C%E7%B4%A2/</id>
    <published>2016-05-25T14:21:11.000Z</published>
    <updated>2017-08-20T07:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客从 Wordpress 迁移过来之后一直缺少一个搜索功能，这个博客我是当做笔记性质的，有时候脑子里突然想不起某个东西的时候就上来查一下。没有搜索还是很不方便的，所以费了点时间研究了下大名鼎鼎的 elasticsearch 配合 golang 给博客加上了搜索功能。</p><p><a href="/notename/" title="add internal search to your blog using elasticsearch"></a></p><h2 id="elasticsearch-介绍"><a href="#elasticsearch-介绍" class="headerlink" title="elasticsearch 介绍"></a>elasticsearch 介绍</h2><p>elasticsearch 是一个 java 编写的搜索和分析引擎，功能十分强大。但是并不意味着你的程序必须使用 java 开发，elasticsearch 是一个独立运行的程序，它会开放一个 RESTful 的接口供人调用，所以使用起来十分方便，甚至使用 curl 就能对它进行访问。另外，elasticsearch 的可伸缩性也很吸引我，使用 elasticsearch 组建一个集群十分方便，只需要把几个 elasticsearch 放到同一个局域网内就可以了，不用做任何配置你就能跑起来一个集群。这样，当你的数据量或者并发量增大的时候，只需要简单的购买几台新服务器就能解决性能问题。</p><p>我是通过 <a href="http://es.xiaoleilu.com/" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版）</a> 这本书来学习的，也推荐大家看一看，比我讲的好。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>elasticsearch 中有几个基本概念，大概可以和数据库的这几个概念对应起来（如下表）。但是有一点需要注意，elasticsearch 中不会限制数据必须存在一个二维表中，你可以保存一个对象，一个数组，一个字符串，或者一个整数，就像一个 JSON 一样，十分灵活。事实上，elasticsearch 的通讯协议确实是使用 JSON 的。</p><p>| 数据库 | elasticsearch |<br>|  |  |<br>| Databases | 索引（Indices） |<br>| Tables | 类型（Types） |<br>| Rows | 文档（Documents） |<br>| Columns | 字段（Fields） |<br>| schema | Mapping |</p><p>在 elasticsearch 中保存的每条记录叫一个 <code>document</code> ，它可以是一个包含很多字段的对象，默认情况下每个字段都能被搜索。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>使用 curl 就可以对 elasticsearch 进行操作，但是我还是推荐一个 chrome 应用 <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener" title="postman 的下载链接"><code>postman</code></a> ，有 JSON 语法高亮和检测，还可以保存历史记录。</p><p><img src="/images/e1cb8a757d384d5cc83ac6945bdeef0e.jpg" alt="90.pic_hd.jpg-1070kB"></p><h4 id="索引一条记录"><a href="#索引一条记录" class="headerlink" title="索引一条记录"></a>索引一条记录</h4><p>在 elasticsearch 中存储数据的行为叫做 <code>索引（index）</code> 。使用 HTTP 协议的 PUT 动词可以存储数据。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="symbol">http:</span>/<span class="regexp">/localhost:9200/mdblog</span><span class="regexp">/note/</span><span class="number">23432</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="string">"notename"</span>: <span class="string">"golang-china-download-mirror"</span>,</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"做了个 golang 安装包的镜像"</span>,</span><br><span class="line">    <span class="string">"content"</span>: <span class="string">"做了个 golang 安装包的镜像 闲扯 golang\n        \n        2016-05-25 16:04 PM\n    鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。地址在这里：https://lengzzz.com/download/golang/包含了 golang 1.5 之后的所有版本，所有平台的安装包和源码包都放在里面，自行 control + f 搜一下吧。新版本的 golang release 之后，应该在一两天内可以拉取过来。欢迎使用。"</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"2016-05-25T08:04:53Z"</span>,</span><br><span class="line">    <span class="string">"lastModified"</span>: <span class="string">"2016-05-25T09:01:42.923822162Z"</span>,</span><br><span class="line">    <span class="string">"tagList"</span>: [</span><br><span class="line">      <span class="string">"golang"</span>,</span><br><span class="line">      <span class="string">"闲扯"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上，把要存储的数据写成一个 JSON 对象，放到 HTTP 的 Body 中传送给 elasticsearch 即可存储数据。</p><p>我们可以看到 url 中包含了 4 部分的信息。</p><p>| 名字 | 信息 |<br>|  |  |<br>| localhost:9200 | Elasticsearch 的 url |<br>| mdblog | 索引名（Index） |<br>| note | 类型名（Type） |<br>| 23432 | 文档ID（Document ID） |</p><p>很方便吧。</p><h4 id="获取一条记录"><a href="#获取一条记录" class="headerlink" title="获取一条记录"></a>获取一条记录</h4><p>大家应当已经想到了，使用 GET 动词。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="regexp">//</span>localhost:<span class="number">9200</span><span class="regexp">/mdblog/</span>note<span class="regexp">/23432</span></span><br></pre></td></tr></table></figure><p>返回的信息会多一些 metadata 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"mdblog"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"note"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"389344"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">"notename"</span>: <span class="string">"golang-china-download-mirror"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"做了个 golang 安装包的镜像"</span>,</span><br><span class="line">    <span class="attr">"content"</span>: <span class="string">"做了个 golang 安装包的镜像 闲扯 golang\n        \n        2016-05-25 16:04 PM\n    鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。地址在这里：https://lengzzz.com/download/golang/包含了 golang 1.5 之后的所有版本，所有平台的安装包和源码包都放在里面，自行 control + f 搜一下吧。新版本的 golang release 之后，应该在一两天内可以拉取过来。欢迎使用。"</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2016-05-25T08:04:53Z"</span>,</span><br><span class="line">    <span class="attr">"lastModified"</span>: <span class="string">"2016-05-25T09:01:42.923822162Z"</span>,</span><br><span class="line">    <span class="attr">"tagList"</span>: [</span><br><span class="line">      <span class="string">"golang"</span>,</span><br><span class="line">      <span class="string">"闲扯"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>搜索的话可以使用 <code>查询 DSL</code> 进行，说是 DSL（领域特定语言） 听起来很吓人，实际上就是几个 JSON 对象的组合而已。</p><p>调用搜索接口需要在 url 后面加一个 <code>_search</code> 。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:<span class="number">9200</span>/mdblog/note/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : "<span class="type">linux</span><span class="string">"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这样，就可以使用 match 查询进行查询了。</p><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0.6609862</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"mdblog"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"note"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"340165"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">0.6609862</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="attr">"notename"</span>: <span class="string">"add-swap-on-linux"</span>,</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"在Linux下设置swap"</span>,</span><br><span class="line">          <span class="attr">"content"</span>: <span class="string">"在Linux下设置swap linux\n        \n        2016-04-10 15:53 PM\n    今早起来发现博客的数据库挂了，赶紧用手机上的ConnectBot连上去把mysql启动。看了下日志大概是因为内存不够用且没设置swap，所以mysql进程申请不到内存挂了（小内存服务器桑不起）所以赶紧把swap搞上，这样至少能让服务不轻易挂掉。这里记录一下，以备遗忘。大概分三步\n生成一个空文件\n把文件格式化成swap格式\n挂载\n"</span>,</span><br><span class="line">          <span class="attr">"timestamp"</span>: <span class="string">"2016-04-10T07:53:58Z"</span>,</span><br><span class="line">          <span class="attr">"lastModified"</span>: <span class="string">"2016-05-24T05:27:01.435772194Z"</span>,</span><br><span class="line">          <span class="attr">"tagList"</span>: [</span><br><span class="line">            <span class="string">"linux"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们可以为搜索加上高亮：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:<span class="number">9200</span>/mdblog/note/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : "<span class="type">linux</span><span class="string">"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "</span>highlight<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>pre_tags<span class="string">" : ["</span>&lt;b&gt;<span class="string">"],</span></span><br><span class="line"><span class="string">        "</span>post_tags<span class="string">" : ["</span>&lt;/b&gt;<span class="string">"],</span></span><br><span class="line"><span class="string">        "</span>fields<span class="string">" : &#123;</span></span><br><span class="line"><span class="string">            "</span>title<span class="string">" : &#123;&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这样的话，在 hit 中会有一个 <code>highlight</code> 字段，所有关键字会用 <code>&lt;b&gt;&lt;/b&gt;</code> 扩起来。</p><h4 id="创建-mapping"><a href="#创建-mapping" class="headerlink" title="创建 mapping"></a>创建 mapping</h4><p>默认情况下 elasticsearch 是不需要“建表”操作的。mapping（类似数据库的表结构）会在第一次 index 的时候建立。但是提前建立 mapping 有助于查询。建立 mapping 也是使用 PUT 动词。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="symbol">http:</span>/<span class="regexp">/localhost:9200/mdblog</span><span class="regexp">/note/</span>_mapping</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"note"</span>: &#123;</span><br><span class="line"><span class="string">"properties"</span>: &#123;</span><br><span class="line"><span class="string">"id"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"long"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"title"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line"><span class="string">"term_vector"</span>: <span class="string">"with_positions_offsets"</span>,</span><br><span class="line"><span class="string">"analyzer"</span>: <span class="string">"ik_syno"</span>,</span><br><span class="line"><span class="string">"search_analyzer"</span>: <span class="string">"ik_syno"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"content"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line"><span class="string">"term_vector"</span>: <span class="string">"with_positions_offsets"</span>,</span><br><span class="line"><span class="string">"analyzer"</span>: <span class="string">"ik_syno"</span>,</span><br><span class="line"><span class="string">"search_analyzer"</span>: <span class="string">"ik_syno"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"notename"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"tagList"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line"><span class="string">"term_vector"</span>: <span class="string">"with_positions_offsets"</span>,</span><br><span class="line"><span class="string">"analyzer"</span>: <span class="string">"ik_syno"</span>,</span><br><span class="line"><span class="string">"search_analyzer"</span>: <span class="string">"ik_syno"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"timestamp"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"lastModified"</span>: &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，建立一个 mapping 。主要是设置一下数据类型和查询方式。</p><h2 id="在-golang-中使用"><a href="#在-golang-中使用" class="headerlink" title="在 golang 中使用"></a>在 golang 中使用</h2><p>在 golang 中有方便的 package 来操纵 elasticsearch。我使用的是 <a href="https://github.com/olivere/elastic" target="_blank" rel="noopener"><code>gopkg.in/olivere/elastic.v3</code></a> 还不错的一个包，所有操作都是链式调用，很有 linq 的感觉。</p><p>使用 elastic 需要先创建一个客户端：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitElasticSearch</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">esClient, err = elastic.NewClient(</span><br><span class="line">    elastic.SetURL(<span class="string">"http://localhost:9200"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以用 client 进行操作了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">noteDetail := model.NoteDetail&#123;</span><br><span class="line">Id:           note.Id,</span><br><span class="line">Notename:     note.Notename,</span><br><span class="line">Title:        note.Title,</span><br><span class="line">Content:      note.ContentText(),</span><br><span class="line">Timestamp:    note.Timestamp,</span><br><span class="line">LastModified: note.LastModified,</span><br><span class="line">TagList:      tagNameList,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先调用 Index 函数，代表这是一次索引（Index）操作</span></span><br><span class="line"><span class="comment">// 接着提供各种参数</span></span><br><span class="line">_, err := esClient.Index().</span><br><span class="line">Index(MdBlogIndexName).</span><br><span class="line">Type(NoteTypeName).</span><br><span class="line">Id(strconv.FormatInt(note.UniqueId, <span class="number">10</span>)).</span><br><span class="line">BodyJson(noteDetail).</span><br><span class="line">Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引一条记录</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNoteDocumentExist</span><span class="params">(uniqueId <span class="keyword">int64</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> esClient.Exists().</span><br><span class="line">Index(MdBlogIndexName).</span><br><span class="line">Type(NoteTypeName).</span><br><span class="line">Id(strconv.FormatInt(uniqueId, <span class="number">10</span>)).</span><br><span class="line">Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否存在</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchNoteByKeyword</span><span class="params">(keyword <span class="keyword">string</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    page, limit <span class="keyword">int64</span>)</span> <span class="params">([]*model.SearchedNote, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">page-- <span class="comment">//数据库层的页数从0开始数</span></span><br><span class="line">offset := page * limit</span><br><span class="line"></span><br><span class="line">query := elastic.NewMultiMatchQuery(keyword).</span><br><span class="line">FieldWithBoost(<span class="string">"notename"</span>, <span class="number">1</span>).</span><br><span class="line">FieldWithBoost(<span class="string">"tagList"</span>, <span class="number">2</span>).</span><br><span class="line">FieldWithBoost(<span class="string">"content"</span>, <span class="number">4</span>).</span><br><span class="line">FieldWithBoost(<span class="string">"title"</span>, <span class="number">4</span>)</span><br><span class="line">highlight := elastic.NewHighlight().</span><br><span class="line">Field(<span class="string">"content"</span>).</span><br><span class="line">Field(<span class="string">"title"</span>).</span><br><span class="line">Field(<span class="string">"tagList"</span>)</span><br><span class="line"></span><br><span class="line">result, err := esClient.Search().</span><br><span class="line">Index(MdBlogIndexName).</span><br><span class="line">Type(NoteTypeName).</span><br><span class="line">Query(query).</span><br><span class="line">Highlight(highlight).</span><br><span class="line">From(<span class="keyword">int</span>(offset)).</span><br><span class="line">Size(<span class="keyword">int</span>(limit)).</span><br><span class="line">Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Hits == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">maxPage := (result.TotalHits()<span class="number">-1</span>)/limit + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">noteList := <span class="built_in">make</span>([]*model.SearchedNote, <span class="number">0</span>, <span class="built_in">len</span>(result.Hits.Hits))</span><br><span class="line"><span class="keyword">for</span> _, hit := <span class="keyword">range</span> result.Hits.Hits &#123;</span><br><span class="line">note := model.NewSearchedNote()</span><br><span class="line">err := json.Unmarshal(*hit.Source, note)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">note.FillHighlight(hit.Highlight)</span><br><span class="line"></span><br><span class="line">noteList = <span class="built_in">append</span>(noteList, note)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> noteList, maxPage, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索记录</p><h2 id="´-・ω・｀"><a href="#´-・ω・｀" class="headerlink" title="(´ ・ω・｀)"></a>(´ ・ω・｀)</h2><p>总的来说，elasticsearch 还是很方便强大的，好评。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客从 Wordpress 迁移过来之后一直缺少一个搜索功能，这个博客我是当做笔记性质的，有时候脑子里突然想不起某个东西的时候就上来查一下。没有搜索还是很不方便的，所以费了点时间研究了下大名鼎鼎的 elasticsearch 配合 golang 给博客加上了搜索功能。&lt;/p
      
    
    </summary>
    
    
    
      <category term="golang" scheme="https://lengzzz.com/tags/golang/"/>
    
      <category term="elasticsearch" scheme="https://lengzzz.com/tags/elasticsearch/"/>
    
      <category term="搜索引擎" scheme="https://lengzzz.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>做了个 golang 安装包的镜像</title>
    <link href="https://lengzzz.com/2016/05/25/%E5%81%9A%E4%BA%86%E4%B8%AAgolang%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://lengzzz.com/2016/05/25/%E5%81%9A%E4%BA%86%E4%B8%AAgolang%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E9%95%9C%E5%83%8F/</id>
    <published>2016-05-25T07:57:16.000Z</published>
    <updated>2016-05-25T08:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。</p><p><a href="/notename/" title="golang china download mirror"></a></p><p>地址在这里：<a href="https://lengzzz.com/download/golang/">https://lengzzz.com/download/golang/</a></p><p>包含了 golang 1.5 之后的所有版本，所有平台的安装包和源码包都放在里面，自行 <code>control + f</code> 搜一下吧。新版本的 golang release 之后，应该在一两天内可以拉取过来。</p><p>欢迎使用。</p><p><img src="/images/1f5556f01de37fc838e02d1c4d7a6682.png" alt="屏幕快照 2016-05-25 下午4.06.56.png-311.7kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="闲扯" scheme="https://lengzzz.com/tags/%E9%97%B2%E6%89%AF/"/>
    
      <category term="golang" scheme="https://lengzzz.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell 编程中的 trap 的小坑</title>
    <link href="https://lengzzz.com/2016/05/24/LinuxShell%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84trap%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>https://lengzzz.com/2016/05/24/LinuxShell%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84trap%E7%9A%84%E5%B0%8F%E5%9D%91/</id>
    <published>2016-05-24T10:58:33.000Z</published>
    <updated>2016-05-24T11:25:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Shell 编程中，为了脚本的健壮性，一般会用到 <code>trap</code> 这个 builtin command。trap 命令类似 c 语言中的 <code>signal</code> 函数，可以注册一个函数，当程序收到信号时执行函数。但是 trap 命令也有一些比较坑的小细节，比如 trap 的执行时机。</p><p><a href="/notename/" title="trap&#39;s trap in linux shell programing"></a></p><p>在 c 语言中，程序收到信号之后会立即执行 signal 注册的信号处理函数。那么在 shell 程序中呢，信号究竟什么时候被 trap 处理？是像 c 程序一样停下程序立即执行，还是等待当前程序执行之后再执行？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">'echo "signal received!"; exit'</span> INT</span><br><span class="line">sleep 100</span><br></pre></td></tr></table></figure><p>我们先写一段程序做个实验。在 bash 中执行它，然后按 <code>control + c</code> 发现程序立即停止了，然后打印了 signal received，似乎 trap 是类似 c 程序一样立即处理信号的。但其实是被表面现象蒙骗了。</p><p>我们再次执行这个 shell 程序，然后打开另一个 shell，在里面执行 <code>kill -SIGINT xxx</code> 发现 shell 程序并没有退出，等待了 100 秒之后才打印 signal received 退出。</p><p>因为第一次在键盘上按 <code>control + c</code> 后，sleep 程序和 shell 程序同属一个进程组，所以也接到了 int 信号退出了，而第二次只有 shell 程序收到信号，所以造成了两者的差异。我第一次也被蒙骗了，傻乎乎的以为 trap 能在 sleep 时也处理信号。</p><p>那么问题来了，我们如果需要在 sleep 时处理信号，并且及时退出怎么办呢？国外一篇文章给了例子<a href="http://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener">^sample</a>，我就负责搬运一下了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid=</span><br><span class="line"><span class="built_in">trap</span> <span class="string">'[[ $pid ]] &amp;&amp; kill $pid'</span> EXIT</span><br><span class="line">sleep 10000 &amp; pid=$!</span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line">pid=</span><br></pre></td></tr></table></figure><p>利用了 bash 的 builtin 命令 wait。wait 是一个 shell 内部的命令，而不是一个外部程序，所以它没有前面的限制。另外，要记得退出时 kill 掉 sleep 进程，擦好屁股。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Shell 编程中，为了脚本的健壮性，一般会用到 &lt;code&gt;trap&lt;/code&gt; 这个 builtin command。trap 命令类似 c 语言中的 &lt;code&gt;signal&lt;/code&gt; 函数，可以注册一个函数，当程序收到信号时执行函数。但是 trap 命令也
      
    
    </summary>
    
    
    
      <category term="linux" scheme="https://lengzzz.com/tags/linux/"/>
    
      <category term="bash" scheme="https://lengzzz.com/tags/bash/"/>
    
      <category term="shell" scheme="https://lengzzz.com/tags/shell/"/>
    
      <category term="trap" scheme="https://lengzzz.com/tags/trap/"/>
    
  </entry>
  
  <entry>
    <title>CloudXNS-DDNS 动态域名客户端 docker 镜像</title>
    <link href="https://lengzzz.com/2016/05/14/CloudXNS-DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E5%AE%A2%E6%88%B7%E7%AB%AFdocker%E9%95%9C%E5%83%8F/"/>
    <id>https://lengzzz.com/2016/05/14/CloudXNS-DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E5%AE%A2%E6%88%B7%E7%AB%AFdocker%E9%95%9C%E5%83%8F/</id>
    <published>2016-05-14T07:15:34.000Z</published>
    <updated>2016-05-14T07:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近<a href="https://lengzzz.com/note/the-domain-hosting-to-cloudxns-perfect-supporting-the-let-s-encrypt">换上</a>了 CloudXNS 的域名服务。以前使用花生壳的时候比较方便，大多数路由器都支持，而且还提供了 Linux 下的客户端源码供定制。换上 CloudXNS 之后这些方便的东西当然没有了，不过 CloudXNS 也提供了 API，作为程序员当然要自己写一个了。这篇文章是这个 CloudXNS DDNS 客户端的使用介绍。</p><p><a href="/notename/" title="a docker image for CloudXNS DDNS"></a></p><p>客户端是使用 golang 开发的，放到了 <a href="https://github.com/zwh8800/cloudxns-ddns" target="_blank" rel="noopener"><i class="icon-github"></i> github 上 <sub>https://github.com/zwh8800/cloudxns-ddns</sub></a>。需要的可以自己编译，不过我已经做好了 <a href="https://hub.docker.com/r/zwh8800/cloudxns-ddns" target="_blank" rel="noopener">docker 镜像 <sub>https://hub.docker.com/r/zwh8800/cloudxns-ddns</sub></a> 了可以直接使用。</p><p>首先，拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zwh8800/cloudxns-ddns</span><br></pre></td></tr></table></figure><p>然后，编写一个很简单的配置文件，放到某个文件夹中（如/home/zzz/cloudxns-ddns/config，下面以此为例子)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[CloudXNS]</span></span><br><span class="line"><span class="attr">APIKey</span>=<span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span></span><br><span class="line"><span class="attr">SecureKey</span>=<span class="string">"xxxxxxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Domain]</span></span><br><span class="line"><span class="attr">Data</span>=<span class="string">"home.lengzzz.com"</span></span><br><span class="line"><span class="attr">Data</span>=<span class="string">"haha.lengzzz.com"</span></span><br></pre></td></tr></table></figure><p>上面 <code>APIKey</code> 是你在 <a href="https://www.cloudxns.net/AccountManage/apimanage.html" target="_blank" rel="noopener">CloudXNS <sub>https://www.cloudxns.net/AccountManage/apimanage.html</sub></a> 申请的 key，填进去即可。下面是你想要动态的域名，可以写很多。</p><p>然后，启动镜像即可。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name cloudxns-ddns -d -v /home/zzz/cloudxns-ddns/log:/app/log -v /home/zzz/cloudxns-ddns/config:/app<span class="built_in">/config </span>zwh8800/cloudxns-ddns</span><br></pre></td></tr></table></figure><p>注意一点，需要把刚写的配置文件当作 <code>volumn</code> 挂载到容器上，如上 <code>-v /home/zzz/cloudxns-ddns/config:/app/config</code> 。这样的话，你可以方便的修改配置文件然后 <code>docker restart cloud-ddns</code> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近&lt;a href=&quot;https://lengzzz.com/note/the-domain-hosting-to-cloudxns-perfect-supporting-the-let-s-encrypt&quot;&gt;换上&lt;/a&gt;了 CloudXNS 的域名服务。以前使用花生壳的时
      
    
    </summary>
    
    
    
      <category term="CloudXNS" scheme="https://lengzzz.com/tags/CloudXNS/"/>
    
      <category term="DDNS" scheme="https://lengzzz.com/tags/DDNS/"/>
    
      <category term="docker" scheme="https://lengzzz.com/tags/docker/"/>
    
      <category term="动态DNS" scheme="https://lengzzz.com/tags/%E5%8A%A8%E6%80%81DNS/"/>
    
  </entry>
  
  <entry>
    <title>把域名托管到 CloudXNS 了，完美支持 let&#39;s encrypt</title>
    <link href="https://lengzzz.com/2016/05/01/%E6%8A%8A%E5%9F%9F%E5%90%8D%E6%89%98%E7%AE%A1%E5%88%B0CloudXNS%E4%BA%86%EF%BC%8C%E5%AE%8C%E7%BE%8E%E6%94%AF%E6%8C%81let&#39;sencrypt/"/>
    <id>https://lengzzz.com/2016/05/01/%E6%8A%8A%E5%9F%9F%E5%90%8D%E6%89%98%E7%AE%A1%E5%88%B0CloudXNS%E4%BA%86%EF%BC%8C%E5%AE%8C%E7%BE%8E%E6%94%AF%E6%8C%81let&#39;sencrypt/</id>
    <published>2016-05-01T08:41:51.000Z</published>
    <updated>2016-05-01T09:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://lengzzz.com">lengzzz.com</a> 这个域名我已经用了6年了，当年年少无知用了 oray 的服务，就为了一个花生壳的功能（tplink自带花生壳）。现在越发感觉 oray 的服务质量不很好。各省解析速度不一，国外就更慢了。尤其是不支持 <code>let&#39;s encrypt</code> 让我好生郁闷。所以赶紧换上了 CloudXNS 。</p><p>CloudXNS 的页面就看着比较顺眼。据说 DNSPod 也不错，但是我感觉网页太丑了，就没有使用它，哈哈，所以证明一句话 <strong>你的颜值决定了别人会不会去发现你的内心</strong> 。</p><p><img src="/images/f9e146686ecd27ddbd7424e8c6a6169b.png" alt="QQ20160501-0@2x.png-321.5kB"></p><p>注册了之后发现使用超级方便，只给你显示了一个超大的输入框，让你输入自己的域名。</p><p><img src="/images/0e13753a1874c7bf2b348f4aca064f45.png" alt="QQ20160501-1@2x.png-43.7kB"></p><p>输入之后，就进入了控制台节目了，好像你的域名已经托管在 CloudXNS 上了一样，当你设置好解析之后，只需要把之前域名的 NS 地址设置到 CloudXNS 上就好了。整个用户体验相当舒服。</p><p>设置好之后，控制台上会实时显示接管状态。不过5分钟，就可以用了。立即用 let’s encrypt 更新一下 ssl 证书。果然可以用了。</p><p><img src="/images/24d97e9041fe854f0a0a90461e921a72.png" alt="QQ20160501-2@2x.png-70.3kB"></p><p>最后来张测速图吧。</p><p><img src="/images/7d9691daa44d1454cc69023bfa78d502.png" alt="QQ20160501-3@2x.png-138.9kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://lengzzz.com&quot;&gt;lengzzz.com&lt;/a&gt; 这个域名我已经用了6年了，当年年少无知用了 oray 的服务，就为了一个花生壳的功能（tplink自带花生壳）。现在越发感觉 oray 的服务质量不很好。各省解析速度不一，国外就更慢
      
    
    </summary>
    
    
    
      <category term="CloudXNS" scheme="https://lengzzz.com/tags/CloudXNS/"/>
    
      <category term="闲扯" scheme="https://lengzzz.com/tags/%E9%97%B2%E6%89%AF/"/>
    
      <category term="DNS" scheme="https://lengzzz.com/tags/DNS/"/>
    
  </entry>
  
</feed>
