<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | wastecat的博客</title>

  
  <meta name="author" content="wastecat">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="wastecat的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wastecat的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">wastecat的博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2016/07/08/并发难|池里究竟该放多少线程？/"><span>并发难 | 池里究竟该放多少线程？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/07/08/并发难|池里究竟该放多少线程？/" rel="bookmark">
        <time class="entry-date published" datetime="2016-07-08T06:29:46.000Z">
          2016-07-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近在项目里做了一个数据同步的功能。需要把两个数据库里的数据做同步，在业务不繁忙的时候跑一次，核对库里每一条数据，主要是为了保证<strong>数据最终一致</strong>，做的一个保底工作。之前项目里同步的代码是单线程的，我改成了基于线程池的，但是在上线前的一些问题却引起了我的思考。</p>
<p><a href="/notename/" title="concurrency roadblock how many threads should be in pool"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>程序的代码还是比较简单的，大概类似下面：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数分别为线程数量和总任务数</span></span><br><span class="line">p := pool.NewPool(goroutineCount, <span class="built_in">len</span>(userIds))</span><br><span class="line"><span class="keyword">for</span> _, userId := <span class="keyword">range</span> userIds &#123;</span><br><span class="line">	p.Queue(<span class="function"><span class="keyword">func</span><span class="params">(job *pool.Job)</span></span> &#123;</span><br><span class="line">		userId := job.Params()[<span class="number">0</span>].(<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line">		tx, err := sess.Begin()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> tx.RollbackUnlessCommitted()</span><br><span class="line">		<span class="keyword">if</span> err := dao.SyncSingleUser(tx, userId); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := tx.Commit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, userId)</span><br><span class="line">&#125;</span><br><span class="line">errOccurs := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> p.Results() &#123;</span><br><span class="line">	<span class="keyword">if</span> err, ok := result.(*pool.ErrRecovery); ok &#123;</span><br><span class="line">		glog.Errorln(err)</span><br><span class="line">		errOccurs = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> errOccurs &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确定线程的数量，我逐步增加线程数记录系统各项数值。下面是在一台 RMBP 上做的测试。</p>
<p>| T | QPS | CPU | DBCPU |<br>|  |  |  |  | |<br>| 1 | 9000 | 37 | 81 |<br>| 2 | 14000 | 60 | 150 |<br>| 3 | 15500 | 70 | 195 |<br>| 4 | 16500 | 90 | 260 |</p>
<p>可以发现随着线程数增加，性能会逐步提高，但是当线程数提高到一定程度之后，性能不增反降（这部分数据没放）。如果继续增加线程数进行测试，会发现系统的某些性能指标会被耗尽，程序开始报错。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recovering <span class="keyword">from</span> panic: dial tcp <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>: getsockopt: operation timed <span class="keyword">out</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现这种情况呢？在讨论这些问题之前，先回顾一下 goroutine 的设计与实现。</p>
<h2 id="goroutine-设计"><a href="#goroutine-设计" class="headerlink" title="goroutine 设计"></a>goroutine 设计</h2><p>事实上，在 golang 中的 goroutine 已经不是传统意义上的线程了。传统的操作系统提供的线程在使用时有一些限制，超过一定数量之后会对性能造成影响。而 golang 提供的 goroutine 是一种 green thread。</p>
<p>Green thread 和 NodeJS 的异步回调方案有类似的地方，都在底层调用的系统的异步 IO 系统调用。</p>
<ul>
<li>异步回调方案：所有 IO 操作的 API 都设计成异步回调形式，底层调用异步的系统调用（如epool、kqueue等）。同时，也可能提供同步版本的 IO 操作（如fs.readFileSync）</li>
<li>Green thread 方案：所有 IO 操作底层实际上事异步调用，但是在语言中却表现的像一个同步调用。当 IO 操作需要等待时，语言的 runtime 自动调度系统级线程到另一个 Green thread 中。写代码的时候感觉好像是同步的，仿佛在同一个线程完成的，但实际上系统可能切换了线程，但程序对此无感。</li>
</ul>
<p>由此可见，Green thread 在语言设计上比异步回调方案要略胜一筹，不会出现“冲击波”的现象（具体在 NodeJS 中如何避免“冲击波”代码可以看我<a href="https://lengzzz.com/note/in-depth-analysis-of-await-and-async">这篇文章<small>await &amp; async 深度剖析</small></a>），但在性能上实际是差不多的，都避免了大量使用操作系统级的线程带来的性能问题，同时又能充分的利用 CPU。</p>
<p>但是，今天我想谈的问题并不是 CPU 利用率／线程数量的问题，这个问题已经被上述两种设计方案比较完美的解决了。</p>
<h2 id="CPU-以外的资源瓶颈"><a href="#CPU-以外的资源瓶颈" class="headerlink" title="CPU 以外的资源瓶颈"></a>CPU 以外的资源瓶颈</h2><p>在实际中，更多遇到的是 cpu ／线程数量之外的资源瓶颈。比如锁、数据库链接、tcp链接。举个例子，假如做个爬虫应用，每个 goroutine 爬一个网页，golang 虽然号称百万级别的 goroutine ，但是你每个 goroutine 里面创建一个 tcp 链接，不到 5 万个 goroutine 就会把系统的 tcp 资源耗尽。</p>
<p>回到文章最上面的情况，在 goroutine 里调用了 <code>dao.SyncSingleUser</code> 函数，这个是一个数据库操作，不可避免的会有 socket 操作、硬盘操作。如果将所有数据库操作都无脑的放到 goroutine 中执行，当资源出现瓶颈之后，大量 goroutine 会阻塞或报错。</p>
<p>因此，我在项目里使用了一个 goroutine 池，来确保不会过多使用系统资源导致崩溃。那么问题来了，<strong>池里究竟该放多少线程</strong>？</p>
<p>又回到了最初使用系统线程时遇到的问题，不过这次导致问题的不再是线程资源，而是其他资源瓶颈（如 tcp、数据库链接 等）。这些资源比线程资源更加复杂，更加难以把控。更加难做 benchmark，也就更难找出一个通用的方法来解决实际场景的问题。</p>
<h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>思考过后，我在网上开始搜索解决方案。发现这篇文章的作者和我做了类似的思考：<a href="http://jolestar.com/parallel-programming-model-thread-goroutine-actor/" target="_blank" rel="noopener">《并发之痛 Thread，Goroutine，Actor》</a>。作者最后得出 Actor 模型能解决一些问题（不过我才疏学浅至今不怎么理解 Actor 模型），但并发带来的问题还远远没到解决的程度。</p>
<blockquote>
<p><em>革命尚未成功 同志任需努力</em></p>
</blockquote>
<p>所以说，<strong>软件工程没有银弹</strong>，路漫漫其修远兮，吾将上下而求索。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/并发/">并发</a><a href="/tags/思考/">思考</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/07/08/并发难|池里究竟该放多少线程？/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/06/22/golang垃圾回收机制/"><span>golang 垃圾回收机制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/22/golang垃圾回收机制/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-22T07:22:16.000Z">
          2016-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>用任何带 GC 的语言最后都要直面 GC 问题。在以前学习 C# 的时候就被迫读了一大堆 .NET Garbage Collection 的文档。最近也学习了一番 golang 的垃圾回收机制，在这里记录一下。</p>
<p><a href="/notename/" title="gc in golang"></a></p>
<h2 id="常见-GC-算法"><a href="#常见-GC-算法" class="headerlink" title="常见 GC 算法"></a>常见 GC 算法</h2><p>趁着这个机会我总结了一下常见的 GC 算法。分别是：<strong>引用计数法</strong>、<strong>Mark-Sweep法</strong>、<strong>三色标记法</strong>、<strong>分代收集法</strong>。</p>
<h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>原理是在每个对象内部维护一个整数值，叫做这个对象的<strong>引用计数</strong>，当对象被引用时引用计数加一，当对象不被引用时引用计数减一。当引用计数为 0 时，自动销毁对象。</p>
<p>目前引用计数法主要用在 c++ 标准库的 std::shared_ptr 、微软的 COM 、Objective-C 和 PHP 中。</p>
<p>但是引用计数法有个缺陷就是不能解决循环引用的问题。循环引用是指对象 A 和对象 B 互相持有对方的引用。这样两个对象的引用计数都不是 0 ，因此永远不能被收集。</p>
<p>另外的缺陷是，每次对象的赋值都要将引用计数加一，增加了消耗。</p>
<h3 id="2-Mark-Sweep法（标记清除法）"><a href="#2-Mark-Sweep法（标记清除法）" class="headerlink" title="2. Mark-Sweep法（标记清除法）"></a>2. Mark-Sweep法（标记清除法）</h3><p>这个算法分为两步，标记和清除。</p>
<ul>
<li>标记：从程序的根节点开始， <strong>递归地</strong> 遍历所有对象，将能遍历到的对象打上标记。</li>
<li>清除：讲所有未标记的的对象当作垃圾销毁。</li>
</ul>
<center>
![Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif-143.9kB][1]
<small>图片来自 https://en.wikipedia.org/wiki/Tracing_garbage_collection </small>
</center>

<p>如图所示。</p>
<p>但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。</p>
<p>当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。</p>
<p>golang 1.5以前使用的这个算法。</p>
<h3 id="3-三色标记法"><a href="#3-三色标记法" class="headerlink" title="3. 三色标记法"></a>3. 三色标记法</h3><p>三色标记法是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法。</p>
<p>原理如下，</p>
<ol>
<li>首先创建三个集合：白、灰、黑。</li>
<li>将所有对象放入白色集合中。</li>
<li>然后从根节点开始遍历所有对象（注意这里<strong>并不递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。</li>
<li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li>
<li>重复 4 直到灰色中无任何对象</li>
<li>通过write-barrier检测对象有变化，重复以上操作</li>
<li>收集所有白色对象（垃圾）</li>
</ol>
<center>
![Animation_of_tri-color_garbage_collection.gif-94kB][2]
<small>图片来自 https://en.wikipedia.org/wiki/Tracing_garbage_collection </small>
</center>

<p>过程如上图所示。</p>
<p>这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。</p>
<p>但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。</p>
<p>使用这种算法的是 Go 1.5、Go 1.6。</p>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>分代收集也是传统 Mark-Sweep 的一个改进。这个算法是基于一个经验：绝大多数对象的生命周期都很短。所以按照对象的生命周期长短来进行分代。</p>
<p>一般 GC 都会分三代，在 java 中称之为新生代（Young Generation）、年老代（Tenured Generation）和永久代（Permanent Generation）；在 .NET 中称之为第 0 代、第 1 代和第2代。</p>
<p>原理如下：</p>
<ul>
<li>新对象放入第 0 代</li>
<li>当内存用量超过一个较小的阈值时，触发 0 代收集</li>
<li>第 0 代幸存的对象（未被收集）放入第 1 代</li>
<li>只有当内存用量超过一个较高的阈值时，才会触发 1 代收集</li>
<li>2 代同理</li>
</ul>
<p>因为 0 代中的对象十分少，所以每次收集时遍历都会非常快（比 1 代收集快几个数量级）。只有内存消耗过于大的时候才会触发较慢的 1 代和 2 代收集。</p>
<p>因此，分代收集是目前比较好的垃圾回收方式。使用的语言（平台）有 jvm、.NET 。</p>
<h2 id="golang-的-GC"><a href="#golang-的-GC" class="headerlink" title="golang 的 GC"></a>golang 的 GC</h2><p>go 语言在 1.3 以前，使用的是比较蠢的传统 Mark-Sweep 算法。</p>
<p>1.3 版本进行了一下改进，把 Sweep 改为了并行操作。</p>
<p>1.5 版本进行了较大改进，使用了三色标记算法。go 1.5 在源码中的解释是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”</p>
<p>go 除了标准的三色收集以外，还有一个辅助回收功能，防止垃圾产生过快手机不过来的情况。这部分代码在 <a href="https://golang.org/src/runtime/mgcmark.go#L316" target="_blank" rel="noopener"><code>runtime.gcAssistAlloc</code></a> 中。</p>
<p>但是 golang 并没有分代收集，所以对于巨量的小对象还是很苦手的，会导致整个 mark 过程十分长，在某些极端情况下，甚至会导致 GC 线程占据 50% 以上的 CPU。</p>
<p>因此，当程序由于高并发等原因造成大量小对象的gc问题时，最好可以使用 <a href="https://golang.org/pkg/sync/#Pool" target="_blank" rel="noopener"><code>sync.Pool</code></a> 等对象池技术，避免大量小对象加大 GC 压力。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/GC/">GC</a><a href="/tags/垃圾回收/">垃圾回收</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/06/22/golang垃圾回收机制/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/06/21/高可用可伸缩架构/"><span>高可用可伸缩架构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/21/高可用可伸缩架构/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-21T05:39:33.000Z">
          2016-06-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近在读一本书《大型网站技术架构》，收获颇多。这篇文章是对最近学习的一些总结，大多是一些结论性的内容，可以拿来就用的东西，对于大部分企业都比较适用。注意这些内容并不是我自己发明的，而是业界多年来的经验总结出的结论。</p>
<p><a href="/notename/" title="high availability scalable architecture"></a></p>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="1-性能测试"><a href="#1-性能测试" class="headerlink" title="1. 性能测试"></a>1. 性能测试</h3><p>保证网站高性能的前提是做性能测试，如果连网站的性能指标都不知道，怎么判断一个网站“慢不慢”和“高性能”呢。</p>
<p>对一个网站做性能测试时，主要需要测试一下几项数据：</p>
<ul>
<li>并发数</li>
<li>响应时间</li>
<li>吞吐量（TPS，每秒事物数）</li>
<li>资源消耗（主要指cpu、内存消耗）</li>
</ul>
<p>在做性能测试时，一般以并发数为自变量，逐步提高并发数，每次记录上述四个指标，制作出一张表格以方便后面进行分析。</p>
<p>例子如下：</p>
<table>
<thead>
<tr>
<th>并发数</th>
<th>响应时间</th>
<th>TPS</th>
<th>出错率</th>
<th>CPU</th>
<th>内存</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>10ms</td>
<td>200</td>
<td>0%</td>
<td>5%</td>
<td>200MiB</td>
<td>性能测试</td>
</tr>
<tr>
<td>200</td>
<td>15ms</td>
<td>266</td>
<td>0%</td>
<td>10%</td>
<td>300MiB</td>
<td>性能测试</td>
</tr>
<tr>
<td>300</td>
<td>20ms</td>
<td>300</td>
<td>2%</td>
<td>15%</td>
<td>400MiB</td>
<td>性能测试</td>
</tr>
<tr>
<td>400</td>
<td>50ms</td>
<td>330</td>
<td>20%</td>
<td>35%</td>
<td>600MiB</td>
<td>负载测试</td>
</tr>
<tr>
<td>500</td>
<td>100ms</td>
<td>350</td>
<td>25%</td>
<td>40%</td>
<td>800MiB</td>
<td>负载测试</td>
</tr>
<tr>
<td>600</td>
<td>500ms</td>
<td>360</td>
<td>30%</td>
<td>50%</td>
<td>1.0GiB</td>
<td>压力测试</td>
</tr>
<tr>
<td>700</td>
<td>1200ms</td>
<td>350</td>
<td>50%</td>
<td>60%</td>
<td>1.5GiB</td>
<td>压力测试</td>
</tr>
<tr>
<td>800</td>
<td>timeout</td>
<td>0</td>
<td>100%</td>
<td>N/A</td>
<td>N/A</td>
<td>压力测试</td>
</tr>
</tbody></table>
<p>看表格不是很直观，我简单解释一下。这个测试大致分为三个stage：<strong>性能测试</strong>、<strong>负载测试</strong>、<strong>压力测试</strong>。</p>
<ul>
<li>性能测试：网站正常运行的状态。随着并发数量的增大，响应时间不会有很大的变化；吞吐量和资源消耗基本上时线性正相关。</li>
<li>负载测试：网站某项或多项性能指标已达到临界值。此时增大并发数量响应时间已经有明显的影响；资源消耗增大而吞吐量不会有太大变化。</li>
<li>压力测试：已超出安全负载。此时响应延迟明显增大；资源消耗越来越多而系统吞吐量不增反降。继续增大负载，系统将崩溃，不能接受任何请求。</li>
</ul>
<p>分别以 “资源消耗” 为横轴、TPS 为纵轴画出函数图像可以更直观的观察两者之间的关系。</p>
<center>
![QQ20160621-0@2x.png-76.3kB][1]
</center>

<p>分别以 “并发数” 为横轴、“响应时间” 为纵轴，观察两者关系。</p>
<center>
![QQ20160621-1@2x.png-84.2kB][2]
</center>

<p>通过以上分析，判断一个网站是否高性能，可以通过并发数来做基本的判断。更准确的应当通过上图中的b点处（系统最佳运行点）的并发数量来判断网站性能。</p>
<h3 id="2-前端性能优化"><a href="#2-前端性能优化" class="headerlink" title="2. 前端性能优化"></a>2. 前端性能优化</h3><p>这部分和我们讨论的网站架构关系不大，对于后端开发者来说需要注意的点有：使用CDN、注意开启浏览器缓存、合并JS减少HTTP请求等等，主要还是靠前端工程师的努力啦。</p>
<h3 id="3-应用性能优化"><a href="#3-应用性能优化" class="headerlink" title="3. 应用性能优化"></a>3. 应用性能优化</h3><p>对于应用层的性能优化主要有三种方法：<strong>加缓存</strong>、<strong>使用异步操作</strong>、<strong>应用集群化</strong>。这三者越靠前者越应当优先使用，效果越好，对系统影响越小。</p>
<h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><p>有一位计算机科学家曾说“缓存是最伟大的发明”，在系统中使用缓存可以挡住大部分请求从而可以不访问数据库。但是并不是说缓存可以在任何地方使用（滥用）。使用缓存有以下原则。</p>
<ul>
<li>不应缓存频繁更改的数据。一般来说，缓存是被用来读的，如果一个缓存刚刚写入没过过久又被修改了，这样毫无意义。最好的情况是，缓存写入后被读了成千上万次。</li>
<li>应缓存热点数据。缓存使用内存存储，如果将不频繁访问的数据放入缓存的话太浪费内存空间。</li>
<li>注意数据不一致问题。缓存一般设置超时时间，当用户修改了数据后缓存不一定能及时更新。应根据业务合理设置超时时间。</li>
<li>注意缓存可用性问题。应妥善结果缓存挂了的情况，因为数据库已经习惯了有缓存的“舒适”的日子，一旦缓存挂了之后数据库压力山大而宕机导致网站整体不可用。</li>
<li>应进行缓存预热。当换上一台新缓存服务器后不应立即撤掉老的缓存服务器，因为新机器内部还没有任何数据，大部分访问还是会打到数据库。所以新的缓存服务器启动时最好将热点数据提前载入进行预热。</li>
</ul>
<p>具体在使用缓存时可以使用业界通用的开源缓存系统，如redis、memcached、jboss cache等。</p>
<h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>网站一些操作可以不直接访问数据库，而是将任务放入消息队列异步化。是用另一台 consumer 服务器从消息队列中取出任务进行数据库访问。</p>
<p>这样可以有效的起到“削峰”作用。经常用于应对突然增加的并发数，比如在抢购系统中，在前几分钟会接到很多请求，将这些请求放入消息队列中逐个处理，当处理结束后再使用 websocket 等通知方式告知用户是否抢购到商品。</p>
<center>
![QQ20160621-2@2x.png-60.3kB][3]
</center>

<h4 id="应用集群化"><a href="#应用集群化" class="headerlink" title="应用集群化"></a>应用集群化</h4><p>使用负载均衡技术，在网站入口搭建一台负载均衡服务器（如nginx），入口后搭建一个应用服务器集群，当接收到请求后，负载均衡服务器使用一定算法将请求平均的打到不同的应用服务器上。</p>
<p>这样，比如应用集群有10台机器，那么理想状态下每台机器的负载只有总负载的 1/10 。</p>
<h3 id="4-存储性能优化"><a href="#4-存储性能优化" class="headerlink" title="4. 存储性能优化"></a>4. 存储性能优化</h3><p>先略过不表</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>可用性指网站的故障情况。网站的故障时间越短，故障范围越小说明网站可用性越高。对于网站提高网站的可用性，需要从四方面入手：负载均衡（入口）、应用、缓存、数据库。</p>
<h3 id="1-入口层"><a href="#1-入口层" class="headerlink" title="1. 入口层"></a>1. 入口层</h3><p>需要在 nginx 挂了之后还有机器能顶上。可使用的技术有 VRRP，具体说来就是当一台机器挂了之后，另一台机器检测到了之后立即把自己的IP地址设置为原有机器的IP地址。通过这种抢地址的方式来接管新的请求。</p>
<h3 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h3><p>应用层做到高可用的方式就是“集群化”。部署多台应用服务器，对于负载均衡来说每台业务服务器都是一样的，当一台机器挂了之后将请求打到其他机器上就好了。</p>
<p>做应用集群化的核心就是“业务层不要有状态”。将状态保存到缓存层和数据库中。以下几点是大家常犯的错误：</p>
<ul>
<li>session数据，很多语言都自带了 session 功能（如php）。这样不利于集群化，所以在写代码时应注意不要使用语言自带的 session 系统，最好将 session 数据存储到缓存层、另外也可以使用 CookieSession ，将 session 加密存储在客户端。</li>
<li>缓存，很多程序员喜欢在业务层使用一个全局的 map 缓存一些数据，这样就不必频繁访问数据库了，但是在使用集群时很容易造成不同机器上的缓存数据不一致的问题。这样从缓存拿到的数据就是错误的。</li>
<li>全局变量。写代码时不要使用全局变量。</li>
</ul>
<h3 id="3-缓存层"><a href="#3-缓存层" class="headerlink" title="3. 缓存层"></a>3. 缓存层</h3><p>现在普遍使用缓存，因为缓存可以替 mysql 挡住大部分请求。所以这种情况下，整个系统都过于依赖缓存层。因为一旦缓存不可用之后，所有的请求都打到数据库上，导致数据库压力过大。</p>
<p>因此，保证缓存层高可用也是必要的了。达到缓存层高可用的方式也是集群化，将缓存分的细一些，不同的数据存储到不同的 cache 中。这样某一个 cache 宕机之后不至于太过严重。</p>
<h3 id="4-数据层"><a href="#4-数据层" class="headerlink" title="4. 数据层"></a>4. 数据层</h3><p>数据层有一个经典的原理，叫做 CAP 原理。CAP 分别指：一致性（ <strong>C</strong> onsistency)、可用性（<strong>A</strong> vailibility）、分区耐受性（<strong>P</strong> atition Tolerance）。</p>
<p>CAP 原理认为，一个数据服务通常无法同时做到以上三点。所以一般情况下网站会舍弃一致性，而达到可用性和分区耐受性（既可伸缩性）。</p>
<p>数据层做高可用的主要技术是：数据备份。</p>
<p>数据备份主要分为：热备、冷备。</p>
<p>冷备指定期对数据库进行备份，如果发现数据库出错了会滚到上一个备份。这种方式其实做不到数据最终一致。</p>
<p>热备主要分为同步热备和异步热备。</p>
<ul>
<li>同步热备指同时开两个数据库，应用在读写时同时对两个数据库进行操作，这样当一个数据库宕机之后另一个数据库中还保存完整数据。</li>
<li>异步热备一般指 Master-Slave 模式，应用只对 master 进行写入操作，master 会随后将数据同步到 slave 中。</li>
</ul>
<center>
![QQ20160621-3@2x.png-116.2kB][4]
</center>

<p>这两种功能 mysql 都有实现。</p>
<h2 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h2><p>可伸缩性指当业务达到负载上限时，可通过简单的增加机器的方式提高系统的负载能力。</p>
<h3 id="1-入口层-1"><a href="#1-入口层-1" class="headerlink" title="1. 入口层"></a>1. 入口层</h3><p>可以通过 DNS 来实现，目前 DNS 服务器会使用轮转算法返回 IP 地址，这样就可以把请求分配到不同的负载均衡上。</p>
<h3 id="2-应用层-1"><a href="#2-应用层-1" class="headerlink" title="2. 应用层"></a>2. 应用层</h3><p>其实应用层做到可伸缩性和高可用的解决方案一致，都是集群化，核心都是保证应用无状态。</p>
<h3 id="3-缓存层-1"><a href="#3-缓存层-1" class="headerlink" title="3. 缓存层"></a>3. 缓存层</h3><p>缓存要保证水平扩展的同时不增加额外的消耗需要一些技术。常见的技术是一致性 HASH。可以保证水平扩展后较少的数据失效。</p>
<center>
![QQ20160621-4@2x.png-115.8kB][5]
</center>

<h3 id="4-数据层-1"><a href="#4-数据层-1" class="headerlink" title="4. 数据层"></a>4. 数据层</h3><p>数据库层做可伸缩的话常用的技术就是分库、分表。</p>
<p>书中也介绍了一些开源的技术如 Cobar 之类的，不过我没有去深入研究。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网上找了张图，总结的不错。</p>
<p><img src="http://static.zybuluo.com/zwh8800/ti6tmxx2iwifi0ptko2eq4e9/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%AF%E4%BC%B8%E7%BC%A9.png" alt="高可用可伸缩.png-27.5kB"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/架构/">架构</a><a href="/tags/高可用/">高可用</a><a href="/tags/可伸缩/">可伸缩</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/06/21/高可用可伸缩架构/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/06/13/跨源HTTP请求（CORS）/"><span>跨源 HTTP 请求（CORS）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/13/跨源HTTP请求（CORS）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-13T06:37:05.000Z">
          2016-06-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>之前一直对跨域问题一知半解，今天看了些资料<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">^cors</a>总算把所有情况搞明白了。总的来说跨域请求分为两种：简单请求和复杂请求，下面来详细说明。</p>
<p><a href="/notename/" title="cross origin http request"></a></p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>简单请求是指：</p>
<ul>
<li>只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型 (Content-Type，<strong>注意是 request 的 Content-Type</strong>) 只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</li>
<li>不会使用自定义请求头（类似于 X-Modified 这种）。</li>
</ul>
<p>当浏览器遇到这种请求时，会直接向服务器发送请求，但是在把结果返回给JS代码前会做一次检查。浏览器会查看 response header 中是否有 <code>Access-Control-Allow-Origin</code> 这个 header 。如果有且允许当前 Origin 访问的话，才会真正将结果返回给 JS 程序。</p>
<h2 id="复杂请求和预请求"><a href="#复杂请求和预请求" class="headerlink" title="复杂请求和预请求"></a>复杂请求和预请求</h2><p>如果一个 Ajax 请求不是上面所说的那种。比如使用 POST 方法并且 Content-Type 是 application/json。那么浏览器则不会直接发送这个 HTTP 请求，而是先发送一个预请求。</p>
<p>预请求使用 OPTION 方法发送，并且带上 <code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Headers</code> 等 header。</p>
<p>举例说明：</p>
<p>在 a.com 下使用 POST 请求 b.com/user ，数据类型是 application/json ，并且使用了私有 header ：x-token</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/user</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: b.com</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span>: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Origin</span>: http://a.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-TOKEN</span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: POST, GET, PUT, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-TOKEN</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding, Origin</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure>

<p>这个 OPTION 请求类似一个询问，他会询问服务器是否支持用户的请求，服务器应当返回他所支持的请求。当进行了 OPTION 请求之后，浏览器进行判断此次请求是否合法，如果合法的话才会发起真正的 HTTP 请求。</p>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>默认情况下跨域请求是不带 Cookies 的，如果需要 Cookies 的话，在客户端需要将 XMLHttpRequest 对象的 withCredentials 设置为 true 。同时，服务器也应当做相应调整。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>; <span class="comment">// 设置 withCredentials 为 true</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>服务器应当返回 <code>Access-Control-Allow-Credentials: true</code> ，否则浏览器不会将结果返回给 JS 程序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，为了实现安全的跨域 Ajax 请求。会对 ajax 做一下检查。对于简单的请求，浏览器会直接发送请求，然后对结果进行检查；对于复杂请求，会首先发送一个预请求进行检查，检查通过之后才发送真正的请求。</p>
<p>为了实现检查的目的，在 HTTP 协议中新增了如下几个请求头和响应头。</p>
<h3 id="请求头（request-header）"><a href="#请求头（request-header）" class="headerlink" title="请求头（request header）"></a>请求头（request header）</h3><ul>
<li>Origin：用于表明此请求来自哪个源</li>
<li>Access-Control-Request-Method：用于表明此次请求需要使用哪个方法</li>
<li>Access-Control-Request-Headers：用于表明此次请求需要哪些自定义头</li>
</ul>
<h3 id="响应头（response-header）"><a href="#响应头（response-header）" class="headerlink" title="响应头（response header）"></a>响应头（response header）</h3><ul>
<li>Access-Control-Allow-Origin：用于表明此资源允许哪些源访问</li>
<li>Access-Control-Expose-Headers：用于表明此资源会返回哪些自定义响应头</li>
<li>Access-Control-Max-Age：用于表明此次预请求的有效期（秒）</li>
<li>Access-Control-Allow-Credentials：用于表明此资源允许使用 Cookies</li>
<li>Access-Control-Allow-Methods：用于表明此资源允许哪些方法</li>
<li>Access-Control-Allow-Headers：用于表明此资源允许哪些自定义请求头</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/HTTP/">HTTP</a><a href="/tags/CORS/">CORS</a><a href="/tags/跨域/">跨域</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/06/13/跨源HTTP请求（CORS）/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/05/28/是时候用apt代替apt-get了！/"><span>是时候用 apt 代替 apt-get 了！</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/28/是时候用apt代替apt-get了！/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-28T01:51:48.000Z">
          2016-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近无痛升级了 ubuntu 16.04 ，软件包和数据一点没丢。比上次 12.04 升级 14.04 舒服多了，直接 ssh 就搞定升级了。不得不说 ubuntu 已经成熟很多了。升级后我才发现多了个 <code>apt</code> 命令，用起来很符合我的审美，不过这个东西好像也存在比较久的一段时间了，实在是后知后觉了。</p>
<p><a href="/notename/" title="it is time to replace apt-get with apt"></a></p>
<p>apt 这个命令行工具在功能上基本涵盖了以前 apt-get 和 apt-cache 的功能，在他们之上提供了一个 high-level 的命令行界面，而且也更有交互性。</p>
<p><img src="http://static.zybuluo.com/zwh8800/j8b5ircljx0gzxv76c6w9wiv/image_1ajqh3qkm1kf81vb81kmtjldlipg.png" alt="image_1ajqh3qkm1kf81vb81kmtjldlipg.png-416.8kB"></p>
<p>在命令行下敲击 apt 后会打印出一些常见命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">zzz@ubuntu-server ~ $ apt</span><br><span class="line">apt 1.2.10 (amd64)</span><br><span class="line">用法： apt [选项] 命令</span><br><span class="line"></span><br><span class="line">命令行软件包管理器 apt 提供软件包搜索，管理和信息查询等功能。</span><br><span class="line">它提供的功能与其他 APT 工具相同（像 apt-<span class="builtin-name">get</span> 和 apt-cache），</span><br><span class="line">但是默认情况下被设置得更适合交互。</span><br><span class="line"></span><br><span class="line">常用命令：</span><br><span class="line">  list - 根据名称列出软件包</span><br><span class="line">  search - 搜索软件包描述</span><br><span class="line">  show - 显示软件包细节</span><br><span class="line">  install - 安装软件包</span><br><span class="line">  <span class="builtin-name">remove</span> - 移除软件包</span><br><span class="line">  autoremove - 卸载所有自动安装且不再使用的软件包</span><br><span class="line">  update - 更新可用软件包列表</span><br><span class="line"> <span class="built_in"> upgrade </span>- 通过 安装/升级 软件来更新系统</span><br><span class="line">  full-upgrade - 通过 卸载/安装/升级 来更新系统</span><br><span class="line">  edit-sources - 编辑软件源信息文件</span><br><span class="line"></span><br><span class="line">参见 apt(8) 以获取更多关于可用命令的信息。</span><br><span class="line">程序配置选项及语法都已经在 apt.conf(5) 中阐明。</span><br><span class="line">欲知如何配置软件源，请参阅 sources.list(5)。</span><br><span class="line">软件包及其版本偏好可以通过 apt_preferences(5) 来设置。</span><br><span class="line">关于安全方面的细节可以参考 apt-secure(8).</span><br><span class="line">                                         本 APT 具有超级牛力。</span><br></pre></td></tr></table></figure>

<p>虽然这个 <code>超级牛力</code> 是什么鬼我也不明白了。。。（莫非是 powered by GNU？）但是基本的使用介绍还是很清晰的。对于咱们普通用户来说，最明显的就是把 search 功能合并过来了。</p>
<p>另外，比较好用的一点是 list 命令。可以使用 <code>apt list --upgradable</code> 来查看需要升级的软件包，有点类似 <code>brew outdated</code> 。</p>
<p>还有一个 <code>apt show</code> 可以打印出软件包的基本信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zzz@ubuntu-server</span> <span class="string">~</span> <span class="string">$</span> <span class="string">apt</span> <span class="string">show</span> <span class="string">zsh</span></span><br><span class="line"><span class="attr">Package:</span> <span class="string">zsh</span></span><br><span class="line"><span class="attr">Version:</span> <span class="number">5.1</span><span class="number">.1</span><span class="string">-1ubuntu2</span></span><br><span class="line"><span class="attr">Priority:</span> <span class="string">optional</span></span><br><span class="line"><span class="attr">Section:</span> <span class="string">shells</span></span><br><span class="line"><span class="attr">Origin:</span> <span class="string">Ubuntu</span></span><br><span class="line"><span class="attr">Maintainer:</span> <span class="string">Ubuntu</span> <span class="string">Developers</span> <span class="string">&lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;</span></span><br><span class="line"><span class="attr">Original-Maintainer:</span> <span class="string">Debian</span> <span class="string">Zsh</span> <span class="string">Maintainers</span> <span class="string">&lt;pkg-zsh-devel@lists.alioth.debian.org&gt;</span></span><br><span class="line"><span class="attr">Bugs:</span> <span class="string">https://bugs.launchpad.net/ubuntu/+filebug</span></span><br><span class="line"><span class="attr">Installed-Size:</span> <span class="number">2</span><span class="string">,023</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Pre-Depends:</span> <span class="string">dpkg</span> <span class="string">(&gt;=</span> <span class="number">1.17</span><span class="number">.14</span><span class="string">)</span></span><br><span class="line"><span class="attr">Depends:</span> <span class="string">zsh-common</span> <span class="string">(=</span> <span class="number">5.1</span><span class="number">.1</span><span class="string">-1ubuntu2),</span> <span class="string">libc6</span> <span class="string">(&gt;=</span> <span class="number">2.15</span><span class="string">),</span> <span class="string">libcap2</span> <span class="string">(&gt;=</span> <span class="number">1</span><span class="string">:2.10),</span> <span class="string">libtinfo5</span> <span class="string">(&gt;=</span> <span class="number">6</span><span class="string">)</span></span><br><span class="line"><span class="attr">Recommends:</span> <span class="string">libncursesw5</span> <span class="string">(&gt;=</span> <span class="number">6</span><span class="string">),</span> <span class="string">libpcre3</span></span><br><span class="line"><span class="attr">Suggests:</span> <span class="string">zsh-doc</span></span><br><span class="line"><span class="attr">Homepage:</span> <span class="string">http://www.zsh.org/</span></span><br><span class="line"><span class="attr">Supported:</span> <span class="string">5y</span></span><br><span class="line"><span class="attr">Download-Size:</span> <span class="number">651</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">APT-Sources:</span> <span class="string">http://cn.archive.ubuntu.com/ubuntu</span> <span class="string">xenial/main</span> <span class="string">amd64</span> <span class="string">Packages</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">具有很多特性的</span> <span class="string">Shell</span></span><br><span class="line"> <span class="string">Zsh</span> <span class="string">是一个既可用作登录</span> <span class="string">Shell，又可用于执行脚本的命令解析器。</span> <span class="string">在标准</span> <span class="string">Shell</span> <span class="string">中</span> <span class="string">Zsh</span> <span class="string">与</span> <span class="string">Ksh</span></span><br><span class="line"> <span class="string">最相近，同时又带有许多改进。Zsh</span> <span class="string">支持命令行编辑，内置拼写纠正，支持可编程命令补全、带自动加载的</span> <span class="string">Shell</span> <span class="string">函数、历史功能和大量其他特性。</span></span><br></pre></td></tr></table></figure>

<p>总之就是各种命令清晰漂亮了很多，个人用起来很舒服。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a><a href="/tags/运维/">运维</a><a href="/tags/ubuntu/">ubuntu</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/05/28/是时候用apt代替apt-get了！/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/05/25/用elasticsearch给博客加上了搜索/"><span>用 elasticsearch 给博客加上了搜索</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/25/用elasticsearch给博客加上了搜索/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-25T14:21:11.000Z">
          2016-05-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>博客从 Wordpress 迁移过来之后一直缺少一个搜索功能，这个博客我是当做笔记性质的，有时候脑子里突然想不起某个东西的时候就上来查一下。没有搜索还是很不方便的，所以费了点时间研究了下大名鼎鼎的 elasticsearch 配合 golang 给博客加上了搜索功能。</p>
<p><a href="/notename/" title="add internal search to your blog using elasticsearch"></a></p>
<h2 id="elasticsearch-介绍"><a href="#elasticsearch-介绍" class="headerlink" title="elasticsearch 介绍"></a>elasticsearch 介绍</h2><p>elasticsearch 是一个 java 编写的搜索和分析引擎，功能十分强大。但是并不意味着你的程序必须使用 java 开发，elasticsearch 是一个独立运行的程序，它会开放一个 RESTful 的接口供人调用，所以使用起来十分方便，甚至使用 curl 就能对它进行访问。另外，elasticsearch 的可伸缩性也很吸引我，使用 elasticsearch 组建一个集群十分方便，只需要把几个 elasticsearch 放到同一个局域网内就可以了，不用做任何配置你就能跑起来一个集群。这样，当你的数据量或者并发量增大的时候，只需要简单的购买几台新服务器就能解决性能问题。</p>
<p>我是通过 <a href="http://es.xiaoleilu.com/" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版）</a> 这本书来学习的，也推荐大家看一看，比我讲的好。</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>elasticsearch 中有几个基本概念，大概可以和数据库的这几个概念对应起来（如下表）。但是有一点需要注意，elasticsearch 中不会限制数据必须存在一个二维表中，你可以保存一个对象，一个数组，一个字符串，或者一个整数，就像一个 JSON 一样，十分灵活。事实上，elasticsearch 的通讯协议确实是使用 JSON 的。</p>
<p>| 数据库 | elasticsearch |<br>|  |  |<br>| Databases | 索引（Indices） |<br>| Tables | 类型（Types） |<br>| Rows | 文档（Documents） |<br>| Columns | 字段（Fields） |<br>| schema | Mapping |</p>
<p>在 elasticsearch 中保存的每条记录叫一个 <code>document</code> ，它可以是一个包含很多字段的对象，默认情况下每个字段都能被搜索。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>使用 curl 就可以对 elasticsearch 进行操作，但是我还是推荐一个 chrome 应用 <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener" title="postman 的下载链接"><code>postman</code></a> ，有 JSON 语法高亮和检测，还可以保存历史记录。</p>
<p><img src="http://static.zybuluo.com/zwh8800/ohw9r0kvh69o6stu45td81sj/90.pic_hd.jpg" alt="90.pic_hd.jpg-1070kB"></p>
<h4 id="索引一条记录"><a href="#索引一条记录" class="headerlink" title="索引一条记录"></a>索引一条记录</h4><p>在 elasticsearch 中存储数据的行为叫做 <code>索引（index）</code> 。使用 HTTP 协议的 PUT 动词可以存储数据。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="symbol">http:</span>/<span class="regexp">/localhost:9200/mdblog</span><span class="regexp">/note/</span><span class="number">23432</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="string">"notename"</span>: <span class="string">"golang-china-download-mirror"</span>,</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"做了个 golang 安装包的镜像"</span>,</span><br><span class="line">    <span class="string">"content"</span>: <span class="string">"做了个 golang 安装包的镜像 闲扯 golang\n        \n        2016-05-25 16:04 PM\n    鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。地址在这里：https://lengzzz.com/download/golang/包含了 golang 1.5 之后的所有版本，所有平台的安装包和源码包都放在里面，自行 control + f 搜一下吧。新版本的 golang release 之后，应该在一两天内可以拉取过来。欢迎使用。"</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"2016-05-25T08:04:53Z"</span>,</span><br><span class="line">    <span class="string">"lastModified"</span>: <span class="string">"2016-05-25T09:01:42.923822162Z"</span>,</span><br><span class="line">    <span class="string">"tagList"</span>: [</span><br><span class="line">      <span class="string">"golang"</span>,</span><br><span class="line">      <span class="string">"闲扯"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上，把要存储的数据写成一个 JSON 对象，放到 HTTP 的 Body 中传送给 elasticsearch 即可存储数据。</p>
<p>我们可以看到 url 中包含了 4 部分的信息。</p>
<p>| 名字 | 信息 |<br>|  |  |<br>| localhost:9200 | Elasticsearch 的 url |<br>| mdblog | 索引名（Index） |<br>| note | 类型名（Type） |<br>| 23432 | 文档ID（Document ID） |</p>
<p>很方便吧。</p>
<h4 id="获取一条记录"><a href="#获取一条记录" class="headerlink" title="获取一条记录"></a>获取一条记录</h4><p>大家应当已经想到了，使用 GET 动词。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="regexp">//</span>localhost:<span class="number">9200</span><span class="regexp">/mdblog/</span>note<span class="regexp">/23432</span></span><br></pre></td></tr></table></figure>

<p>返回的信息会多一些 metadata 。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"mdblog"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"note"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"389344"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">"notename"</span>: <span class="string">"golang-china-download-mirror"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"做了个 golang 安装包的镜像"</span>,</span><br><span class="line">    <span class="attr">"content"</span>: <span class="string">"做了个 golang 安装包的镜像 闲扯 golang\n        \n        2016-05-25 16:04 PM\n    鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。地址在这里：https://lengzzz.com/download/golang/包含了 golang 1.5 之后的所有版本，所有平台的安装包和源码包都放在里面，自行 control + f 搜一下吧。新版本的 golang release 之后，应该在一两天内可以拉取过来。欢迎使用。"</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2016-05-25T08:04:53Z"</span>,</span><br><span class="line">    <span class="attr">"lastModified"</span>: <span class="string">"2016-05-25T09:01:42.923822162Z"</span>,</span><br><span class="line">    <span class="attr">"tagList"</span>: [</span><br><span class="line">      <span class="string">"golang"</span>,</span><br><span class="line">      <span class="string">"闲扯"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>搜索的话可以使用 <code>查询 DSL</code> 进行，说是 DSL（领域特定语言） 听起来很吓人，实际上就是几个 JSON 对象的组合而已。</p>
<p>调用搜索接口需要在 url 后面加一个 <code>_search</code> 。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:<span class="number">9200</span>/mdblog/note/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : "<span class="type">linux</span><span class="string">"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样，就可以使用 match 查询进行查询了。</p>
<p>结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0.6609862</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"mdblog"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"note"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"340165"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">0.6609862</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="attr">"notename"</span>: <span class="string">"add-swap-on-linux"</span>,</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"在Linux下设置swap"</span>,</span><br><span class="line">          <span class="attr">"content"</span>: <span class="string">"在Linux下设置swap linux\n        \n        2016-04-10 15:53 PM\n    今早起来发现博客的数据库挂了，赶紧用手机上的ConnectBot连上去把mysql启动。看了下日志大概是因为内存不够用且没设置swap，所以mysql进程申请不到内存挂了（小内存服务器桑不起）所以赶紧把swap搞上，这样至少能让服务不轻易挂掉。这里记录一下，以备遗忘。大概分三步\n生成一个空文件\n把文件格式化成swap格式\n挂载\n"</span>,</span><br><span class="line">          <span class="attr">"timestamp"</span>: <span class="string">"2016-04-10T07:53:58Z"</span>,</span><br><span class="line">          <span class="attr">"lastModified"</span>: <span class="string">"2016-05-24T05:27:01.435772194Z"</span>,</span><br><span class="line">          <span class="attr">"tagList"</span>: [</span><br><span class="line">            <span class="string">"linux"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，我们可以为搜索加上高亮：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:<span class="number">9200</span>/mdblog/note/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : "<span class="type">linux</span><span class="string">"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "</span>highlight<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>pre_tags<span class="string">" : ["</span>&lt;b&gt;<span class="string">"],</span></span><br><span class="line"><span class="string">        "</span>post_tags<span class="string">" : ["</span>&lt;/b&gt;<span class="string">"],</span></span><br><span class="line"><span class="string">        "</span>fields<span class="string">" : &#123;</span></span><br><span class="line"><span class="string">            "</span>title<span class="string">" : &#123;&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样的话，在 hit 中会有一个 <code>highlight</code> 字段，所有关键字会用 <code>&lt;b&gt;&lt;/b&gt;</code> 扩起来。</p>
<h4 id="创建-mapping"><a href="#创建-mapping" class="headerlink" title="创建 mapping"></a>创建 mapping</h4><p>默认情况下 elasticsearch 是不需要“建表”操作的。mapping（类似数据库的表结构）会在第一次 index 的时候建立。但是提前建立 mapping 有助于查询。建立 mapping 也是使用 PUT 动词。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="symbol">http:</span>/<span class="regexp">/localhost:9200/mdblog</span><span class="regexp">/note/</span>_mapping</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"note"</span>: &#123;</span><br><span class="line">		<span class="string">"properties"</span>: &#123;</span><br><span class="line">			<span class="string">"id"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"long"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">"title"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">				<span class="string">"term_vector"</span>: <span class="string">"with_positions_offsets"</span>,</span><br><span class="line">				<span class="string">"analyzer"</span>: <span class="string">"ik_syno"</span>,</span><br><span class="line">				<span class="string">"search_analyzer"</span>: <span class="string">"ik_syno"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">"content"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">				<span class="string">"term_vector"</span>: <span class="string">"with_positions_offsets"</span>,</span><br><span class="line">				<span class="string">"analyzer"</span>: <span class="string">"ik_syno"</span>,</span><br><span class="line">				<span class="string">"search_analyzer"</span>: <span class="string">"ik_syno"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">"notename"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">"tagList"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">				<span class="string">"term_vector"</span>: <span class="string">"with_positions_offsets"</span>,</span><br><span class="line">				<span class="string">"analyzer"</span>: <span class="string">"ik_syno"</span>,</span><br><span class="line">				<span class="string">"search_analyzer"</span>: <span class="string">"ik_syno"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">"timestamp"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">				<span class="string">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">"lastModified"</span>: &#123;</span><br><span class="line">				<span class="string">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">				<span class="string">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，建立一个 mapping 。主要是设置一下数据类型和查询方式。</p>
<h2 id="在-golang-中使用"><a href="#在-golang-中使用" class="headerlink" title="在 golang 中使用"></a>在 golang 中使用</h2><p>在 golang 中有方便的 package 来操纵 elasticsearch。我使用的是 <a href="https://github.com/olivere/elastic" target="_blank" rel="noopener"><code>gopkg.in/olivere/elastic.v3</code></a> 还不错的一个包，所有操作都是链式调用，很有 linq 的感觉。</p>
<p>使用 elastic 需要先创建一个客户端：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitElasticSearch</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	esClient, err = elastic.NewClient(</span><br><span class="line">	    elastic.SetURL(<span class="string">"http://localhost:9200"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就可以用 client 进行操作了。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">noteDetail := model.NoteDetail&#123;</span><br><span class="line">	Id:           note.Id,</span><br><span class="line">	Notename:     note.Notename,</span><br><span class="line">	Title:        note.Title,</span><br><span class="line">	Content:      note.ContentText(),</span><br><span class="line">	Timestamp:    note.Timestamp,</span><br><span class="line">	LastModified: note.LastModified,</span><br><span class="line">	TagList:      tagNameList,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先调用 Index 函数，代表这是一次索引（Index）操作</span></span><br><span class="line"><span class="comment">// 接着提供各种参数</span></span><br><span class="line">_, err := esClient.Index().</span><br><span class="line">	Index(MdBlogIndexName).</span><br><span class="line">	Type(NoteTypeName).</span><br><span class="line">	Id(strconv.FormatInt(note.UniqueId, <span class="number">10</span>)).</span><br><span class="line">	BodyJson(noteDetail).</span><br><span class="line">	Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引一条记录</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNoteDocumentExist</span><span class="params">(uniqueId <span class="keyword">int64</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> esClient.Exists().</span><br><span class="line">		Index(MdBlogIndexName).</span><br><span class="line">		Type(NoteTypeName).</span><br><span class="line">		Id(strconv.FormatInt(uniqueId, <span class="number">10</span>)).</span><br><span class="line">		Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是否存在</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchNoteByKeyword</span><span class="params">(keyword <span class="keyword">string</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    page, limit <span class="keyword">int64</span>)</span> <span class="params">([]*model.SearchedNote, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	page-- <span class="comment">//数据库层的页数从0开始数</span></span><br><span class="line">	offset := page * limit</span><br><span class="line"></span><br><span class="line">	query := elastic.NewMultiMatchQuery(keyword).</span><br><span class="line">		FieldWithBoost(<span class="string">"notename"</span>, <span class="number">1</span>).</span><br><span class="line">		FieldWithBoost(<span class="string">"tagList"</span>, <span class="number">2</span>).</span><br><span class="line">		FieldWithBoost(<span class="string">"content"</span>, <span class="number">4</span>).</span><br><span class="line">		FieldWithBoost(<span class="string">"title"</span>, <span class="number">4</span>)</span><br><span class="line">	highlight := elastic.NewHighlight().</span><br><span class="line">		Field(<span class="string">"content"</span>).</span><br><span class="line">		Field(<span class="string">"title"</span>).</span><br><span class="line">		Field(<span class="string">"tagList"</span>)</span><br><span class="line"></span><br><span class="line">	result, err := esClient.Search().</span><br><span class="line">		Index(MdBlogIndexName).</span><br><span class="line">		Type(NoteTypeName).</span><br><span class="line">		Query(query).</span><br><span class="line">		Highlight(highlight).</span><br><span class="line">		From(<span class="keyword">int</span>(offset)).</span><br><span class="line">		Size(<span class="keyword">int</span>(limit)).</span><br><span class="line">		Do()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result.Hits == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	maxPage := (result.TotalHits()<span class="number">-1</span>)/limit + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	noteList := <span class="built_in">make</span>([]*model.SearchedNote, <span class="number">0</span>, <span class="built_in">len</span>(result.Hits.Hits))</span><br><span class="line">	<span class="keyword">for</span> _, hit := <span class="keyword">range</span> result.Hits.Hits &#123;</span><br><span class="line">		note := model.NewSearchedNote()</span><br><span class="line">		err := json.Unmarshal(*hit.Source, note)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		note.FillHighlight(hit.Highlight)</span><br><span class="line"></span><br><span class="line">		noteList = <span class="built_in">append</span>(noteList, note)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> noteList, maxPage, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索记录</p>
<h2 id="´-・ω・｀"><a href="#´-・ω・｀" class="headerlink" title="(´ ・ω・｀)"></a>(´ ・ω・｀)</h2><p>总的来说，elasticsearch 还是很方便强大的，好评。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/elasticsearch/">elasticsearch</a><a href="/tags/搜索引擎/">搜索引擎</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/05/25/用elasticsearch给博客加上了搜索/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/05/25/做了个golang安装包的镜像/"><span>做了个 golang 安装包的镜像</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/25/做了个golang安装包的镜像/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-25T07:57:16.000Z">
          2016-05-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>鉴于国情，国内下载 golang 安装包还是挺蛋疼的，就算使用代理速度也比较感人。虽然现在 docker 镜像是个比较好的选择，但还是有很多场景需要原始的 golang 环境的。所以抽空做了个 mirror ，定时拉取 golang 官网的安装包到我的服务器上。</p>
<p><a href="/notename/" title="golang china download mirror"></a></p>
<p>地址在这里：<a href="https://lengzzz.com/download/golang/">https://lengzzz.com/download/golang/</a></p>
<p>包含了 golang 1.5 之后的所有版本，所有平台的安装包和源码包都放在里面，自行 <code>control + f</code> 搜一下吧。新版本的 golang release 之后，应该在一两天内可以拉取过来。</p>
<p>欢迎使用。</p>
<p><img src="http://static.zybuluo.com/zwh8800/irj91ef52ump2v4ap7b2bti2/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%20%E4%B8%8B%E5%8D%884.06.56.png" alt="屏幕快照 2016-05-25 下午4.06.56.png-311.7kB"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/闲扯/">闲扯</a><a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/05/25/做了个golang安装包的镜像/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/05/24/LinuxShell编程中的trap的小坑/"><span>Linux Shell 编程中的 trap 的小坑</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/24/LinuxShell编程中的trap的小坑/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-24T10:58:33.000Z">
          2016-05-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在 Shell 编程中，为了脚本的健壮性，一般会用到 <code>trap</code> 这个 builtin command。trap 命令类似 c 语言中的 <code>signal</code> 函数，可以注册一个函数，当程序收到信号时执行函数。但是 trap 命令也有一些比较坑的小细节，比如 trap 的执行时机。</p>
<p><a href="/notename/" title="trap&#39;s trap in linux shell programing"></a></p>
<p>在 c 语言中，程序收到信号之后会立即执行 signal 注册的信号处理函数。那么在 shell 程序中呢，信号究竟什么时候被 trap 处理？是像 c 程序一样停下程序立即执行，还是等待当前程序执行之后再执行？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">'echo "signal received!"; exit'</span> INT</span><br><span class="line">sleep 100</span><br></pre></td></tr></table></figure>

<p>我们先写一段程序做个实验。在 bash 中执行它，然后按 <code>control + c</code> 发现程序立即停止了，然后打印了 signal received，似乎 trap 是类似 c 程序一样立即处理信号的。但其实是被表面现象蒙骗了。</p>
<p>我们再次执行这个 shell 程序，然后打开另一个 shell，在里面执行 <code>kill -SIGINT xxx</code> 发现 shell 程序并没有退出，等待了 100 秒之后才打印 signal received 退出。</p>
<p>因为第一次在键盘上按 <code>control + c</code> 后，sleep 程序和 shell 程序同属一个进程组，所以也接到了 int 信号退出了，而第二次只有 shell 程序收到信号，所以造成了两者的差异。我第一次也被蒙骗了，傻乎乎的以为 trap 能在 sleep 时也处理信号。</p>
<p>那么问题来了，我们如果需要在 sleep 时处理信号，并且及时退出怎么办呢？国外一篇文章给了例子<a href="http://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener">^sample</a>，我就负责搬运一下了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid=</span><br><span class="line"><span class="built_in">trap</span> <span class="string">'[[ $pid ]] &amp;&amp; kill $pid'</span> EXIT</span><br><span class="line">sleep 10000 &amp; pid=$!</span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line">pid=</span><br></pre></td></tr></table></figure>

<p>利用了 bash 的 builtin 命令 wait。wait 是一个 shell 内部的命令，而不是一个外部程序，所以它没有前面的限制。另外，要记得退出时 kill 掉 sleep 进程，擦好屁股。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a><a href="/tags/bash/">bash</a><a href="/tags/shell/">shell</a><a href="/tags/trap/">trap</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/05/24/LinuxShell编程中的trap的小坑/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/05/14/CloudXNS-DDNS动态域名客户端docker镜像/"><span>CloudXNS-DDNS 动态域名客户端 docker 镜像</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/14/CloudXNS-DDNS动态域名客户端docker镜像/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-14T07:15:34.000Z">
          2016-05-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近<a href="https://lengzzz.com/note/the-domain-hosting-to-cloudxns-perfect-supporting-the-let-s-encrypt">换上</a>了 CloudXNS 的域名服务。以前使用花生壳的时候比较方便，大多数路由器都支持，而且还提供了 Linux 下的客户端源码供定制。换上 CloudXNS 之后这些方便的东西当然没有了，不过 CloudXNS 也提供了 API，作为程序员当然要自己写一个了。这篇文章是这个 CloudXNS DDNS 客户端的使用介绍。</p>
<p><a href="/notename/" title="a docker image for CloudXNS DDNS"></a></p>
<p>客户端是使用 golang 开发的，放到了 <a href="https://github.com/zwh8800/cloudxns-ddns" target="_blank" rel="noopener"><i class="icon-github"></i> github 上 <sub>https://github.com/zwh8800/cloudxns-ddns</sub></a>。需要的可以自己编译，不过我已经做好了 <a href="https://hub.docker.com/r/zwh8800/cloudxns-ddns" target="_blank" rel="noopener">docker 镜像 <sub>https://hub.docker.com/r/zwh8800/cloudxns-ddns</sub></a> 了可以直接使用。</p>
<p>首先，拉取镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zwh8800/cloudxns-ddns</span><br></pre></td></tr></table></figure>

<p>然后，编写一个很简单的配置文件，放到某个文件夹中（如/home/zzz/cloudxns-ddns/config，下面以此为例子)</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[CloudXNS]</span></span><br><span class="line"><span class="attr">APIKey</span>=<span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span></span><br><span class="line"><span class="attr">SecureKey</span>=<span class="string">"xxxxxxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Domain]</span></span><br><span class="line"><span class="attr">Data</span>=<span class="string">"home.lengzzz.com"</span></span><br><span class="line"><span class="attr">Data</span>=<span class="string">"haha.lengzzz.com"</span></span><br></pre></td></tr></table></figure>

<p>上面 <code>APIKey</code> 是你在 <a href="https://www.cloudxns.net/AccountManage/apimanage.html" target="_blank" rel="noopener">CloudXNS <sub>https://www.cloudxns.net/AccountManage/apimanage.html</sub></a> 申请的 key，填进去即可。下面是你想要动态的域名，可以写很多。</p>
<p>然后，启动镜像即可。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name cloudxns-ddns -d -v /home/zzz/cloudxns-ddns/log:/app/log -v /home/zzz/cloudxns-ddns/config:/app<span class="built_in">/config </span>zwh8800/cloudxns-ddns</span><br></pre></td></tr></table></figure>

<p>注意一点，需要把刚写的配置文件当作 <code>volumn</code> 挂载到容器上，如上 <code>-v /home/zzz/cloudxns-ddns/config:/app/config</code> 。这样的话，你可以方便的修改配置文件然后 <code>docker restart cloud-ddns</code> 。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/CloudXNS/">CloudXNS</a><a href="/tags/DDNS/">DDNS</a><a href="/tags/docker/">docker</a><a href="/tags/动态DNS/">动态DNS</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/05/14/CloudXNS-DDNS动态域名客户端docker镜像/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/05/01/把域名托管到CloudXNS了，完美支持let'sencrypt/"><span>把域名托管到 CloudXNS 了，完美支持 let&#39;s encrypt</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/01/把域名托管到CloudXNS了，完美支持let'sencrypt/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-01T08:41:51.000Z">
          2016-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://lengzzz.com">lengzzz.com</a> 这个域名我已经用了6年了，当年年少无知用了 oray 的服务，就为了一个花生壳的功能（tplink自带花生壳）。现在越发感觉 oray 的服务质量不很好。各省解析速度不一，国外就更慢了。尤其是不支持 <code>let&#39;s encrypt</code> 让我好生郁闷。所以赶紧换上了 CloudXNS 。</p>
<p>CloudXNS 的页面就看着比较顺眼。据说 DNSPod 也不错，但是我感觉网页太丑了，就没有使用它，哈哈，所以证明一句话 <strong>你的颜值决定了别人会不会去发现你的内心</strong> 。</p>
<p><img src="http://static.zybuluo.com/zwh8800/gmz55dfpsc6k07y0ctrcf80y/QQ20160501-0@2x.png" alt="QQ20160501-0@2x.png-321.5kB"></p>
<p>注册了之后发现使用超级方便，只给你显示了一个超大的输入框，让你输入自己的域名。</p>
<p><img src="http://static.zybuluo.com/zwh8800/cpgnk0wkgntpg08az7heqecr/QQ20160501-1@2x.png" alt="QQ20160501-1@2x.png-43.7kB"></p>
<p>输入之后，就进入了控制台节目了，好像你的域名已经托管在 CloudXNS 上了一样，当你设置好解析之后，只需要把之前域名的 NS 地址设置到 CloudXNS 上就好了。整个用户体验相当舒服。</p>
<p>设置好之后，控制台上会实时显示接管状态。不过5分钟，就可以用了。立即用 let’s encrypt 更新一下 ssl 证书。果然可以用了。</p>
<p><img src="http://static.zybuluo.com/zwh8800/a3cvhjcpf7v0d965cnxeceqo/QQ20160501-2@2x.png" alt="QQ20160501-2@2x.png-70.3kB"></p>
<p>最后来张测速图吧。</p>
<p><img src="http://static.zybuluo.com/zwh8800/nh72858jdjk7fwt42x1us6rp/QQ20160501-3@2x.png" alt="QQ20160501-3@2x.png-138.9kB"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/CloudXNS/">CloudXNS</a><a href="/tags/闲扯/">闲扯</a><a href="/tags/DNS/">DNS</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/05/01/把域名托管到CloudXNS了，完美支持let'sencrypt/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/3/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 wastecat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47471611-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>