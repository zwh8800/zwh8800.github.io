<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>linux 设备驱动程序 (4) – 并发 | wastecat的博客</title>

  
  <meta name="author" content="wastecat">
  

  
  <meta name="description" content="linux 设备驱动程序 (4) – 并发

进行 linux 驱动开发不得不考虑的问题就是并发问题. 因为在内核态, 代码是可抢占的, 你不知道什么时候内核会抢占你对 CPU 的使用权来执行另一段代码 (这段代码可能会修改掉你的数据). 而且现在大多使用 SMP(对称多处理器), 代码甚至可以同时">
  

  
  
  <meta name="keywords" content="linux,驱动开发">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="linux 设备驱动程序 (4) – 并发"/>

  <meta property="og:site_name" content="wastecat的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wastecat的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">wastecat的博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>linux 设备驱动程序 (4) – 并发</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/02/17/linux设备驱动程序(4)–并发/" rel="bookmark">
        <time class="entry-date published" datetime="2014-02-17T00:00:00.000Z">
          2014-02-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>linux 设备驱动程序 (4) – 并发</p>
<p><a href="/notename/" title="archive 20140217"></a></p>
<p>进行 linux 驱动开发不得不考虑的问题就是并发问题. 因为在内核态, 代码是可抢占的, 你不知道什么时候内核会抢占你对 CPU 的使用权来执行另一段代码 (这段代码可能会修改掉你的数据). 而且现在大多使用 SMP(对称多处理器), 代码甚至可以同时执行. 性能得到了很大提升但是编程的复杂程度也高了很多. 特别是在如何防止数据被其他执行线程修改上. 幸运的是, linux 已经提供了很多设施来完成这个功能.</p>
<h3 id="1-信号量-amp-互斥体"><a href="#1-信号量-amp-互斥体" class="headerlink" title="1. 信号量 &amp; 互斥体"></a>1. 信号量 &amp; 互斥体</h3><p>这个在多线程编程中太常见了, 就不赘述了. 另外记一下 semaphore 这个单词, 总是拼错.</p>
<p>列一下函数原型:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;linux/semaphore.h&gt; <span class="comment">/* 不像书中所写</span></span><br><span class="line"><span class="comment">				并没有&lt;asm/semaphore.h&gt; */</span></span><br><span class="line">void sema<span class="constructor">_init(<span class="params">struct</span> <span class="params">semaphore</span> <span class="operator">*</span><span class="params">sem</span>, <span class="params">int</span> <span class="params">val</span>)</span>;</span><br><span class="line">void down(<span class="keyword">struct</span> semaphore *sem);</span><br><span class="line"><span class="built_in">int</span> down<span class="constructor">_interruptible(<span class="params">struct</span> <span class="params">semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> down<span class="constructor">_trylock(<span class="params">struct</span> <span class="params">semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line">void up(<span class="keyword">struct</span> semaphore *sem);</span><br><span class="line"> </span><br><span class="line">void init<span class="constructor">_rwsem(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line">void down<span class="constructor">_read(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> down<span class="constructor">_read_trylock(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line">void up<span class="constructor">_read(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line">void down<span class="constructor">_write(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> down<span class="constructor">_write_trylock(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line">void up<span class="constructor">_write(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line">void downgrade<span class="constructor">_write(<span class="params">struct</span> <span class="params">rw_semaphore</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>&lt;&lt;linux 设备驱动程序&gt;&gt; 上所说的 init_MUTEX 函数貌似在新版本中已经删掉了, 可以用 sema_init(&amp;sem, 1); 来代替.<br>down_interruptible 函数当被中断时会返回非零值, down_trylock 当信号量不可获得时会返回非零值.</p>
<h3 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2. 自旋锁"></a>2. 自旋锁</h3><p>当对信号量执行 down 函数时, 如果当前无法获取信号量, 会阻塞当前执行线程, 但是并非 CPU 空转不工作. 而是” 进入休眠”. 进入休眠是一个有明确定义的术语. 当” 进入休眠” 时, 执行线程会进入休眠状态, 这时会把 CPU 让给其他执行线程知道将来它能获取信号量为止.</p>
<p>但是自旋锁不一样, 当线程对自旋锁进行” 锁定” 动作时, 如果自旋锁已经被其他线程锁定, 那么当前线程将进行” 自旋”. 所谓自旋, 其实就是一个 while 循环 [它循环重复检查这个锁直到锁可用为止]. 所以说可见自旋锁当锁定时不会让出 CPU.</p>
<p>所以自旋锁简单, 而且也比信号量快 (因为不用设计到 CPU 调度). 但是使用却有一些限制:</p>
<ul>
<li>考虑当前系统是单处理器非抢占系统, 那么如果一个线程进入自旋状态, 那么因为没有抢占其他线程得不到执行, 所以无法解锁自旋锁. 那么这个线程会一直循环下去. 整个系统会被卡死. <span style="color: #0000ff;"><strong>所以在非抢占式单处理器系统上自旋锁被优化为不做任何事.</strong></span></li>
<li> 考虑在一个单处理器抢占式系统上. 一个线程获得了一个自旋锁, 然后再临界区执行时丢掉了 CPU(可能被抢占, 可能调用了进入休眠的函数). 如果获得 CPU 的线程也想获取那个自旋锁, 那么整个系统会死锁下去. <strong><span style="color: #0000ff;">所以为了避免这个, 当一个线程获得自旋锁之后<span style="color: #ff0000;">此线程所在的 CPU</span> 的抢占会被禁止.</span></strong> 另外,<strong><span style="color: #ff0000;"> 人们要注意不要再获得自旋锁之后执行会丢掉 CPU 的函数.</span></strong></li>
<li> 另外, 当线程获得自旋锁之后, 发生了中断, 中断例程也请求获取自旋锁, 这时整个系统也会进入死锁. <strong><span style="color: #0000ff;">可以在获取锁时关闭当前 CPU 中断来解决.</span></strong></li>
<li> 最后, 自旋锁的重要准则是: “<strong>自旋锁必须在可能的最短时间内拥有</strong> “</li>
</ul>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;linux/spinlock.h&gt;</span><br><span class="line"> </span><br><span class="line">spinlock_t lock = SPIN_LOCK_UNLOCKED;</span><br><span class="line">void spin<span class="constructor">_lock_init(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line"> </span><br><span class="line">void spin<span class="constructor">_lock(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line">void spin<span class="constructor">_lock_irqsave(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>, <span class="params">unsigned</span> <span class="params">long</span> <span class="params">flags</span>)</span>;</span><br><span class="line">void spin<span class="constructor">_lock_irq(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line">void spin<span class="constructor">_lock_bh(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line"> </span><br><span class="line">void spin<span class="constructor">_unlock(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line">void spin<span class="constructor">_unlock_irqsave(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>, <span class="params">unsigned</span> <span class="params">long</span> <span class="params">flags</span>)</span>;</span><br><span class="line">void spin<span class="constructor">_unlock_irq(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line">void spin<span class="constructor">_unlock_bh(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> spin<span class="constructor">_trylock(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> spin<span class="constructor">_trylock_bh(<span class="params">spinlock_t</span> <span class="operator">*</span><span class="params">lock</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>irqsave 会将中断状态保存在 flags 中, 当 unlock 时必须提供同一个 flags.</p>
<p>irq 函数会禁止本处理器的中断.</p>
<p>bh 会关闭软中断.</p>
<p>同样, 自旋锁有 rw 版本.</p>
<h3 id="3-使用锁的一些准则与陷阱"><a href="#3-使用锁的一些准则与陷阱" class="headerlink" title="3. 使用锁的一些准则与陷阱"></a>3. 使用锁的一些准则与陷阱</h3><ul>
<li>在编写函数时, 被调用的函数不能锁定此函数中一定锁定的锁否则会造成死锁. 所以当编写那些假定调用者已经获取锁的函数时,<span style="color: #0000ff;"><strong> 最好在注释中写明</strong></span>, 在此函数被调用之前调用者已经加锁. 防止几个月后重写时在函数中误加锁造成死锁. <strong><span style="color: #0000ff;">[最好养成习惯只在某一类函数中加锁 (如只在系统调用直接调用的函数中加锁)]</span></strong></li>
<li> 必须同时获取多个锁时, 最好都按照一定顺序获取.</li>
<li> 先获取局部的锁, 再获取全局的锁.</li>
<li> 先获取信号量, 再获取自旋锁.</li>
</ul>

<h3 id="4-循环队列"><a href="#4-循环队列" class="headerlink" title="4. 循环队列"></a>4. 循环队列</h3><p>使用循环队列是一种免锁算法. 生产者在队列的一端中写入, 消费者从另一端取走. 如果设计的好, 可以不必使用锁.</p>
<p>在 &lt;linux/kfifo.h&gt; 中有实现好的循环队列.</p>
<h3 id="5-原子变量"><a href="#5-原子变量" class="headerlink" title="5. 原子变量"></a>5. 原子变量</h3><p>当对一个简单的整数进行加减的时候也加锁显得有些小题大做了. 但是很多整数运算确实不是原子的, 如 ++i;</p>
<p>所以 linux 内核实现了原子类型 atomic_t 来进行高效的原子的整形运算.</p>
<p>具体参见 &lt;asm/atomic.h&gt;</p>
<h3 id="6-原子位操作"><a href="#6-原子位操作" class="headerlink" title="6. 原子位操作"></a>6. 原子位操作</h3><p>除了原子的整数变量, 内核也提供了原子的位操作类型和函数. 集体参见 &lt;asm/bitops.h&gt;</p>
<h3 id="7-seqlock"><a href="#7-seqlock" class="headerlink" title="7.seqlock"></a>7.seqlock</h3><h3 id="8-读取-复制-更新-RCU"><a href="#8-读取-复制-更新-RCU" class="headerlink" title="8. 读取 - 复制 - 更新 (RCU)"></a>8. 读取 - 复制 - 更新 (RCU)</h3>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a><a href="/tags/驱动开发/">驱动开发</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'lengzzz';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 wastecat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47471611-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>