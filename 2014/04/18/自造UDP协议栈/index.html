<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>自造 UDP 协议栈 | wastecat的博客</title>

  
  <meta name="author" content="wastecat">
  

  
  <meta name="description" content="自造 UDP 协议栈

这一个星期一直在自造一个 UDP 协议栈.
今天是周五, 屁屁和室友逛街去了, 我就在寝室敲代码搞了一下午, 终于是搞定了.
这个是老师的项目里要用的, 实现 avr 的单片机和 PC 机通讯. 中间通过以太网进行连接, avr 上用的是 enc28j60 芯片. 这个芯片原">
  

  
  
  <meta name="keywords" content="协议栈,网络编程,UDP">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="自造 UDP 协议栈"/>

  <meta property="og:site_name" content="wastecat的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wastecat的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">wastecat的博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/2020/04/29/hello-world/">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>自造 UDP 协议栈</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/04/18/自造UDP协议栈/" rel="bookmark">
        <time class="entry-date published" datetime="2014-04-18T00:00:00.000Z">
          2014-04-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>自造 UDP 协议栈</p>
<p><a href="/notename/" title="archive 20140418"></a></p>
<p>这一个星期一直在自造一个 UDP 协议栈.</p>
<p>今天是周五, 屁屁和室友逛街去了, 我就在寝室敲代码搞了一下午, 终于是搞定了.</p>
<p>这个是老师的项目里要用的, 实现 avr 的单片机和 PC 机通讯. 中间通过以太网进行连接, avr 上用的是 enc28j60 芯片. 这个芯片原来我在 C8051F 上写过一个驱动. 移植过来倒是不麻烦, 半天搞定.</p>
<p>麻烦的是协议栈!</p>
<p>原来在 51 上用的是一个我精简了的 uIP 协议栈, 因为 C8051F 系列 FLASH 足够大, 而且 ram 也大 (f340 有 4096 字节). 足够移植 uIP 过去了.</p>
<p>在 avr 上遇了不少麻烦.</p>
<p>首先就是蛋疼的 codevision 编译器乱改 C 语言, 不按标准来. const 修饰的变量没法直接访问. 移植起来很麻烦. 然后就是 uIP 的 ram 占用一直下不去. 我已经把以太网最大帧长度调成 512 了还是费了 1100 多个字节. 然后很不幸, ATMega16 只有 1024 字节的 RAM. 可恶的 uIP 竟然用去了 512 个字节… 知道 RAM 有多宝贵嘛你!</p>
<p>想想算了, 还是换个内存大点的吧. 周一给老师要了 ATMEGA32, 想着鸟枪换炮! 不料, 老师给了我张板子, 说” 自己焊吧”……</p>
<p>贴片的本身就不容易焊, 况且我烙铁吃灰 n 久了脏死了完全不想动呀! (我这个死洁癖!)</p>
<p>切! 想想我也是立志成为驱动工程师的男人, 这种小事应该交给硬件工程师来做嘛, 哼╭(╯^╰)╮(无任何冒犯…)</p>
<p>所以嘛这点困难完全难不倒我! 开源的不行我就自己写一个嘛.</p>
<p>自己动手丰衣足食.</p>
<p>↑一点都不华丽的分割线</p>
<p>自己造轮子的话最大的好处就是可以<span style="color: red">紧密把握需求</span>, 只写需要的功能, 不需要的一概不写! 另外因为对内存需求比较严格, 所以这个协议栈<span style="color: red">几乎是不占内存</span>, 除了 6 个 ip 地址 7 个 mac 地址常驻内存以外, 全部使用栈内存.</p>
<p>这个协议栈最大的特点就是简洁, 只有两个文件构成: udp.c, 和 udp.h<br>而且接口设计的也比较简洁, 只向外部提供三个函数:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_udp</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* mac_addr, <span class="keyword">ip_t</span> ip_addr, <span class="keyword">ip_t</span> netmask, <span class="keyword">ip_t</span> gateway,</span></span></span><br><span class="line"><span class="function"><span class="params">	INCOMING_CALLBACK incoming, SENDBUF_CALLBACK sendbuf, DELAY_CALLBACK <span class="built_in">delay</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buf,  <span class="keyword">unsigned</span> short len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_udp</span><span class="params">(struct address* addr, <span class="keyword">void</span>* buf,  <span class="keyword">unsigned</span> short len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>顾名思义</p>
<ol>
<li>init_udp 是初始化函数, 需要提供 ip 地址和 mac 地址. 另外需要提供三个回调函数.</li>
<li>process 函数是当主程序接收到数据帧时需要调用的函数, 直接将以太网数据帧和 size 传入即可. 协议栈会进行处理 (现在可处理 arp 请求, icmp ping 请求, 和 udp 数据)</li>
<li>send_udp 函数是主程序发送 udp 数据的函数, 需要把对端 ip 和端口以及本地端口存入 struct address 结构体中.</li>
</ol>
<p>另外在 init_udp 函数中的三个回调函数:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*INCOMING_CALLBACK)(<span class="keyword">struct</span> address* addr, <span class="keyword">unsigned</span> <span class="keyword">char</span>* buf,  <span class="keyword">unsigned</span> <span class="keyword">short</span> len);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*SENDBUF_CALLBACK)(<span class="keyword">void</span>* buf,  <span class="keyword">unsigned</span> <span class="keyword">short</span> len);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*DELAY_CALLBACK)(<span class="keyword">int</span> ms);</span><br></pre></td></tr></table></figure>

<p>分别是</p>
<ol>
<li>当有 UDP 数据到达时被调用</li>
<li>当需要发送数据时被调用</li>
<li>当需要 sleep 时调用</li>
</ol>
<p><strong>INCOMING_CALLBACK</strong> 函数的 addr 参数传来对端的 ip 端口和本地端口号, buf 中的是 <span style="color: red">UDP 数据</span>, 不包含任何报头</p>
<p>SENDBUF_CALLBACK 函数传来 buf, <span style="color: red">SENDBUF_CALLBACK </span><code>需要将 buf 中的数据写入一个缓冲区</code> (可以是<code>硬件缓冲区</code>中). SENDBUF_CALLBACK 函数会被<code>多次</code>调用, 应当<code>依次将 buf 中数据写入缓冲</code>.</p>
<p>当 SENDBUF_CALLBACK <span style="color: red">最后一次被调用时, buf 会传入 </span><code>NULL</code>. 此时, <span style="color: red">SENDBUF_CALLBACK 函数</span><code>应当将缓冲区中数据发送到以太网上</code>.</p>
<p>DELAY_CALLBACK 函数需要休眠指定的毫秒数, 如果程序运行在一个 RTOS 上的话可以调用 SLEEP 来让出处理器. 如果是裸板程序的话… 那就用循环吧 (这个协议栈在通过 arp 协议查找 mac 地址时会等待, 但最多不超过 1000 毫秒 [这个数值可以改]).</p>
<p>如果不能忍受等待的话, 可以将要紧任务放到中断中处理 (这个常识应该都用吧)</p>
<p>大致就是这样. 下午就是在板子上简单的测试了一下, 基本可用, 能收发 udp 包, 能 ping 通.</p>
<p>源码如下: (不做任何担保, 用了出事不怪我, 逃…</p>
<p><a href="https://lengzzz.com/udp/udp-0.3.zip">https://lengzzz.com/udp/udp-0.3.zip</a></p>
<p>最后上图:<br><img src="/images/13880d8baedd7994327526f1a8aa7556.png" alt="image_1bl057v6q5uq1rbf1b5ejk311q9.png-579.9kB"><br><img src="/images/27fff57e412e0967ec53c768c9485894.png" alt="image_1bl058hv31jct1gsd4slnej20dm.png-68.2kB"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/协议栈/">协议栈</a><a href="/tags/网络编程/">网络编程</a><a href="/tags/UDP/">UDP</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'lengzzz';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 wastecat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47471611-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>